; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.4035 

	TITLE	.\loadutil.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??0SLoadedFace@GXU@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@SLoadedFace@GXU@@QAEXKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitEmpty@SLoadedFace@GXU@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVertexColor@GXU@@YAJPAUSLoadedFace@1@KAAUD3DXCOLOR@@PAPAUSLoadVertex@1@PAK3@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SLoadVertex@GXU@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVertexAttributes@GXU@@YAJPAUSLoadedFace@1@KPAUD3DXVECTOR3@@PAUD3DXVECTOR2@@PAPAUSLoadVertex@1@PAK4@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSmoothingGroup@GXU@@YAJPAUSLoadedFace@1@KGAAUD3DXVECTOR3@@PAPAUSLoadVertex@1@PAK3@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindPoint@GXU@@YAKPAKKPAUSLoadVertex@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitVertices@GXU@@YAJAAPAUSLoadVertex@1@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitCorners@GXU@@YAJAAPAUSCorner@1@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SCorner@GXU@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitFaces@GXU@@YAJAAPAUSLoadedFace@1@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BEqualWedges@GXU@@YA_NAAUSLoadVertex@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertColor@GXU@@YAKAAUD3DXCOLOR@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMesh@GXU@@YAJAAPAUSLoadedFace@1@KAAPAUSLoadVertex@1@KPAUSCorner@1@KPAUSFVFData@1@HPAKKKPAUIDirect3DDevice9@@PAPAUID3DXMesh@@PAPAUID3DXBuffer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateMaterialBuffer@GXU@@YAJPAU_D3DXMATERIAL@@KPAPAUID3DXBuffer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeMaterialBuffers@GXU@@YAJPAUID3DXBuffer@@K0KPAPAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AddToDynamicArray@USLoadVertex@GXU@@@@YAHPAPAUSLoadVertex@GXU@@ABU01@PAK2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CbTexCoordSize@DXCrackFVF@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PuvGetTex1@DXCrackFVF@@QAEPAUD3DXVECTOR2@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CTexCoords@DXCrackFVF@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSpecular@DXCrackFVF@@QAEXPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BSpecular@DXCrackFVF@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWeight@DXCrackFVF@@QAEXPAXIM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CWeights@DXCrackFVF@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTex1@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR2@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDiffuse@DXCrackFVF@@QAEXPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNormal@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BTex1@DXCrackFVF@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BDiffuse@DXCrackFVF@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_0D3DXVECTOR3@@QAEAAU0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BNormal@DXCrackFVF@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTexCoordSizes@DXCrackFVF@@QAEXPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DXCrackFVF@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8D3DXVECTOR2@@QBEHABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8D3DXVECTOR3@@QBEHABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9D3DXVECTOR2@@QBEHABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9D3DXVECTOR3@@QBEHABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8D3DXCOLOR@@QBEHABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9D3DXCOLOR@@QBEHABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

CONST	SEGMENT
_x_rgdwTexCoordSize DD 08H
	DD	0cH
	DD	010H
	DD	04H
CONST	ENDS
PUBLIC	?Init@SLoadedFace@GXU@@QAEXKKK@Z		; GXU::SLoadedFace::Init
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\loadutil.h
;	COMDAT ?Init@SLoadedFace@GXU@@QAEXKKK@Z
_TEXT	SEGMENT
_w0$ = 8						; size = 4
_w1$ = 12						; size = 4
_w2$ = 16						; size = 4
?Init@SLoadedFace@GXU@@QAEXKKK@Z PROC NEAR		; GXU::SLoadedFace::Init, COMDAT
; _this$ = ecx

; 63   :     }

  00000	8b ff		 npad	 2

; 55   :     {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 56   :         m_bColorSpecified = false;
; 57   :         m_bMaterialSpecified = false;
; 58   :         m_bAttributeSpecified = false;
; 59   :         m_bSmoothingGroupSpecified = false;
; 60   :         m_wIndices[0] = w0;

  00005	8b 45 08	 mov	 eax, DWORD PTR _w0$[ebp]
  00008	80 61 0c f0	 and	 BYTE PTR [ecx+12], -16	; fffffff0H
  0000c	89 01		 mov	 DWORD PTR [ecx], eax

; 61   :         m_wIndices[1] = w1;

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _w1$[ebp]
  00011	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 62   :         m_wIndices[2] = w2;

  00014	8b 45 10	 mov	 eax, DWORD PTR _w2$[ebp]
  00017	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 63   :     }

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
?Init@SLoadedFace@GXU@@QAEXKKK@Z ENDP			; GXU::SLoadedFace::Init
_TEXT	ENDS
PUBLIC	?InitEmpty@SLoadedFace@GXU@@QAEXXZ		; GXU::SLoadedFace::InitEmpty
; Function compile flags: /Ogs
;	COMDAT ?InitEmpty@SLoadedFace@GXU@@QAEXXZ
_TEXT	SEGMENT
?InitEmpty@SLoadedFace@GXU@@QAEXXZ PROC NEAR		; GXU::SLoadedFace::InitEmpty, COMDAT
; _this$ = ecx

; 67   :         Init(UNUSED32, UNUSED32, UNUSED32);

  00000	80 61 0c f0	 and	 BYTE PTR [ecx+12], -16	; fffffff0H
  00004	83 09 ff	 or	 DWORD PTR [ecx], -1
  00007	83 49 04 ff	 or	 DWORD PTR [ecx+4], -1
  0000b	83 49 08 ff	 or	 DWORD PTR [ecx+8], -1

; 68   :     }

  0000f	c3		 ret	 0
?InitEmpty@SLoadedFace@GXU@@QAEXXZ ENDP			; GXU::SLoadedFace::InitEmpty
_TEXT	ENDS
PUBLIC	?FindPoint@GXU@@YAKPAKKPAUSLoadVertex@1@@Z	; GXU::FindPoint
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\loadutil.cpp
;	COMDAT ?FindPoint@GXU@@YAKPAKKPAUSLoadVertex@1@@Z
_TEXT	SEGMENT
_pwIndices$ = 8						; size = 4
_iPointSearch$ = 12					; size = 4
_rglvVerts$ = 16					; size = 4
?FindPoint@GXU@@YAKPAKKPAUSLoadVertex@1@@Z PROC NEAR	; GXU::FindPoint, COMDAT

; 369  :         {
; 370  :             break;
; 371  :         }
; 372  :     }
; 373  : 
; 374  :     return iPoint;
; 375  : }

  00000	8b ff		 npad	 2

; 359  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 360  :     DWORD iPoint;
; 361  : 
; 362  :     // get the representative for the point, so that we can compare
; 363  :     //   them, this function compares the logical points in the mesh
; 364  :     DWORD wPointSearchRep = rglvVerts[iPointSearch].m_wPointRep;

  00005	8b 45 0c	 mov	 eax, DWORD PTR _iPointSearch$[ebp]
  00008	8b 4d 10	 mov	 ecx, DWORD PTR _rglvVerts$[ebp]
  0000b	6b c0 44	 imul	 eax, 68			; 00000044H
  0000e	8b 54 08 30	 mov	 edx, DWORD PTR [eax+ecx+48]

; 365  : 
; 366  :     for (iPoint = 0; iPoint < 3; iPoint++)

  00012	33 c0		 xor	 eax, eax
  00014	56		 push	 esi
$L56512:

; 367  :     {
; 368  :         if (rglvVerts[pwIndices[iPoint]].m_wPointRep == wPointSearchRep)

  00015	8b 75 08	 mov	 esi, DWORD PTR _pwIndices$[ebp]
  00018	8b 34 86	 mov	 esi, DWORD PTR [esi+eax*4]
  0001b	6b f6 44	 imul	 esi, 68			; 00000044H
  0001e	39 54 0e 30	 cmp	 DWORD PTR [esi+ecx+48], edx
  00022	74 06		 je	 SHORT $L57037
  00024	40		 inc	 eax
  00025	83 f8 03	 cmp	 eax, 3
  00028	72 eb		 jb	 SHORT $L56512
$L57037:
  0002a	5e		 pop	 esi

; 369  :         {
; 370  :             break;
; 371  :         }
; 372  :     }
; 373  : 
; 374  :     return iPoint;
; 375  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?FindPoint@GXU@@YAKPAKKPAUSLoadVertex@1@@Z ENDP		; GXU::FindPoint
_TEXT	ENDS
PUBLIC	_sqrtf
EXTRN	__fltused:NEAR
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\crt\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 458  :         {return ((float)sqrt((double)_X)); }

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00008	d9 fa		 fsqrt
  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR2@@QAE@XZ				; D3DXVECTOR2::D3DXVECTOR2
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.h
;	COMDAT ??0D3DXVECTOR2@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR2@@QAE@XZ PROC NEAR			; D3DXVECTOR2::D3DXVECTOR2, COMDAT
; _this$ = ecx

; 91   :     D3DXVECTOR2() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR2@@QAE@XZ ENDP				; D3DXVECTOR2::D3DXVECTOR2
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogs
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 165  :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	?ConvertColor@GXU@@YAKAAUD3DXCOLOR@@@Z		; GXU::ConvertColor
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@437f0000
PUBLIC	__real@3f000000
EXTRN	__ftol:NEAR
;	COMDAT __real@00000000
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\loadutil.cpp
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Ogs
CONST	ENDS
;	COMDAT ?ConvertColor@GXU@@YAKAAUD3DXCOLOR@@@Z
_TEXT	SEGMENT
__g$ = -4						; size = 4
__r$ = 8						; size = 4
_color$ = 8						; size = 4
?ConvertColor@GXU@@YAKAAUD3DXCOLOR@@@Z PROC NEAR	; GXU::ConvertColor, COMDAT

; 488  : }

  00000	8b ff		 npad	 2

; 473  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 474  :     DWORD _r, _g, _b, _a;
; 475  :     if (color.r < 0.0f) _r = 0;

  00006	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _color$[ebp]
  00011	d8 16		 fcom	 DWORD PTR [esi]
  00013	57		 push	 edi
  00014	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  0001a	bf ff 00 00 00	 mov	 edi, 255		; 000000ffH
  0001f	df e0		 fnstsw	 ax
  00021	f6 c4 41	 test	 ah, 65			; 00000041H
  00024	75 06		 jne	 SHORT $L56595
  00026	83 65 08 00	 and	 DWORD PTR __r$[ebp], 0

; 476  :     else if (color.r > 1.0f) _r = 0xff;

  0002a	eb 24		 jmp	 SHORT $L56598
$L56595:
  0002c	d8 16		 fcom	 DWORD PTR [esi]
  0002e	df e0		 fnstsw	 ax
  00030	f6 c4 05	 test	 ah, 5
  00033	7a 05		 jp	 SHORT $L56597
  00035	89 7d 08	 mov	 DWORD PTR __r$[ebp], edi

; 477  :     else _r = (DWORD) (color.r*255.0f+0.5f);

  00038	eb 16		 jmp	 SHORT $L56598
$L56597:
  0003a	d9 06		 fld	 DWORD PTR [esi]
  0003c	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@437f0000
  00042	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f000000
  00048	e8 00 00 00 00	 call	 __ftol
  0004d	89 45 08	 mov	 DWORD PTR __r$[ebp], eax
$L56598:

; 478  :     if (color.g < 0.0f) _g = 0;

  00050	d9 46 04	 fld	 DWORD PTR [esi+4]
  00053	d8 da		 fcomp	 ST(2)
  00055	df e0		 fnstsw	 ax
  00057	f6 c4 05	 test	 ah, 5
  0005a	7a 06		 jp	 SHORT $L56600
  0005c	83 65 fc 00	 and	 DWORD PTR __g$[ebp], 0

; 479  :     else if (color.g > 1.0f) _g = 0xff;

  00060	eb 26		 jmp	 SHORT $L56603
$L56600:
  00062	d8 56 04	 fcom	 DWORD PTR [esi+4]
  00065	df e0		 fnstsw	 ax
  00067	f6 c4 05	 test	 ah, 5
  0006a	7a 05		 jp	 SHORT $L56602
  0006c	89 7d fc	 mov	 DWORD PTR __g$[ebp], edi

; 480  :     else _g = (DWORD) (color.g*255.0f+0.5f);

  0006f	eb 17		 jmp	 SHORT $L56603
$L56602:
  00071	d9 46 04	 fld	 DWORD PTR [esi+4]
  00074	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@437f0000
  0007a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f000000
  00080	e8 00 00 00 00	 call	 __ftol
  00085	89 45 fc	 mov	 DWORD PTR __g$[ebp], eax
$L56603:

; 481  :     if (color.b < 0.0f) _b = 0;

  00088	d9 46 08	 fld	 DWORD PTR [esi+8]
  0008b	d8 da		 fcomp	 ST(2)
  0008d	df e0		 fnstsw	 ax
  0008f	f6 c4 05	 test	 ah, 5
  00092	7a 06		 jp	 SHORT $L56605
  00094	dd d8		 fstp	 ST(0)
  00096	33 db		 xor	 ebx, ebx

; 482  :     else if (color.b > 1.0f) _b = 0xff;

  00098	eb 24		 jmp	 SHORT $L56608
$L56605:
  0009a	d8 5e 08	 fcomp	 DWORD PTR [esi+8]
  0009d	df e0		 fnstsw	 ax
  0009f	f6 c4 05	 test	 ah, 5
  000a2	7a 04		 jp	 SHORT $L56607
  000a4	8b df		 mov	 ebx, edi

; 483  :     else _b = (DWORD) (color.b*255.0f+0.5f);

  000a6	eb 16		 jmp	 SHORT $L56608
$L56607:
  000a8	d9 46 08	 fld	 DWORD PTR [esi+8]
  000ab	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@437f0000
  000b1	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f000000
  000b7	e8 00 00 00 00	 call	 __ftol
  000bc	8b d8		 mov	 ebx, eax
$L56608:

; 484  :     if (color.a < 0.0f) _a = 0;

  000be	d8 5e 0c	 fcomp	 DWORD PTR [esi+12]
  000c1	df e0		 fnstsw	 ax
  000c3	f6 c4 41	 test	 ah, 65			; 00000041H
  000c6	75 04		 jne	 SHORT $L56610
  000c8	33 c0		 xor	 eax, eax

; 485  :     else if (color.a > 1.0f) _a = 0xff;

  000ca	eb 28		 jmp	 SHORT $L56613
$L56610:
  000cc	d9 46 0c	 fld	 DWORD PTR [esi+12]
  000cf	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f800000
  000d5	df e0		 fnstsw	 ax
  000d7	f6 c4 41	 test	 ah, 65			; 00000041H
  000da	75 04		 jne	 SHORT $L56612
  000dc	8b c7		 mov	 eax, edi

; 486  :     else _a = (DWORD) (color.a*255.0f+0.5f);

  000de	eb 14		 jmp	 SHORT $L56613
$L56612:
  000e0	d9 46 0c	 fld	 DWORD PTR [esi+12]
  000e3	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@437f0000
  000e9	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f000000
  000ef	e8 00 00 00 00	 call	 __ftol
$L56613:

; 487  :     return RGBA_MAKE( _r, _g, _b, _a);

  000f4	c1 e0 08	 shl	 eax, 8
  000f7	0b 45 08	 or	 eax, DWORD PTR __r$[ebp]
  000fa	5f		 pop	 edi
  000fb	c1 e0 08	 shl	 eax, 8
  000fe	0b 45 fc	 or	 eax, DWORD PTR __g$[ebp]
  00101	5e		 pop	 esi
  00102	c1 e0 08	 shl	 eax, 8
  00105	0b c3		 or	 eax, ebx
  00107	5b		 pop	 ebx

; 488  : }

  00108	c9		 leave
  00109	c3		 ret	 0
?ConvertColor@GXU@@YAKAAUD3DXCOLOR@@@Z ENDP		; GXU::ConvertColor
_TEXT	ENDS
PUBLIC	??0D3DXCOLOR@@QAE@XZ				; D3DXCOLOR::D3DXCOLOR
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.h
;	COMDAT ??0D3DXCOLOR@@QAE@XZ
_TEXT	SEGMENT
??0D3DXCOLOR@@QAE@XZ PROC NEAR				; D3DXCOLOR::D3DXCOLOR, COMDAT
; _this$ = ecx

; 516  :     D3DXCOLOR() {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXCOLOR@@QAE@XZ ENDP				; D3DXCOLOR::D3DXCOLOR
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR2@@QAE@MM@Z			; D3DXVECTOR2::D3DXVECTOR2
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
??0D3DXVECTOR2@@QAE@MM@Z PROC NEAR			; D3DXVECTOR2::D3DXVECTOR2, COMDAT
; _this$ = ecx

; 93   : }

  00000	8b ff		 npad	 2

; 90   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx

; 91   :     x = fx;

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _fx$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 92   :     y = fy;

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _fy$[ebp]
  0000f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 93   : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??0D3DXVECTOR2@@QAE@MM@Z ENDP				; D3DXVECTOR2::D3DXVECTOR2
_TEXT	ENDS
PUBLIC	??8D3DXVECTOR2@@QBEHABU0@@Z			; D3DXVECTOR2::operator==
; Function compile flags: /Ogs
;	COMDAT ??8D3DXVECTOR2@@QBEHABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??8D3DXVECTOR2@@QBEHABU0@@Z PROC NEAR			; D3DXVECTOR2::operator==, COMDAT
; _this$ = ecx

; 195  : }

  00000	8b ff		 npad	 2

; 193  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 194  :     return x == v.x && y == v.y;

  00005	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00008	d9 02		 fld	 DWORD PTR [edx]
  0000a	d9 01		 fld	 DWORD PTR [ecx]
  0000c	da e9		 fucompp
  0000e	df e0		 fnstsw	 ax
  00010	f6 c4 44	 test	 ah, 68			; 00000044H
  00013	7a 14		 jp	 SHORT $L57059
  00015	d9 42 04	 fld	 DWORD PTR [edx+4]
  00018	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0001b	da e9		 fucompp
  0001d	df e0		 fnstsw	 ax
  0001f	f6 c4 44	 test	 ah, 68			; 00000044H
  00022	7a 05		 jp	 SHORT $L57059
  00024	33 c0		 xor	 eax, eax
  00026	40		 inc	 eax
  00027	eb 02		 jmp	 SHORT $L57060
$L57059:
  00029	33 c0		 xor	 eax, eax
$L57060:

; 195  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??8D3DXVECTOR2@@QBEHABU0@@Z ENDP			; D3DXVECTOR2::operator==
_TEXT	ENDS
PUBLIC	??9D3DXVECTOR2@@QBEHABU0@@Z			; D3DXVECTOR2::operator!=
; Function compile flags: /Ogs
;	COMDAT ??9D3DXVECTOR2@@QBEHABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??9D3DXVECTOR2@@QBEHABU0@@Z PROC NEAR			; D3DXVECTOR2::operator!=, COMDAT
; _this$ = ecx

; 201  : }

  00000	8b ff		 npad	 2

; 199  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 200  :     return x != v.x || y != v.y;

  00005	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00008	d9 02		 fld	 DWORD PTR [edx]
  0000a	d9 01		 fld	 DWORD PTR [ecx]
  0000c	da e9		 fucompp
  0000e	df e0		 fnstsw	 ax
  00010	f6 c4 44	 test	 ah, 68			; 00000044H
  00013	7a 13		 jp	 SHORT $L57062
  00015	d9 42 04	 fld	 DWORD PTR [edx+4]
  00018	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0001b	da e9		 fucompp
  0001d	df e0		 fnstsw	 ax
  0001f	f6 c4 44	 test	 ah, 68			; 00000044H
  00022	7a 04		 jp	 SHORT $L57062
  00024	33 c0		 xor	 eax, eax
  00026	eb 03		 jmp	 SHORT $L57063
$L57062:
  00028	33 c0		 xor	 eax, eax
  0002a	40		 inc	 eax
$L57063:

; 201  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??9D3DXVECTOR2@@QBEHABU0@@Z ENDP			; D3DXVECTOR2::operator!=
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogs
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 308  : }

  00000	8b ff		 npad	 2

; 304  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx

; 305  :     x = fx;

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _fx$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 306  :     y = fy;

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _fy$[ebp]
  0000f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 307  :     z = fz;

  00012	8b 4d 10	 mov	 ecx, DWORD PTR _fz$[ebp]
  00015	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 308  : }

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z			; D3DXVECTOR3::operator+=
; Function compile flags: /Ogs
;	COMDAT ??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z PROC NEAR		; D3DXVECTOR3::operator+=, COMDAT
; _this$ = ecx

; 332  :     return *this;
; 333  : }

  00000	8b ff		 npad	 2

; 328  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx

; 329  :     x += v.x;

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0000a	d9 01		 fld	 DWORD PTR [ecx]
  0000c	d8 00		 fadd	 DWORD PTR [eax]
  0000e	d9 18		 fstp	 DWORD PTR [eax]

; 330  :     y += v.y;

  00010	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00013	d8 40 04	 fadd	 DWORD PTR [eax+4]
  00016	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 331  :     z += v.z;

  00019	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0001c	d8 40 08	 fadd	 DWORD PTR [eax+8]
  0001f	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 332  :     return *this;
; 333  : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+=
_TEXT	ENDS
PUBLIC	??_0D3DXVECTOR3@@QAEAAU0@M@Z			; D3DXVECTOR3::operator/=
; Function compile flags: /Ogs
;	COMDAT ??_0D3DXVECTOR3@@QAEAAU0@M@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
??_0D3DXVECTOR3@@QAEAAU0@M@Z PROC NEAR			; D3DXVECTOR3::operator/=, COMDAT
; _this$ = ecx

; 360  :     return *this;
; 361  : }

  00000	8b ff		 npad	 2

; 355  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 356  :     FLOAT fInv = 1.0f / f;

  00005	d9 e8		 fld1
  00007	8b c1		 mov	 eax, ecx
  00009	d8 75 08	 fdiv	 DWORD PTR _f$[ebp]

; 357  :     x *= fInv;

  0000c	d9 c0		 fld	 ST(0)
  0000e	d8 08		 fmul	 DWORD PTR [eax]
  00010	d9 18		 fstp	 DWORD PTR [eax]

; 358  :     y *= fInv;

  00012	d9 c0		 fld	 ST(0)
  00014	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00017	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 359  :     z *= fInv;

  0001a	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001d	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 360  :     return *this;
; 361  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_0D3DXVECTOR3@@QAEAAU0@M@Z ENDP			; D3DXVECTOR3::operator/=
_TEXT	ENDS
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator-
; Function compile flags: /Ogs
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC NEAR		; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 389  : }

  00000	8b ff		 npad	 2

; 387  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 388  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00005	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00008	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0000b	d8 60 08	 fsub	 DWORD PTR [eax+8]
  0000e	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00011	d8 60 04	 fsub	 DWORD PTR [eax+4]
  00014	d9 01		 fld	 DWORD PTR [ecx]
  00016	d8 20		 fsub	 DWORD PTR [eax]
  00018	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001b	d9 18		 fstp	 DWORD PTR [eax]
  0001d	d9 58 04	 fstp	 DWORD PTR [eax+4]
  00020	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 389  : }

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-
_TEXT	ENDS
PUBLIC	??8D3DXVECTOR3@@QBEHABU0@@Z			; D3DXVECTOR3::operator==
; Function compile flags: /Ogs
;	COMDAT ??8D3DXVECTOR3@@QBEHABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??8D3DXVECTOR3@@QBEHABU0@@Z PROC NEAR			; D3DXVECTOR3::operator==, COMDAT
; _this$ = ecx

; 416  : }

  00000	8b ff		 npad	 2

; 414  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 415  :     return x == v.x && y == v.y && z == v.z;

  00005	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00008	d9 02		 fld	 DWORD PTR [edx]
  0000a	d9 01		 fld	 DWORD PTR [ecx]
  0000c	da e9		 fucompp
  0000e	df e0		 fnstsw	 ax
  00010	f6 c4 44	 test	 ah, 68			; 00000044H
  00013	7a 23		 jp	 SHORT $L57075
  00015	d9 42 04	 fld	 DWORD PTR [edx+4]
  00018	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0001b	da e9		 fucompp
  0001d	df e0		 fnstsw	 ax
  0001f	f6 c4 44	 test	 ah, 68			; 00000044H
  00022	7a 14		 jp	 SHORT $L57075
  00024	d9 42 08	 fld	 DWORD PTR [edx+8]
  00027	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0002a	da e9		 fucompp
  0002c	df e0		 fnstsw	 ax
  0002e	f6 c4 44	 test	 ah, 68			; 00000044H
  00031	7a 05		 jp	 SHORT $L57075
  00033	33 c0		 xor	 eax, eax
  00035	40		 inc	 eax
  00036	eb 02		 jmp	 SHORT $L57076
$L57075:
  00038	33 c0		 xor	 eax, eax
$L57076:

; 416  : }

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
??8D3DXVECTOR3@@QBEHABU0@@Z ENDP			; D3DXVECTOR3::operator==
_TEXT	ENDS
PUBLIC	??9D3DXVECTOR3@@QBEHABU0@@Z			; D3DXVECTOR3::operator!=
; Function compile flags: /Ogs
;	COMDAT ??9D3DXVECTOR3@@QBEHABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??9D3DXVECTOR3@@QBEHABU0@@Z PROC NEAR			; D3DXVECTOR3::operator!=, COMDAT
; _this$ = ecx

; 422  : }

  00000	8b ff		 npad	 2

; 420  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 421  :     return x != v.x || y != v.y || z != v.z;

  00005	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00008	d9 02		 fld	 DWORD PTR [edx]
  0000a	d9 01		 fld	 DWORD PTR [ecx]
  0000c	da e9		 fucompp
  0000e	df e0		 fnstsw	 ax
  00010	f6 c4 44	 test	 ah, 68			; 00000044H
  00013	7a 22		 jp	 SHORT $L57078
  00015	d9 42 04	 fld	 DWORD PTR [edx+4]
  00018	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0001b	da e9		 fucompp
  0001d	df e0		 fnstsw	 ax
  0001f	f6 c4 44	 test	 ah, 68			; 00000044H
  00022	7a 13		 jp	 SHORT $L57078
  00024	d9 42 08	 fld	 DWORD PTR [edx+8]
  00027	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0002a	da e9		 fucompp
  0002c	df e0		 fnstsw	 ax
  0002e	f6 c4 44	 test	 ah, 68			; 00000044H
  00031	7a 04		 jp	 SHORT $L57078
  00033	33 c0		 xor	 eax, eax
  00035	eb 03		 jmp	 SHORT $L57079
$L57078:
  00037	33 c0		 xor	 eax, eax
  00039	40		 inc	 eax
$L57079:

; 422  : }

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
??9D3DXVECTOR3@@QBEHABU0@@Z ENDP			; D3DXVECTOR3::operator!=
_TEXT	ENDS
PUBLIC	?CreateMaterialBuffer@GXU@@YAJPAU_D3DXMATERIAL@@KPAPAUID3DXBuffer@@@Z ; GXU::CreateMaterialBuffer
EXTRN	_D3DXCreateBuffer@8:NEAR
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\loadutil.cpp
;	COMDAT ?CreateMaterialBuffer@GXU@@YAJPAU_D3DXMATERIAL@@KPAPAUID3DXBuffer@@@Z
_TEXT	SEGMENT
_hr$ = -20						; size = 4
tv318 = -16						; size = 4
_rgmatOut$ = -12					; size = 4
tv88 = -8						; size = 4
_iCurOffset$ = -8					; size = 4
_pbufMaterialsOut$ = -4					; size = 4
_rgmat$ = 8						; size = 4
tv156 = 12						; size = 4
_cmat$ = 12						; size = 4
_ppbufMaterials$ = 16					; size = 4
?CreateMaterialBuffer@GXU@@YAJPAU_D3DXMATERIAL@@KPAPAUID3DXBuffer@@@Z PROC NEAR ; GXU::CreateMaterialBuffer, COMDAT

; 1011 : }

  00000	8b ff		 npad	 2

; 960  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H
  00008	53		 push	 ebx
  00009	56		 push	 esi

; 961  :     HRESULT hr = S_OK;
; 962  :     DWORD cbTotalStringSize;
; 963  :     DWORD iCurOffset;
; 964  :     DWORD imat;
; 965  :     LPD3DXBUFFER pbufMaterialsOut = NULL;
; 966  :     LPD3DXMATERIAL rgmatOut;
; 967  :     DWORD cbName;
; 968  : 
; 969  :     // first calculate the amount of memory needed for the string buffers
; 970  :     cbTotalStringSize = 0;
; 971  :     for (imat = 0; imat < cmat; imat++)

  0000a	8b 75 0c	 mov	 esi, DWORD PTR _cmat$[ebp]
  0000d	33 c9		 xor	 ecx, ecx
  0000f	3b f1		 cmp	 esi, ecx
  00011	57		 push	 edi
  00012	89 4d fc	 mov	 DWORD PTR _pbufMaterialsOut$[ebp], ecx
  00015	76 27		 jbe	 SHORT $L57088
  00017	8b 7d 08	 mov	 edi, DWORD PTR _rgmat$[ebp]
  0001a	83 c7 44	 add	 edi, 68			; 00000044H
  0001d	89 75 f8	 mov	 DWORD PTR tv88[ebp], esi
$L57090:

; 972  :     {
; 973  :         if (rgmat[imat].pTextureFilename != NULL)

  00020	8b 07		 mov	 eax, DWORD PTR [edi]
  00022	85 c0		 test	 eax, eax
  00024	74 10		 je	 SHORT $L56880

; 974  :         {
; 975  :             cbTotalStringSize += strlen(rgmat[imat].pTextureFilename) + 1;

  00026	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
$L57085:
  00029	8a 10		 mov	 dl, BYTE PTR [eax]
  0002b	40		 inc	 eax
  0002c	84 d2		 test	 dl, dl
  0002e	75 f9		 jne	 SHORT $L57085
  00030	2b c3		 sub	 eax, ebx
  00032	8d 4c 01 01	 lea	 ecx, DWORD PTR [ecx+eax+1]
$L56880:
  00036	83 c7 48	 add	 edi, 72			; 00000048H
  00039	ff 4d f8	 dec	 DWORD PTR tv88[ebp]
  0003c	75 e2		 jne	 SHORT $L57090
$L57088:

; 976  :         }
; 977  :     }
; 978  : 
; 979  :     hr = D3DXCreateBuffer(sizeof(D3DXMATERIAL) * cmat + cbTotalStringSize, &pbufMaterialsOut);

  0003e	8d 1c f6	 lea	 ebx, DWORD PTR [esi+esi*8]
  00041	8d 45 fc	 lea	 eax, DWORD PTR _pbufMaterialsOut$[ebp]
  00044	50		 push	 eax
  00045	c1 e3 03	 shl	 ebx, 3
  00048	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _D3DXCreateBuffer@8

; 980  :     if (FAILED(hr))

  00051	85 c0		 test	 eax, eax
  00053	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax
  00056	0f 8c 8a 00 00
	00		 jl	 $e_Exit$56886

; 981  :         goto e_Exit;
; 982  : 
; 983  :     rgmatOut = (LPD3DXMATERIAL)pbufMaterialsOut->GetBufferPointer();

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _pbufMaterialsOut$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	50		 push	 eax
  00062	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 984  : 
; 985  :     // fist copy the materials info into the new array (note: string pointers are now incorrect)
; 986  :     memcpy(rgmatOut, rgmat, sizeof(D3DXMATERIAL) * cmat);

  00065	8b 75 08	 mov	 esi, DWORD PTR _rgmat$[ebp]
  00068	8b f8		 mov	 edi, eax
  0006a	8b cb		 mov	 ecx, ebx
  0006c	8b c1		 mov	 eax, ecx
  0006e	c1 e9 02	 shr	 ecx, 2
  00071	89 7d f4	 mov	 DWORD PTR _rgmatOut$[ebp], edi
  00074	f3 a5		 rep movsd
  00076	8b c8		 mov	 ecx, eax
  00078	83 e1 03	 and	 ecx, 3
  0007b	f3 a4		 rep movsb

; 987  : 
; 988  :     // start allocating strings just after the last material
; 989  :     iCurOffset = sizeof(D3DXMATERIAL) * cmat;
; 990  :     for (imat = 0; imat < cmat; imat++)

  0007d	8b 75 0c	 mov	 esi, DWORD PTR _cmat$[ebp]
  00080	85 f6		 test	 esi, esi
  00082	89 5d f8	 mov	 DWORD PTR _iCurOffset$[ebp], ebx
  00085	76 53		 jbe	 SHORT $L56893
  00087	8b 45 08	 mov	 eax, DWORD PTR _rgmat$[ebp]
  0008a	8b 4d f4	 mov	 ecx, DWORD PTR _rgmatOut$[ebp]
  0008d	2b c8		 sub	 ecx, eax
  0008f	8d 50 44	 lea	 edx, DWORD PTR [eax+68]
  00092	89 4d f0	 mov	 DWORD PTR tv318[ebp], ecx
  00095	89 75 0c	 mov	 DWORD PTR tv156[ebp], esi
$L57089:

; 991  :     {
; 992  :         if (rgmat[imat].pTextureFilename != NULL)

  00098	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0009b	74 35		 je	 SHORT $L56892

; 993  :         {
; 994  :             rgmatOut[imat].pTextureFilename = ((char*)rgmatOut) + iCurOffset;

  0009d	8b 45 f8	 mov	 eax, DWORD PTR _iCurOffset$[ebp]
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _rgmatOut$[ebp]
  000a3	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  000a6	8b 45 f0	 mov	 eax, DWORD PTR tv318[ebp]
  000a9	89 3c 10	 mov	 DWORD PTR [eax+edx], edi

; 995  : 
; 996  :             cbName = strlen(rgmat[imat].pTextureFilename) + 1;

  000ac	8b 32		 mov	 esi, DWORD PTR [edx]
  000ae	8b ce		 mov	 ecx, esi
  000b0	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
$L57086:
  000b3	8a 19		 mov	 bl, BYTE PTR [ecx]
  000b5	41		 inc	 ecx
  000b6	84 db		 test	 bl, bl
  000b8	75 f9		 jne	 SHORT $L57086
  000ba	2b c8		 sub	 ecx, eax
  000bc	8d 59 01	 lea	 ebx, DWORD PTR [ecx+1]

; 997  :             memcpy(rgmatOut[imat].pTextureFilename, rgmat[imat].pTextureFilename, cbName);

  000bf	8b cb		 mov	 ecx, ebx
  000c1	8b c1		 mov	 eax, ecx
  000c3	c1 e9 02	 shr	 ecx, 2
  000c6	f3 a5		 rep movsd
  000c8	8b c8		 mov	 ecx, eax
  000ca	83 e1 03	 and	 ecx, 3

; 998  : 
; 999  :             iCurOffset += cbName;

  000cd	01 5d f8	 add	 DWORD PTR _iCurOffset$[ebp], ebx
  000d0	f3 a4		 rep movsb
$L56892:
  000d2	83 c2 48	 add	 edx, 72			; 00000048H
  000d5	ff 4d 0c	 dec	 DWORD PTR tv156[ebp]
  000d8	75 be		 jne	 SHORT $L57089
$L56893:

; 1000 :         }
; 1001 :     }
; 1002 : 
; 1003 :     GXASSERT(iCurOffset == sizeof(D3DXMATERIAL) * cmat + cbTotalStringSize);
; 1004 : 
; 1005 :     *ppbufMaterials = pbufMaterialsOut;

  000da	8b 45 fc	 mov	 eax, DWORD PTR _pbufMaterialsOut$[ebp]
  000dd	8b 4d 10	 mov	 ecx, DWORD PTR _ppbufMaterials$[ebp]

; 1006 :     pbufMaterialsOut = NULL;

  000e0	83 65 fc 00	 and	 DWORD PTR _pbufMaterialsOut$[ebp], 0
  000e4	89 01		 mov	 DWORD PTR [ecx], eax
$e_Exit$56886:

; 1007 : 
; 1008 : e_Exit:
; 1009 :     GXRELEASE(pbufMaterialsOut);

  000e6	8b 45 fc	 mov	 eax, DWORD PTR _pbufMaterialsOut$[ebp]
  000e9	85 c0		 test	 eax, eax
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	5b		 pop	 ebx
  000ee	74 06		 je	 SHORT $L56898
  000f0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f2	50		 push	 eax
  000f3	ff 51 08	 call	 DWORD PTR [ecx+8]
$L56898:

; 1010 :     return hr;

  000f6	8b 45 ec	 mov	 eax, DWORD PTR _hr$[ebp]

; 1011 : }

  000f9	c9		 leave
  000fa	c3		 ret	 0
?CreateMaterialBuffer@GXU@@YAJPAU_D3DXMATERIAL@@KPAPAUID3DXBuffer@@@Z ENDP ; GXU::CreateMaterialBuffer
_TEXT	ENDS
PUBLIC	?MergeMaterialBuffers@GXU@@YAJPAUID3DXBuffer@@K0KPAPAU2@@Z ; GXU::MergeMaterialBuffers
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogs
;	COMDAT ?MergeMaterialBuffers@GXU@@YAJPAUID3DXBuffer@@K0KPAPAU2@@Z
_TEXT	SEGMENT
_rgmatTemp$ = -4					; size = 4
_rgmat2$ = 8						; size = 4
_pbufMat1$ = 8						; size = 4
_cmat1$ = 12						; size = 4
_pbufMat2$ = 16						; size = 4
_cmat2$ = 20						; size = 4
_ppbufMaterials$ = 24					; size = 4
?MergeMaterialBuffers@GXU@@YAJPAUID3DXBuffer@@K0KPAPAU2@@Z PROC NEAR ; GXU::MergeMaterialBuffers, COMDAT

; 1064 : 
; 1065 : }

  00000	8b ff		 npad	 2

; 1015 : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 1016 :     HRESULT hr = S_OK;
; 1017 :     D3DXMATERIAL *rgmatTemp = NULL;
; 1018 :     D3DXMATERIAL *rgmat1;
; 1019 :     D3DXMATERIAL *rgmat2;
; 1020 : 
; 1021 :     if (pbufMat1 == NULL)

  00006	8b 45 08	 mov	 eax, DWORD PTR _pbufMat1$[ebp]
  00009	56		 push	 esi
  0000a	33 f6		 xor	 esi, esi
  0000c	3b c6		 cmp	 eax, esi
  0000e	89 75 fc	 mov	 DWORD PTR _rgmatTemp$[ebp], esi
  00011	75 21		 jne	 SHORT $L56913

; 1022 :     {
; 1023 :         if (pbufMat2 == NULL)

  00013	8b 45 10	 mov	 eax, DWORD PTR _pbufMat2$[ebp]
  00016	3b c6		 cmp	 eax, esi
  00018	75 0a		 jne	 SHORT $L56914

; 1024 :         {
; 1025 :             *ppbufMaterials = NULL;

  0001a	8b 45 18	 mov	 eax, DWORD PTR _ppbufMaterials$[ebp]
  0001d	89 30		 mov	 DWORD PTR [eax], esi

; 1026 :         }
; 1027 :         else

  0001f	e9 a5 00 00 00	 jmp	 $e_Exit$56925
$L56914:

; 1028 :         {
; 1029 :             *ppbufMaterials = pbufMat2;

  00024	8b 4d 18	 mov	 ecx, DWORD PTR _ppbufMaterials$[ebp]
  00027	89 01		 mov	 DWORD PTR [ecx], eax

; 1030 :             pbufMat2->AddRef();

  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	50		 push	 eax
  0002c	ff 51 04	 call	 DWORD PTR [ecx+4]

; 1031 :         }
; 1032 :     }
; 1033 :     else if (pbufMat2 == NULL)

  0002f	e9 95 00 00 00	 jmp	 $e_Exit$56925
$L56913:
  00034	57		 push	 edi
  00035	8b 7d 10	 mov	 edi, DWORD PTR _pbufMat2$[ebp]
  00038	3b fe		 cmp	 edi, esi
  0003a	75 0d		 jne	 SHORT $L56917

; 1034 :     {
; 1035 :         *ppbufMaterials = pbufMat1;

  0003c	8b 4d 18	 mov	 ecx, DWORD PTR _ppbufMaterials$[ebp]
  0003f	89 01		 mov	 DWORD PTR [ecx], eax

; 1036 :         pbufMat1->AddRef();

  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	50		 push	 eax
  00044	ff 51 04	 call	 DWORD PTR [ecx+4]

; 1037 :     }
; 1038 :     else  // both have materials

  00047	eb 7f		 jmp	 SHORT $L57094
$L56917:

; 1039 :     {
; 1040 :         rgmat1 = (LPD3DXMATERIAL)pbufMat1->GetBufferPointer();

  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	53		 push	 ebx
  0004c	50		 push	 eax
  0004d	ff 51 0c	 call	 DWORD PTR [ecx+12]
  00050	8b f0		 mov	 esi, eax

; 1041 :         rgmat2 = (LPD3DXMATERIAL)pbufMat2->GetBufferPointer();

  00052	8b 07		 mov	 eax, DWORD PTR [edi]
  00054	57		 push	 edi
  00055	ff 50 0c	 call	 DWORD PTR [eax+12]

; 1042 : 
; 1043 :         // make an array contains the color info and pointers to the original strings
; 1044 :         //   that is the two arrays combined
; 1045 :         rgmatTemp = new D3DXMATERIAL[cmat1 + cmat2];

  00058	8b 7d 0c	 mov	 edi, DWORD PTR _cmat1$[ebp]
  0005b	89 45 08	 mov	 DWORD PTR _rgmat2$[ebp], eax
  0005e	8b 45 14	 mov	 eax, DWORD PTR _cmat2$[ebp]
  00061	8d 1c 07	 lea	 ebx, DWORD PTR [edi+eax]
  00064	8d 04 db	 lea	 eax, DWORD PTR [ebx+ebx*8]
  00067	c1 e0 03	 shl	 eax, 3
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1046 :         if (rgmatTemp == NULL)

  00070	85 c0		 test	 eax, eax
  00072	59		 pop	 ecx
  00073	89 45 fc	 mov	 DWORD PTR _rgmatTemp$[ebp], eax
  00076	75 07		 jne	 SHORT $L56923

; 1047 :         {
; 1048 :             hr = E_OUTOFMEMORY;

  00078	be 0e 00 07 80	 mov	 esi, -2147024882	; 8007000eH

; 1049 :             goto e_Exit;

  0007d	eb 48		 jmp	 SHORT $L57095
$L56923:

; 1050 :         }
; 1051 : 
; 1052 :         memcpy(rgmatTemp, rgmat1, sizeof(D3DXMATERIAL) * cmat1);

  0007f	8d 04 ff	 lea	 eax, DWORD PTR [edi+edi*8]
  00082	8b 7d fc	 mov	 edi, DWORD PTR _rgmatTemp$[ebp]
  00085	c1 e0 03	 shl	 eax, 3
  00088	8b c8		 mov	 ecx, eax
  0008a	8b d1		 mov	 edx, ecx
  0008c	c1 e9 02	 shr	 ecx, 2
  0008f	f3 a5		 rep movsd

; 1053 :         memcpy(rgmatTemp + cmat1, rgmat2, sizeof(D3DXMATERIAL) * cmat2);
; 1054 : 
; 1055 :         // then use the CreateMaterialBuffer call to take and make a buffer out of the "merged" array
; 1056 :         hr = CreateMaterialBuffer(rgmatTemp, cmat1 + cmat2, ppbufMaterials);

  00091	ff 75 18	 push	 DWORD PTR _ppbufMaterials$[ebp]
  00094	8b ca		 mov	 ecx, edx
  00096	8b 55 fc	 mov	 edx, DWORD PTR _rgmatTemp$[ebp]
  00099	83 e1 03	 and	 ecx, 3
  0009c	f3 a4		 rep movsb
  0009e	8b 4d 14	 mov	 ecx, DWORD PTR _cmat2$[ebp]
  000a1	8b 75 08	 mov	 esi, DWORD PTR _rgmat2$[ebp]
  000a4	8d 0c c9	 lea	 ecx, DWORD PTR [ecx+ecx*8]
  000a7	c1 e1 03	 shl	 ecx, 3
  000aa	8d 3c 10	 lea	 edi, DWORD PTR [eax+edx]
  000ad	8b c1		 mov	 eax, ecx
  000af	c1 e9 02	 shr	 ecx, 2
  000b2	f3 a5		 rep movsd
  000b4	8b c8		 mov	 ecx, eax
  000b6	83 e1 03	 and	 ecx, 3
  000b9	53		 push	 ebx
  000ba	52		 push	 edx
  000bb	f3 a4		 rep movsb
  000bd	e8 00 00 00 00	 call	 ?CreateMaterialBuffer@GXU@@YAJPAU_D3DXMATERIAL@@KPAPAUID3DXBuffer@@@Z ; GXU::CreateMaterialBuffer
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c5	8b f0		 mov	 esi, eax
$L57095:
  000c7	5b		 pop	 ebx
$L57094:
  000c8	5f		 pop	 edi
$e_Exit$56925:

; 1057 :         if (FAILED(hr))
; 1058 :             goto e_Exit;
; 1059 :     }
; 1060 : 
; 1061 : e_Exit:
; 1062 :     delete []rgmatTemp;

  000c9	ff 75 fc	 push	 DWORD PTR _rgmatTemp$[ebp]
  000cc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d1	59		 pop	 ecx

; 1063 :     return hr;

  000d2	8b c6		 mov	 eax, esi
  000d4	5e		 pop	 esi

; 1064 : 
; 1065 : }

  000d5	c9		 leave
  000d6	c3		 ret	 0
?MergeMaterialBuffers@GXU@@YAJPAUID3DXBuffer@@K0KPAPAU2@@Z ENDP ; GXU::MergeMaterialBuffers
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogs
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00008	48		 dec	 eax
  00009	78 15		 js	 SHORT $L56942
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
  0000f	57		 push	 edi
  00010	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
$L56941:
  00013	8b ce		 mov	 ecx, esi
  00015	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00018	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  0001b	4f		 dec	 edi
  0001c	75 f5		 jne	 SHORT $L56941
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
$L56942:
  00020	5d		 pop	 ebp
  00021	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??0D3DXCOLOR@@QAE@MMMM@Z			; D3DXCOLOR::D3DXCOLOR
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.inl
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT
_fr$ = 8						; size = 4
_fg$ = 12						; size = 4
_fb$ = 16						; size = 4
_fa$ = 20						; size = 4
??0D3DXCOLOR@@QAE@MMMM@Z PROC NEAR			; D3DXCOLOR::D3DXCOLOR, COMDAT
; _this$ = ecx

; 1395 : }

  00000	8b ff		 npad	 2

; 1390 : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx

; 1391 :     r = fr;

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _fr$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1392 :     g = fg;

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _fg$[ebp]
  0000f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1393 :     b = fb;

  00012	8b 4d 10	 mov	 ecx, DWORD PTR _fb$[ebp]
  00015	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1394 :     a = fa;

  00018	8b 4d 14	 mov	 ecx, DWORD PTR _fa$[ebp]
  0001b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 1395 : }

  0001e	5d		 pop	 ebp
  0001f	c2 10 00	 ret	 16			; 00000010H
??0D3DXCOLOR@@QAE@MMMM@Z ENDP				; D3DXCOLOR::D3DXCOLOR
_TEXT	ENDS
PUBLIC	??8D3DXCOLOR@@QBEHABU0@@Z			; D3DXCOLOR::operator==
; Function compile flags: /Ogs
;	COMDAT ??8D3DXCOLOR@@QBEHABU0@@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
??8D3DXCOLOR@@QBEHABU0@@Z PROC NEAR			; D3DXCOLOR::operator==, COMDAT
; _this$ = ecx

; 1545 : }

  00000	8b ff		 npad	 2

; 1543 : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1544 :     return r == c.r && g == c.g && b == c.b && a == c.a;

  00005	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00008	d9 02		 fld	 DWORD PTR [edx]
  0000a	d9 01		 fld	 DWORD PTR [ecx]
  0000c	da e9		 fucompp
  0000e	df e0		 fnstsw	 ax
  00010	f6 c4 44	 test	 ah, 68			; 00000044H
  00013	7a 32		 jp	 SHORT $L57101
  00015	d9 42 04	 fld	 DWORD PTR [edx+4]
  00018	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0001b	da e9		 fucompp
  0001d	df e0		 fnstsw	 ax
  0001f	f6 c4 44	 test	 ah, 68			; 00000044H
  00022	7a 23		 jp	 SHORT $L57101
  00024	d9 42 08	 fld	 DWORD PTR [edx+8]
  00027	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0002a	da e9		 fucompp
  0002c	df e0		 fnstsw	 ax
  0002e	f6 c4 44	 test	 ah, 68			; 00000044H
  00031	7a 14		 jp	 SHORT $L57101
  00033	d9 42 0c	 fld	 DWORD PTR [edx+12]
  00036	d9 41 0c	 fld	 DWORD PTR [ecx+12]
  00039	da e9		 fucompp
  0003b	df e0		 fnstsw	 ax
  0003d	f6 c4 44	 test	 ah, 68			; 00000044H
  00040	7a 05		 jp	 SHORT $L57101
  00042	33 c0		 xor	 eax, eax
  00044	40		 inc	 eax
  00045	eb 02		 jmp	 SHORT $L57102
$L57101:
  00047	33 c0		 xor	 eax, eax
$L57102:

; 1545 : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??8D3DXCOLOR@@QBEHABU0@@Z ENDP				; D3DXCOLOR::operator==
_TEXT	ENDS
PUBLIC	??9D3DXCOLOR@@QBEHABU0@@Z			; D3DXCOLOR::operator!=
; Function compile flags: /Ogs
;	COMDAT ??9D3DXCOLOR@@QBEHABU0@@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
??9D3DXCOLOR@@QBEHABU0@@Z PROC NEAR			; D3DXCOLOR::operator!=, COMDAT
; _this$ = ecx

; 1551 : }

  00000	8b ff		 npad	 2

; 1549 : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1550 :     return r != c.r || g != c.g || b != c.b || a != c.a;

  00005	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00008	d9 02		 fld	 DWORD PTR [edx]
  0000a	d9 01		 fld	 DWORD PTR [ecx]
  0000c	da e9		 fucompp
  0000e	df e0		 fnstsw	 ax
  00010	f6 c4 44	 test	 ah, 68			; 00000044H
  00013	7a 31		 jp	 SHORT $L57104
  00015	d9 42 04	 fld	 DWORD PTR [edx+4]
  00018	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0001b	da e9		 fucompp
  0001d	df e0		 fnstsw	 ax
  0001f	f6 c4 44	 test	 ah, 68			; 00000044H
  00022	7a 22		 jp	 SHORT $L57104
  00024	d9 42 08	 fld	 DWORD PTR [edx+8]
  00027	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0002a	da e9		 fucompp
  0002c	df e0		 fnstsw	 ax
  0002e	f6 c4 44	 test	 ah, 68			; 00000044H
  00031	7a 13		 jp	 SHORT $L57104
  00033	d9 42 0c	 fld	 DWORD PTR [edx+12]
  00036	d9 41 0c	 fld	 DWORD PTR [ecx+12]
  00039	da e9		 fucompp
  0003b	df e0		 fnstsw	 ax
  0003d	f6 c4 44	 test	 ah, 68			; 00000044H
  00040	7a 04		 jp	 SHORT $L57104
  00042	33 c0		 xor	 eax, eax
  00044	eb 03		 jmp	 SHORT $L57105
$L57104:
  00046	33 c0		 xor	 eax, eax
  00048	40		 inc	 eax
$L57105:

; 1551 : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??9D3DXCOLOR@@QBEHABU0@@Z ENDP				; D3DXCOLOR::operator!=
_TEXT	ENDS
PUBLIC	?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z		; D3DXVec3Length
; Function compile flags: /Ogs
;	COMDAT ?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pV$ = 8						; size = 4
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z PROC NEAR	; D3DXVec3Length, COMDAT

; 1711 : #else
; 1712 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1713 : #endif
; 1714 : }

  00000	8b ff		 npad	 2

; 1703 : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1704 : #ifdef D3DX_DEBUG
; 1705 :     if(!pV)
; 1706 :         return 0.0f;
; 1707 : #endif
; 1708 : 
; 1709 : #ifdef __cplusplus
; 1710 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00005	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  00008	d9 40 08	 fld	 DWORD PTR [eax+8]
  0000b	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000e	d9 00		 fld	 DWORD PTR [eax]
  00010	d9 c0		 fld	 ST(0)
  00012	d8 c9		 fmul	 ST(0), ST(1)
  00014	d9 c2		 fld	 ST(2)
  00016	d8 cb		 fmul	 ST(0), ST(3)
  00018	de c1		 faddp	 ST(1), ST(0)
  0001a	d9 c3		 fld	 ST(3)
  0001c	d8 cc		 fmul	 ST(0), ST(4)
  0001e	de c1		 faddp	 ST(1), ST(0)
  00020	d9 fa		 fsqrt
  00022	dd db		 fstp	 ST(3)
  00024	dd d8		 fstp	 ST(0)
  00026	dd d8		 fstp	 ST(0)

; 1711 : #else
; 1712 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1713 : #endif
; 1714 : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3Length
_TEXT	ENDS
PUBLIC	?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z	; D3DXVec3Cross
; Function compile flags: /Ogs
;	COMDAT ?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z
_TEXT	SEGMENT
_v$ = -12						; size = 12
_pOut$ = 8						; size = 4
_pV1$ = 12						; size = 4
_pV2$ = 16						; size = 4
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z PROC NEAR ; D3DXVec3Cross, COMDAT

; 1753 :     return pOut;
; 1754 : }

  00000	8b ff		 npad	 2

; 1740 : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1741 :     D3DXVECTOR3 v;
; 1742 : 
; 1743 : #ifdef D3DX_DEBUG
; 1744 :     if(!pOut || !pV1 || !pV2)
; 1745 :         return NULL;
; 1746 : #endif
; 1747 : 
; 1748 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00008	8b 4d 10	 mov	 ecx, DWORD PTR _pV2$[ebp]
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _pV1$[ebp]
  0000e	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00011	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00014	56		 push	 esi
  00015	d9 40 08	 fld	 DWORD PTR [eax+8]
  00018	57		 push	 edi
  00019	d8 49 04	 fmul	 DWORD PTR [ecx+4]

; 1749 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;
; 1750 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;
; 1751 : 
; 1752 :     *pOut = v;

  0001c	8d 75 f4	 lea	 esi, DWORD PTR _v$[ebp]
  0001f	de e9		 fsubp	 ST(1), ST(0)
  00021	d9 5d f4	 fstp	 DWORD PTR _v$[ebp]
  00024	d9 40 08	 fld	 DWORD PTR [eax+8]
  00027	d8 09		 fmul	 DWORD PTR [ecx]
  00029	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0002c	d8 08		 fmul	 DWORD PTR [eax]
  0002e	de e9		 fsubp	 ST(1), ST(0)
  00030	d9 5d f8	 fstp	 DWORD PTR _v$[ebp+4]
  00033	d9 00		 fld	 DWORD PTR [eax]
  00035	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  00038	d9 01		 fld	 DWORD PTR [ecx]
  0003a	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0003d	8b 45 08	 mov	 eax, DWORD PTR _pOut$[ebp]
  00040	8b f8		 mov	 edi, eax
  00042	de e9		 fsubp	 ST(1), ST(0)
  00044	d9 5d fc	 fstp	 DWORD PTR _v$[ebp+8]
  00047	a5		 movsd
  00048	a5		 movsd
  00049	a5		 movsd
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi

; 1753 :     return pOut;
; 1754 : }

  0004c	c9		 leave
  0004d	c3		 ret	 0
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z ENDP	; D3DXVec3Cross
_TEXT	ENDS
PUBLIC	?BNormal@DXCrackFVF@@QAE_NXZ			; DXCrackFVF::BNormal
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\gxcrackfvf.h
;	COMDAT ?BNormal@DXCrackFVF@@QAE_NXZ
_TEXT	SEGMENT
?BNormal@DXCrackFVF@@QAE_NXZ PROC NEAR			; DXCrackFVF::BNormal, COMDAT
; _this$ = ecx

; 70   :     inline bool         BNormal()       { return m_oNormal > 0; }

  00000	33 c0		 xor	 eax, eax
  00002	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00005	1b c0		 sbb	 eax, eax
  00007	f7 d8		 neg	 eax
  00009	c3		 ret	 0
?BNormal@DXCrackFVF@@QAE_NXZ ENDP			; DXCrackFVF::BNormal
_TEXT	ENDS
PUBLIC	?BDiffuse@DXCrackFVF@@QAE_NXZ			; DXCrackFVF::BDiffuse
; Function compile flags: /Ogs
;	COMDAT ?BDiffuse@DXCrackFVF@@QAE_NXZ
_TEXT	SEGMENT
?BDiffuse@DXCrackFVF@@QAE_NXZ PROC NEAR			; DXCrackFVF::BDiffuse, COMDAT
; _this$ = ecx

; 72   :     inline bool         BDiffuse()      { return m_oDiffuse > 0; }

  00000	33 c0		 xor	 eax, eax
  00002	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00005	1b c0		 sbb	 eax, eax
  00007	f7 d8		 neg	 eax
  00009	c3		 ret	 0
?BDiffuse@DXCrackFVF@@QAE_NXZ ENDP			; DXCrackFVF::BDiffuse
_TEXT	ENDS
PUBLIC	?BSpecular@DXCrackFVF@@QAE_NXZ			; DXCrackFVF::BSpecular
; Function compile flags: /Ogs
;	COMDAT ?BSpecular@DXCrackFVF@@QAE_NXZ
_TEXT	SEGMENT
?BSpecular@DXCrackFVF@@QAE_NXZ PROC NEAR		; DXCrackFVF::BSpecular, COMDAT
; _this$ = ecx

; 73   :     inline bool         BSpecular()     { return m_oSpecular > 0; }

  00000	33 c0		 xor	 eax, eax
  00002	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  00005	1b c0		 sbb	 eax, eax
  00007	f7 d8		 neg	 eax
  00009	c3		 ret	 0
?BSpecular@DXCrackFVF@@QAE_NXZ ENDP			; DXCrackFVF::BSpecular
_TEXT	ENDS
PUBLIC	?BTex1@DXCrackFVF@@QAE_NXZ			; DXCrackFVF::BTex1
; Function compile flags: /Ogs
;	COMDAT ?BTex1@DXCrackFVF@@QAE_NXZ
_TEXT	SEGMENT
?BTex1@DXCrackFVF@@QAE_NXZ PROC NEAR			; DXCrackFVF::BTex1, COMDAT
; _this$ = ecx

; 74   :     inline bool         BTex1()         { return m_oTex[0] > 0; }

  00000	33 c0		 xor	 eax, eax
  00002	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00005	1b c0		 sbb	 eax, eax
  00007	f7 d8		 neg	 eax
  00009	c3		 ret	 0
?BTex1@DXCrackFVF@@QAE_NXZ ENDP				; DXCrackFVF::BTex1
_TEXT	ENDS
PUBLIC	?CWeights@DXCrackFVF@@QAEKXZ			; DXCrackFVF::CWeights
; Function compile flags: /Ogs
;	COMDAT ?CWeights@DXCrackFVF@@QAEKXZ
_TEXT	SEGMENT
?CWeights@DXCrackFVF@@QAEKXZ PROC NEAR			; DXCrackFVF::CWeights, COMDAT
; _this$ = ecx

; 76   :     inline DWORD        CWeights()      { return m_cWeights; }

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	c3		 ret	 0
?CWeights@DXCrackFVF@@QAEKXZ ENDP			; DXCrackFVF::CWeights
_TEXT	ENDS
PUBLIC	?CTexCoords@DXCrackFVF@@QAEKXZ			; DXCrackFVF::CTexCoords
; Function compile flags: /Ogs
;	COMDAT ?CTexCoords@DXCrackFVF@@QAEKXZ
_TEXT	SEGMENT
?CTexCoords@DXCrackFVF@@QAEKXZ PROC NEAR		; DXCrackFVF::CTexCoords, COMDAT
; _this$ = ecx

; 77   :     inline DWORD        CTexCoords()    { return m_cTexCoords; }

  00000	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  00003	c3		 ret	 0
?CTexCoords@DXCrackFVF@@QAEKXZ ENDP			; DXCrackFVF::CTexCoords
_TEXT	ENDS
PUBLIC	??0DXCrackFVF@@QAE@K@Z				; DXCrackFVF::DXCrackFVF
; Function compile flags: /Ogs
;	COMDAT ??0DXCrackFVF@@QAE@K@Z
_TEXT	SEGMENT
_dwFVF$ = 8						; size = 4
??0DXCrackFVF@@QAE@K@Z PROC NEAR			; DXCrackFVF::DXCrackFVF, COMDAT
; _this$ = ecx

; 192  : }

  00000	8b ff		 npad	 2

; 115  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx
  00007	53		 push	 ebx
  00008	8b 5d 08	 mov	 ebx, DWORD PTR _dwFVF$[ebp]
  0000b	56		 push	 esi

; 116  :     DWORD oCur = 0;
; 117  :     DWORD dwPosition;
; 118  :     DWORD dwTexCoordInfo;
; 119  :     DWORD iTexCoord;
; 120  :     DWORD dwTexCoordSize;
; 121  :     m_oTex[0] = 0;
; 122  : 
; 123  :     dwPosition = dwFVF & D3DFVF_POSITION_MASK;

  0000c	8b d3		 mov	 edx, ebx
  0000e	57		 push	 edi
  0000f	33 ff		 xor	 edi, edi
  00011	81 e2 0e 40 00
	00		 and	 edx, 16398		; 0000400eH
  00017	33 c9		 xor	 ecx, ecx

; 124  : 
; 125  :     if (dwPosition == D3DFVF_XYZ)

  00019	83 fa 02	 cmp	 edx, 2
  0001c	8d 70 18	 lea	 esi, DWORD PTR [eax+24]
  0001f	89 18		 mov	 DWORD PTR [eax], ebx
  00021	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00024	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00027	89 78 10	 mov	 DWORD PTR [eax+16], edi
  0002a	89 78 14	 mov	 DWORD PTR [eax+20], edi
  0002d	89 78 38	 mov	 DWORD PTR [eax+56], edi
  00030	89 78 3c	 mov	 DWORD PTR [eax+60], edi
  00033	89 3e		 mov	 DWORD PTR [esi], edi
  00035	75 05		 jne	 SHORT $L55537

; 126  :     {
; 127  :         oCur += 3 * sizeof(float);

  00037	6a 0c		 push	 12			; 0000000cH
$L57133:
  00039	59		 pop	 ecx

; 128  :     }
; 129  :     else if (dwPosition == D3DFVF_XYZRHW)

  0003a	eb 1d		 jmp	 SHORT $L57130
$L55537:
  0003c	83 fa 04	 cmp	 edx, 4
  0003f	75 04		 jne	 SHORT $L55540

; 130  :     {
; 131  :         oCur += 4 * sizeof(float);

  00041	6a 10		 push	 16			; 00000010H

; 132  :     }
; 133  :     else if (dwPosition >= D3DFVF_XYZB1)

  00043	eb f4		 jmp	 SHORT $L57133
$L55540:
  00045	83 fa 06	 cmp	 edx, 6
  00048	72 0f		 jb	 SHORT $L57130

; 134  :     {
; 135  :         m_cWeights = (dwPosition >> 1) - 2;

  0004a	d1 ea		 shr	 edx, 1
  0004c	8d 4a fe	 lea	 ecx, DWORD PTR [edx-2]
  0004f	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 136  :         oCur += (3 + m_cWeights) * sizeof(float);

  00052	8d 0c 8d 0c 00
	00 00		 lea	 ecx, DWORD PTR [ecx*4+12]
$L57130:

; 137  :     }
; 138  : 
; 139  :     if ( dwFVF & D3DFVF_NORMAL )

  00059	f6 c3 10	 test	 bl, 16			; 00000010H
  0005c	74 06		 je	 SHORT $L55545

; 140  :     {
; 141  :         m_oNormal = oCur;

  0005e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 142  :         oCur += 3 * sizeof(float);

  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
$L55545:

; 143  :     }
; 144  : 
; 145  :     if ( dwFVF & D3DFVF_PSIZE )

  00064	f6 c3 20	 test	 bl, 32			; 00000020H
  00067	74 06		 je	 SHORT $L57131

; 146  :     {
; 147  :         m_oPointSize = oCur;

  00069	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 148  :         oCur += sizeof(float);

  0006c	83 c1 04	 add	 ecx, 4
$L57131:

; 149  :     }
; 150  : 
; 151  :     if ( dwFVF & D3DFVF_DIFFUSE )

  0006f	f6 c3 40	 test	 bl, 64			; 00000040H
  00072	74 06		 je	 SHORT $L57132

; 152  :     {
; 153  :         m_oDiffuse = oCur;

  00074	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 154  :         oCur += sizeof(D3DCOLOR);

  00077	83 c1 04	 add	 ecx, 4
$L57132:

; 155  :     }
; 156  : 
; 157  :     if ( dwFVF & D3DFVF_SPECULAR )

  0007a	84 db		 test	 bl, bl
  0007c	79 06		 jns	 SHORT $L55551

; 158  :     {
; 159  :         m_oSpecular = oCur;

  0007e	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 160  :         oCur += sizeof(D3DCOLOR);

  00081	83 c1 04	 add	 ecx, 4
$L55551:

; 161  :     }
; 162  : 
; 163  :     if ( dwFVF & D3DFVF_TEXCOUNT_MASK )

  00084	f6 c7 0f	 test	 bh, 15			; 0000000fH
  00087	74 3d		 je	 SHORT $L55557

; 164  :     {
; 165  :         m_oTex[0] = oCur;
; 166  : 
; 167  :         // only one tu/tv set currently supported
; 168  : 
; 169  :         m_cTexCoords = ((dwFVF & D3DFVF_TEXCOUNT_MASK)>>D3DFVF_TEXCOUNT_SHIFT);

  00089	8b d3		 mov	 edx, ebx
  0008b	c1 ea 08	 shr	 edx, 8
  0008e	83 e2 0f	 and	 edx, 15			; 0000000fH

; 170  : 
; 171  :         if(m_cTexCoords > 8)

  00091	83 fa 08	 cmp	 edx, 8
  00094	89 0e		 mov	 DWORD PTR [esi], ecx
  00096	89 50 3c	 mov	 DWORD PTR [eax+60], edx
  00099	76 07		 jbe	 SHORT $L55554

; 172  :             m_cTexCoords = 8;

  0009b	c7 40 3c 08 00
	00 00		 mov	 DWORD PTR [eax+60], 8
$L55554:

; 173  : 
; 174  :         // all 2d, then go quick route
; 175  :         //if ((dwFVF & 0xffff0000) == 0)
; 176  :         //{
; 177  :             //oCur += sizeof(float) * 2 * m_cTexCoords;
; 178  :         //}
; 179  :         //else
; 180  :         {
; 181  :             dwTexCoordSize = (dwFVF & 0xffff0000) >> 16;

  000a2	c1 eb 10	 shr	 ebx, 16			; 00000010H

; 182  :             for (iTexCoord = 0; iTexCoord < m_cTexCoords; iTexCoord++)

  000a5	33 d2		 xor	 edx, edx
  000a7	39 78 3c	 cmp	 DWORD PTR [eax+60], edi
  000aa	76 1a		 jbe	 SHORT $L55557
$L55555:

; 183  :             {
; 184  :                 m_oTex[iTexCoord] = oCur;
; 185  :                 oCur += x_rgdwTexCoordSize[dwTexCoordSize & 0x3];

  000ac	8b fb		 mov	 edi, ebx
  000ae	83 e7 03	 and	 edi, 3
  000b1	89 0e		 mov	 DWORD PTR [esi], ecx
  000b3	03 0c bd 00 00
	00 00		 add	 ecx, DWORD PTR _x_rgdwTexCoordSize[edi*4]

; 186  :                 dwTexCoordSize = dwTexCoordSize >> 2;

  000ba	c1 eb 02	 shr	 ebx, 2
  000bd	42		 inc	 edx
  000be	83 c6 04	 add	 esi, 4
  000c1	3b 50 3c	 cmp	 edx, DWORD PTR [eax+60]
  000c4	72 e6		 jb	 SHORT $L55555
$L55557:
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi

; 187  :             }
; 188  :         }
; 189  :     }
; 190  : 
; 191  :     m_cBytesPerVertex = oCur;

  000c8	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000cb	5b		 pop	 ebx

; 192  : }

  000cc	5d		 pop	 ebp
  000cd	c2 04 00	 ret	 4
??0DXCrackFVF@@QAE@K@Z ENDP				; DXCrackFVF::DXCrackFVF
_TEXT	ENDS
PUBLIC	?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetPosition
; Function compile flags: /Ogs
;	COMDAT ?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_pvPos$ = 12						; size = 4
?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z PROC NEAR ; DXCrackFVF::SetPosition, COMDAT
; _this$ = ecx

; 211  : }

  00000	8b ff		 npad	 2

; 209  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 210  :     memcpy(pvPoint, pvPos, sizeof(D3DXVECTOR3));

  00006	8b 75 0c	 mov	 esi, DWORD PTR _pvPos$[ebp]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _pvPoint$[ebp]
  0000d	a5		 movsd
  0000e	a5		 movsd
  0000f	a5		 movsd
  00010	5f		 pop	 edi
  00011	5e		 pop	 esi

; 211  : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ENDP	; DXCrackFVF::SetPosition
_TEXT	ENDS
PUBLIC	?SetNormal@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetNormal
; Function compile flags: /Ogs
;	COMDAT ?SetNormal@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_pvNormal$ = 12						; size = 4
?SetNormal@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z PROC NEAR ; DXCrackFVF::SetNormal, COMDAT
; _this$ = ecx

; 223  :     }
; 224  : }

  00000	8b ff		 npad	 2

; 219  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 220  :     if (m_oNormal)

  00005	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00008	85 c0		 test	 eax, eax
  0000a	74 10		 je	 SHORT $L55575

; 221  :     {
; 222  :         memcpy(((PBYTE)pvPoint) + m_oNormal, pvNormal, sizeof(D3DXVECTOR3));

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pvPoint$[ebp]
  0000f	56		 push	 esi
  00010	8b 75 0c	 mov	 esi, DWORD PTR _pvNormal$[ebp]
  00013	57		 push	 edi
  00014	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  00017	a5		 movsd
  00018	a5		 movsd
  00019	a5		 movsd
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
$L55575:

; 223  :     }
; 224  : }

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?SetNormal@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ENDP	; DXCrackFVF::SetNormal
_TEXT	ENDS
PUBLIC	?SetDiffuse@DXCrackFVF@@QAEXPAXK@Z		; DXCrackFVF::SetDiffuse
; Function compile flags: /Ogs
;	COMDAT ?SetDiffuse@DXCrackFVF@@QAEXPAXK@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_color$ = 12						; size = 4
?SetDiffuse@DXCrackFVF@@QAEXPAXK@Z PROC NEAR		; DXCrackFVF::SetDiffuse, COMDAT
; _this$ = ecx

; 249  :     }
; 250  : }

  00000	8b ff		 npad	 2

; 245  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 246  :     if (m_oDiffuse)

  00005	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00008	85 c0		 test	 eax, eax
  0000a	74 09		 je	 SHORT $L55591

; 247  :     {
; 248  :         memcpy(((PBYTE)pvPoint) + m_oDiffuse, &color, sizeof(D3DCOLOR));

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _color$[ebp]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _pvPoint$[ebp]
  00012	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx
$L55591:

; 249  :     }
; 250  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?SetDiffuse@DXCrackFVF@@QAEXPAXK@Z ENDP			; DXCrackFVF::SetDiffuse
_TEXT	ENDS
PUBLIC	?SetSpecular@DXCrackFVF@@QAEXPAXK@Z		; DXCrackFVF::SetSpecular
; Function compile flags: /Ogs
;	COMDAT ?SetSpecular@DXCrackFVF@@QAEXPAXK@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_color$ = 12						; size = 4
?SetSpecular@DXCrackFVF@@QAEXPAXK@Z PROC NEAR		; DXCrackFVF::SetSpecular, COMDAT
; _this$ = ecx

; 262  :     }
; 263  : }

  00000	8b ff		 npad	 2

; 258  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 259  :     if (m_oSpecular)

  00005	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00008	85 c0		 test	 eax, eax
  0000a	74 09		 je	 SHORT $L55599

; 260  :     {
; 261  :         memcpy(((PBYTE)pvPoint) + m_oSpecular, &color, sizeof(D3DCOLOR));

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _color$[ebp]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _pvPoint$[ebp]
  00012	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx
$L55599:

; 262  :     }
; 263  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?SetSpecular@DXCrackFVF@@QAEXPAXK@Z ENDP		; DXCrackFVF::SetSpecular
_TEXT	ENDS
PUBLIC	?SetTex1@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR2@@@Z	; DXCrackFVF::SetTex1
; Function compile flags: /Ogs
;	COMDAT ?SetTex1@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR2@@@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_puvTex1$ = 12						; size = 4
?SetTex1@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR2@@@Z PROC NEAR ; DXCrackFVF::SetTex1, COMDAT
; _this$ = ecx

; 275  :     }
; 276  : }

  00000	8b ff		 npad	 2

; 271  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 272  :     if (m_oTex[0])

  00005	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00008	85 c0		 test	 eax, eax
  0000a	74 14		 je	 SHORT $L55607

; 273  :     {
; 274  :         memcpy(((PBYTE)pvPoint) + m_oTex[0], puvTex1, sizeof(D3DXVECTOR2));

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _puvTex1$[ebp]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _pvPoint$[ebp]
  00012	56		 push	 esi
  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
  00015	89 34 10	 mov	 DWORD PTR [eax+edx], esi
  00018	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001b	89 4c 10 04	 mov	 DWORD PTR [eax+edx+4], ecx
  0001f	5e		 pop	 esi
$L55607:

; 275  :     }
; 276  : }

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?SetTex1@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR2@@@Z ENDP	; DXCrackFVF::SetTex1
_TEXT	ENDS
PUBLIC	?SetWeight@DXCrackFVF@@QAEXPAXIM@Z		; DXCrackFVF::SetWeight
; Function compile flags: /Ogs
;	COMDAT ?SetWeight@DXCrackFVF@@QAEXPAXIM@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_iWeight$ = 12						; size = 4
_fWeight$ = 16						; size = 4
?SetWeight@DXCrackFVF@@QAEXPAXIM@Z PROC NEAR		; DXCrackFVF::SetWeight, COMDAT
; _this$ = ecx

; 331  :     }
; 332  : }

  00000	8b ff		 npad	 2

; 327  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 328  :     if (iWeight < m_cWeights)

  00005	8b 45 0c	 mov	 eax, DWORD PTR _iWeight$[ebp]
  00008	3b 41 38	 cmp	 eax, DWORD PTR [ecx+56]
  0000b	73 0a		 jae	 SHORT $L55652

; 329  :     {
; 330  :         memcpy(((PBYTE)pvPoint) + sizeof(D3DXVECTOR3) + sizeof(float) * iWeight, &fWeight, sizeof(float));

  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _fWeight$[ebp]
  00010	8b 55 08	 mov	 edx, DWORD PTR _pvPoint$[ebp]
  00013	89 4c 82 0c	 mov	 DWORD PTR [edx+eax*4+12], ecx
$L55652:

; 331  :     }
; 332  : }

  00017	5d		 pop	 ebp
  00018	c2 0c 00	 ret	 12			; 0000000cH
?SetWeight@DXCrackFVF@@QAEXPAXIM@Z ENDP			; DXCrackFVF::SetWeight
_TEXT	ENDS
PUBLIC	?PuvGetTex1@DXCrackFVF@@QAEPAUD3DXVECTOR2@@PAX@Z ; DXCrackFVF::PuvGetTex1
; Function compile flags: /Ogs
;	COMDAT ?PuvGetTex1@DXCrackFVF@@QAEPAUD3DXVECTOR2@@PAX@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
?PuvGetTex1@DXCrackFVF@@QAEPAUD3DXVECTOR2@@PAX@Z PROC NEAR ; DXCrackFVF::PuvGetTex1, COMDAT
; _this$ = ecx

; 415  : }

  00000	8b ff		 npad	 2

; 413  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 414  :     return (D3DXVECTOR2*)  (((PBYTE)pvPoint) + m_oTex[0]);

  00005	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00008	03 45 08	 add	 eax, DWORD PTR _pvPoint$[ebp]

; 415  : }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?PuvGetTex1@DXCrackFVF@@QAEPAUD3DXVECTOR2@@PAX@Z ENDP	; DXCrackFVF::PuvGetTex1
_TEXT	ENDS
PUBLIC	?CbTexCoordSize@DXCrackFVF@@QAEKK@Z		; DXCrackFVF::CbTexCoordSize
; Function compile flags: /Ogs
;	COMDAT ?CbTexCoordSize@DXCrackFVF@@QAEKK@Z
_TEXT	SEGMENT
_iTexCoord$ = 8						; size = 4
?CbTexCoordSize@DXCrackFVF@@QAEKK@Z PROC NEAR		; DXCrackFVF::CbTexCoordSize, COMDAT
; _this$ = ecx

; 467  : }

  00000	8b ff		 npad	 2

; 462  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx

; 463  :     if (iTexCoord < m_cTexCoords)

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _iTexCoord$[ebp]
  0000a	3b 48 3c	 cmp	 ecx, DWORD PTR [eax+60]
  0000d	73 14		 jae	 SHORT $L55750

; 464  :         return x_rgdwTexCoordSize[(m_dwFVF >> (16 + iTexCoord * 2)) & 0x3];

  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	8d 4c 09 10	 lea	 ecx, DWORD PTR [ecx+ecx+16]
  00015	d3 e8		 shr	 eax, cl
  00017	83 e0 03	 and	 eax, 3
  0001a	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _x_rgdwTexCoordSize[eax*4]
  00021	eb 02		 jmp	 SHORT $L55751
$L55750:

; 465  :     else
; 466  :         return 0;

  00023	33 c0		 xor	 eax, eax
$L55751:

; 467  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?CbTexCoordSize@DXCrackFVF@@QAEKK@Z ENDP		; DXCrackFVF::CbTexCoordSize
_TEXT	ENDS
PUBLIC	?GetTexCoordSizes@DXCrackFVF@@QAEXPAK@Z		; DXCrackFVF::GetTexCoordSizes
; Function compile flags: /Ogs
;	COMDAT ?GetTexCoordSizes@DXCrackFVF@@QAEXPAK@Z
_TEXT	SEGMENT
_rgdwTexCoordSizes$ = 8					; size = 4
?GetTexCoordSizes@DXCrackFVF@@QAEXPAK@Z PROC NEAR	; DXCrackFVF::GetTexCoordSizes, COMDAT
; _this$ = ecx

; 489  :     }
; 490  : }

  00000	8b ff		 npad	 2

; 474  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 475  :     DWORD iTexCoord;
; 476  : 
; 477  :     for (iTexCoord = 0; iTexCoord < m_cTexCoords; iTexCoord++)

  00006	8b 75 08	 mov	 esi, DWORD PTR _rgdwTexCoordSizes$[ebp]
  00009	8b d1		 mov	 edx, ecx
  0000b	33 c0		 xor	 eax, eax
  0000d	39 42 3c	 cmp	 DWORD PTR [edx+60], eax
  00010	57		 push	 edi
  00011	76 21		 jbe	 SHORT $L57148
  00013	6a 10		 push	 16			; 00000010H
  00015	59		 pop	 ecx
$L55757:

; 478  :     {
; 479  :        
; 480  :         rgdwTexCoordSizes[iTexCoord] = x_rgdwTexCoordSize[(m_dwFVF >> (16 + iTexCoord * 2)) & 0x3];

  00016	8b 3a		 mov	 edi, DWORD PTR [edx]
  00018	d3 ef		 shr	 edi, cl
  0001a	83 e7 03	 and	 edi, 3
  0001d	8b 3c bd 00 00
	00 00		 mov	 edi, DWORD PTR _x_rgdwTexCoordSize[edi*4]
  00024	89 3c 86	 mov	 DWORD PTR [esi+eax*4], edi
  00027	40		 inc	 eax
  00028	41		 inc	 ecx
  00029	41		 inc	 ecx
  0002a	3b 42 3c	 cmp	 eax, DWORD PTR [edx+60]
  0002d	72 e7		 jb	 SHORT $L55757

; 481  : 
; 482  :  
; 483  :     }
; 484  : 
; 485  :     // set the rest to 0
; 486  :     for (;iTexCoord < 8; iTexCoord++)

  0002f	83 f8 08	 cmp	 eax, 8
  00032	73 0c		 jae	 SHORT $L57147
$L57148:

; 487  :     {
; 488  :         rgdwTexCoordSizes[iTexCoord] = 0;

  00034	6a 08		 push	 8
  00036	59		 pop	 ecx
  00037	8d 3c 86	 lea	 edi, DWORD PTR [esi+eax*4]
  0003a	2b c8		 sub	 ecx, eax
  0003c	33 c0		 xor	 eax, eax
  0003e	f3 ab		 rep stosd
$L57147:
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 489  :     }
; 490  : }

  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?GetTexCoordSizes@DXCrackFVF@@QAEXPAK@Z ENDP		; DXCrackFVF::GetTexCoordSizes
_TEXT	ENDS
PUBLIC	??0SLoadedFace@GXU@@QAE@XZ			; GXU::SLoadedFace::SLoadedFace
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\loadutil.h
;	COMDAT ??0SLoadedFace@GXU@@QAE@XZ
_TEXT	SEGMENT
??0SLoadedFace@GXU@@QAE@XZ PROC NEAR			; GXU::SLoadedFace::SLoadedFace, COMDAT
; _this$ = ecx

; 43   :     SLoadedFace()        

  00000	8b c1		 mov	 eax, ecx
  00002	80 60 0c f0	 and	 BYTE PTR [eax+12], -16	; fffffff0H
  00006	83 08 ff	 or	 DWORD PTR [eax], -1
  00009	83 48 04 ff	 or	 DWORD PTR [eax+4], -1
  0000d	83 48 08 ff	 or	 DWORD PTR [eax+8], -1
  00011	c3		 ret	 0
??0SLoadedFace@GXU@@QAE@XZ ENDP				; GXU::SLoadedFace::SLoadedFace
_TEXT	ENDS
PUBLIC	??0SLoadVertex@GXU@@QAE@XZ			; GXU::SLoadVertex::SLoadVertex
; Function compile flags: /Ogs
;	COMDAT ??0SLoadVertex@GXU@@QAE@XZ
_TEXT	SEGMENT
??0SLoadVertex@GXU@@QAE@XZ PROC NEAR			; GXU::SLoadVertex::SLoadVertex, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0SLoadVertex@GXU@@QAE@XZ ENDP				; GXU::SLoadVertex::SLoadVertex
_TEXT	ENDS
PUBLIC	?InitVertices@GXU@@YAJAAPAUSLoadVertex@1@K@Z	; GXU::InitVertices
EXTRN	__EH_prolog:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.inl
xdata$x	SEGMENT
$T57208	DD	0ffffffffH
	DD	FLAT:$L57186
$T57202	DD	019930520H
	DD	01H
	DD	FLAT:$T57208
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\loadutil.cpp
xdata$x	ENDS
;	COMDAT ?InitVertices@GXU@@YAJAAPAUSLoadVertex@1@K@Z
_TEXT	SEGMENT
$T57184 = -64						; size = 16
$T57183 = -48						; size = 12
$T57182 = -36						; size = 12
$T57185 = -24						; size = 8
$T57179 = -20						; size = 4
_hr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_rglvVertices$ = 8					; size = 4
_cVertices$ = 12					; size = 4
?InitVertices@GXU@@YAJAAPAUSLoadVertex@1@K@Z PROC NEAR	; GXU::InitVertices, COMDAT

; 379  : {

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?InitVertices@GXU@@YAJAAPAUSLoadVertex@1@K@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 34	 sub	 esp, 52			; 00000034H

; 380  :     HRESULT hr = S_OK;
; 381  :     DWORD iVertex;
; 382  : 
; 383  :     rglvVertices = new SLoadVertex[cVertices];

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _cVertices$[ebp]
  00010	6b c0 44	 imul	 eax, 68			; 00000044H
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	33 db		 xor	 ebx, ebx
  00017	50		 push	 eax
  00018	89 5d f0	 mov	 DWORD PTR _hr$[ebp], ebx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	8b f0		 mov	 esi, eax
  00022	59		 pop	 ecx
  00023	89 75 ec	 mov	 DWORD PTR $T57179[ebp], esi
  00026	3b f3		 cmp	 esi, ebx
  00028	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0002b	74 14		 je	 SHORT $L57180
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??0SLoadVertex@GXU@@QAE@XZ
  00032	ff 75 0c	 push	 DWORD PTR _cVertices$[ebp]
  00035	6a 44		 push	 68			; 00000044H
  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EPAX0@Z@Z
  0003d	8b c6		 mov	 eax, esi
  0003f	eb 02		 jmp	 SHORT $L57181
$L57180:
  00041	33 c0		 xor	 eax, eax
$L57181:

; 384  :     if (rglvVertices == NULL)

  00043	3b c3		 cmp	 eax, ebx
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _rglvVertices$[ebp]
  00048	89 01		 mov	 DWORD PTR [ecx], eax
  0004a	75 0c		 jne	 SHORT $L56529

; 385  :     {
; 386  :         hr = E_OUTOFMEMORY;

  0004c	c7 45 f0 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 387  :         goto e_Exit;

  00053	e9 ad 00 00 00	 jmp	 $e_Exit$56531
$L56529:

; 388  :     }
; 389  : 
; 390  :     for (iVertex = 0; iVertex < cVertices; iVertex++)

  00058	33 d2		 xor	 edx, edx
  0005a	39 5d 0c	 cmp	 DWORD PTR _cVertices$[ebp], ebx
  0005d	0f 86 a2 00 00
	00		 jbe	 $e_Exit$56531

; 391  :     {
; 392  :         rglvVertices[iVertex].m_vPos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  00063	d9 ee		 fldz
  00065	33 c0		 xor	 eax, eax
  00067	d9 5d dc	 fstp	 DWORD PTR $T57182[ebp]
  0006a	57		 push	 edi
  0006b	d9 ee		 fldz
  0006d	d9 5d e0	 fstp	 DWORD PTR $T57182[ebp+4]
  00070	d9 ee		 fldz
  00072	d9 5d e4	 fstp	 DWORD PTR $T57182[ebp+8]

; 393  :         rglvVertices[iVertex].m_vNormal = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  00075	d9 ee		 fldz
  00077	d9 5d d0	 fstp	 DWORD PTR $T57183[ebp]
  0007a	d9 ee		 fldz
  0007c	d9 5d d4	 fstp	 DWORD PTR $T57183[ebp+4]
  0007f	d9 ee		 fldz
  00081	d9 5d d8	 fstp	 DWORD PTR $T57183[ebp+8]

; 394  : //        rglvVertices[iVertex].m_color = D3DXCOLOR(0.9f, 0.6f, 0.4f, 0.0f);
; 395  :         rglvVertices[iVertex].m_color = D3DXCOLOR(1.0f, 1.0f, 1.0f, 0.0f);

  00084	d9 e8		 fld1
  00086	d9 5d c0	 fstp	 DWORD PTR $T57184[ebp]
  00089	d9 e8		 fld1
  0008b	d9 5d c4	 fstp	 DWORD PTR $T57184[ebp+4]
  0008e	d9 e8		 fld1
  00090	d9 5d c8	 fstp	 DWORD PTR $T57184[ebp+8]
  00093	d9 ee		 fldz
  00095	d9 5d cc	 fstp	 DWORD PTR $T57184[ebp+12]

; 396  :         rglvVertices[iVertex].m_uvTex1 = D3DXVECTOR2(0.0f, 0.0f);

  00098	d9 ee		 fldz
  0009a	d9 5d e8	 fstp	 DWORD PTR $T57185[ebp]
  0009d	d9 ee		 fldz
  0009f	d9 5d ec	 fstp	 DWORD PTR $T57185[ebp+4]
$L56533:
  000a2	8b 39		 mov	 edi, DWORD PTR [ecx]
  000a4	03 f8		 add	 edi, eax
  000a6	8d 75 dc	 lea	 esi, DWORD PTR $T57182[ebp]
  000a9	a5		 movsd
  000aa	a5		 movsd
  000ab	a5		 movsd
  000ac	8b 31		 mov	 esi, DWORD PTR [ecx]
  000ae	8d 7c 30 24	 lea	 edi, DWORD PTR [eax+esi+36]
  000b2	8d 75 d0	 lea	 esi, DWORD PTR $T57183[ebp]
  000b5	a5		 movsd
  000b6	a5		 movsd
  000b7	a5		 movsd
  000b8	8b 31		 mov	 esi, DWORD PTR [ecx]
  000ba	8d 7c 30 0c	 lea	 edi, DWORD PTR [eax+esi+12]
  000be	8d 75 c0	 lea	 esi, DWORD PTR $T57184[ebp]
  000c1	a5		 movsd
  000c2	a5		 movsd
  000c3	a5		 movsd
  000c4	a5		 movsd
  000c5	8b 31		 mov	 esi, DWORD PTR [ecx]
  000c7	8b 7d e8	 mov	 edi, DWORD PTR $T57185[ebp]
  000ca	89 7c 30 1c	 mov	 DWORD PTR [eax+esi+28], edi
  000ce	8b 7d ec	 mov	 edi, DWORD PTR $T57185[ebp+4]
  000d1	89 7c 30 20	 mov	 DWORD PTR [eax+esi+32], edi

; 397  :         rglvVertices[iVertex].m_wPointRep = iVertex;

  000d5	8b 31		 mov	 esi, DWORD PTR [ecx]
  000d7	89 54 30 30	 mov	 DWORD PTR [eax+esi+48], edx

; 398  :         rglvVertices[iVertex].m_wPointList = iVertex;

  000db	8b 31		 mov	 esi, DWORD PTR [ecx]
  000dd	89 54 30 34	 mov	 DWORD PTR [eax+esi+52], edx

; 399  :         rglvVertices[iVertex].m_bOwned = false;

  000e1	8b 31		 mov	 esi, DWORD PTR [ecx]
  000e3	88 5c 30 38	 mov	 BYTE PTR [eax+esi+56], bl

; 400  :         rglvVertices[iVertex].m_iFVFDataOffset = iVertex;

  000e7	8b 31		 mov	 esi, DWORD PTR [ecx]
  000e9	89 54 30 40	 mov	 DWORD PTR [eax+esi+64], edx

; 401  : 
; 402  :         rglvVertices[iVertex].m_iSmoothingGroup = 0;

  000ed	8b 31		 mov	 esi, DWORD PTR [ecx]
  000ef	66 89 5c 30 3a	 mov	 WORD PTR [eax+esi+58], bx

; 403  :         rglvVertices[iVertex].m_cSmoothingGroupFaces = 0;

  000f4	8b 31		 mov	 esi, DWORD PTR [ecx]
  000f6	66 89 5c 30 3c	 mov	 WORD PTR [eax+esi+60], bx
  000fb	42		 inc	 edx
  000fc	83 c0 44	 add	 eax, 68			; 00000044H
  000ff	3b 55 0c	 cmp	 edx, DWORD PTR _cVertices$[ebp]
  00102	72 9e		 jb	 SHORT $L56533
  00104	5f		 pop	 edi
$e_Exit$56531:

; 404  :     }
; 405  : 
; 406  : e_Exit:
; 407  :     return hr;
; 408  : }

  00105	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00108	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00114	c9		 leave
  00115	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L57186:
  00000	ff 75 ec	 push	 DWORD PTR $T57179[ebp]
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
__ehhandler$?InitVertices@GXU@@YAJAAPAUSLoadVertex@1@K@Z:
  0000a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T57202
  0000f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?InitVertices@GXU@@YAJAAPAUSLoadVertex@1@K@Z ENDP	; GXU::InitVertices
PUBLIC	??0SCorner@GXU@@QAE@XZ				; GXU::SCorner::SCorner
; Function compile flags: /Ogs
;	COMDAT ??0SCorner@GXU@@QAE@XZ
_TEXT	SEGMENT
??0SCorner@GXU@@QAE@XZ PROC NEAR			; GXU::SCorner::SCorner, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0SCorner@GXU@@QAE@XZ ENDP				; GXU::SCorner::SCorner
_TEXT	ENDS
PUBLIC	?InitFaces@GXU@@YAJAAPAUSLoadedFace@1@K@Z	; GXU::InitFaces
;	COMDAT xdata$x
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\loadutil.h
xdata$x	SEGMENT
$T57241	DD	0ffffffffH
	DD	FLAT:$L57226
$T57237	DD	019930520H
	DD	01H
	DD	FLAT:$T57241
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\loadutil.cpp
xdata$x	ENDS
;	COMDAT ?InitFaces@GXU@@YAJAAPAUSLoadedFace@1@K@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_rglfFaces$ = 8						; size = 4
$T57223 = 12						; size = 4
_cFaces$ = 12						; size = 4
?InitFaces@GXU@@YAJAAPAUSLoadedFace@1@K@Z PROC NEAR	; GXU::InitFaces, COMDAT

; 441  : {

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?InitFaces@GXU@@YAJAAPAUSLoadedFace@1@K@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi

; 442  :     HRESULT hr = S_OK;
; 443  :     DWORD iFace;
; 444  : 
; 445  :     rglfFaces = new SLoadedFace[cFaces];

  0000d	8b 7d 0c	 mov	 edi, DWORD PTR _cFaces$[ebp]
  00010	8b c7		 mov	 eax, edi
  00012	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00015	50		 push	 eax
  00016	33 db		 xor	 ebx, ebx
  00018	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001d	8b f0		 mov	 esi, eax
  0001f	59		 pop	 ecx
  00020	89 75 0c	 mov	 DWORD PTR $T57223[ebp], esi
  00023	3b f3		 cmp	 esi, ebx
  00025	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00028	74 12		 je	 SHORT $L57224
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:??0SLoadedFace@GXU@@QAE@XZ ; GXU::SLoadedFace::SLoadedFace
  0002f	57		 push	 edi
  00030	6a 2c		 push	 44			; 0000002cH
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EPAX0@Z@Z
  00038	8b c6		 mov	 eax, esi
  0003a	eb 02		 jmp	 SHORT $L57225
$L57224:
  0003c	33 c0		 xor	 eax, eax
$L57225:

; 446  :     if (rglfFaces == NULL)

  0003e	85 c0		 test	 eax, eax
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _rglfFaces$[ebp]
  00043	89 01		 mov	 DWORD PTR [ecx], eax
  00045	75 07		 jne	 SHORT $L56577

; 447  :     {
; 448  :         hr = E_OUTOFMEMORY;

  00047	bb 0e 00 07 80	 mov	 ebx, -2147024882	; 8007000eH

; 449  :         goto e_Exit;

  0004c	eb 1f		 jmp	 SHORT $e_Exit$56579
$L56577:

; 450  :     }
; 451  : 
; 452  :     for (iFace = 0; iFace < cFaces; iFace++)

  0004e	85 ff		 test	 edi, edi
  00050	76 1b		 jbe	 SHORT $e_Exit$56579
  00052	33 d2		 xor	 edx, edx
$L56581:

; 453  :     {
; 454  :         rglfFaces[iFace].InitEmpty();

  00054	8b 01		 mov	 eax, DWORD PTR [ecx]
  00056	03 c2		 add	 eax, edx
  00058	80 60 0c f0	 and	 BYTE PTR [eax+12], -16	; fffffff0H
  0005c	83 08 ff	 or	 DWORD PTR [eax], -1
  0005f	83 48 04 ff	 or	 DWORD PTR [eax+4], -1
  00063	83 48 08 ff	 or	 DWORD PTR [eax+8], -1
  00067	83 c2 2c	 add	 edx, 44			; 0000002cH
  0006a	4f		 dec	 edi
  0006b	75 e7		 jne	 SHORT $L56581
$e_Exit$56579:

; 455  :     }
; 456  : 
; 457  : e_Exit:
; 458  :     return hr;
; 459  : }

  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	8b c3		 mov	 eax, ebx
  00074	5b		 pop	 ebx
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007c	c9		 leave
  0007d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L57226:
  00000	ff 75 0c	 push	 DWORD PTR $T57223[ebp]
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
__ehhandler$?InitFaces@GXU@@YAJAAPAUSLoadedFace@1@K@Z:
  0000a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T57237
  0000f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?InitFaces@GXU@@YAJAAPAUSLoadedFace@1@K@Z ENDP		; GXU::InitFaces
PUBLIC	?BEqualWedges@GXU@@YA_NAAUSLoadVertex@1@0@Z	; GXU::BEqualWedges
; Function compile flags: /Ogs
;	COMDAT ?BEqualWedges@GXU@@YA_NAAUSLoadVertex@1@0@Z
_TEXT	SEGMENT
_lv1$ = 8						; size = 4
_lv2$ = 12						; size = 4
?BEqualWedges@GXU@@YA_NAAUSLoadVertex@1@0@Z PROC NEAR	; GXU::BEqualWedges, COMDAT

; 468  : }

  00000	8b ff		 npad	 2

; 463  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 464  : 
; 465  :     return (lv1.m_color == lv2.m_color) 
; 466  :         && (lv1.m_uvTex1 == lv2.m_uvTex1)
; 467  :         && (lv1.m_vNormal == lv2.m_vNormal);

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR _lv2$[ebp]
  00008	8b 55 08	 mov	 edx, DWORD PTR _lv1$[ebp]
  0000b	d9 41 0c	 fld	 DWORD PTR [ecx+12]
  0000e	d9 42 0c	 fld	 DWORD PTR [edx+12]
  00011	da e9		 fucompp
  00013	df e0		 fnstsw	 ax
  00015	f6 c4 44	 test	 ah, 68			; 00000044H
  00018	7a 7d		 jp	 SHORT $L57245
  0001a	d9 41 10	 fld	 DWORD PTR [ecx+16]
  0001d	d9 42 10	 fld	 DWORD PTR [edx+16]
  00020	da e9		 fucompp
  00022	df e0		 fnstsw	 ax
  00024	f6 c4 44	 test	 ah, 68			; 00000044H
  00027	7a 6e		 jp	 SHORT $L57245
  00029	d9 41 14	 fld	 DWORD PTR [ecx+20]
  0002c	d9 42 14	 fld	 DWORD PTR [edx+20]
  0002f	da e9		 fucompp
  00031	df e0		 fnstsw	 ax
  00033	f6 c4 44	 test	 ah, 68			; 00000044H
  00036	7a 5f		 jp	 SHORT $L57245
  00038	d9 41 18	 fld	 DWORD PTR [ecx+24]
  0003b	d9 42 18	 fld	 DWORD PTR [edx+24]
  0003e	da e9		 fucompp
  00040	df e0		 fnstsw	 ax
  00042	f6 c4 44	 test	 ah, 68			; 00000044H
  00045	7a 50		 jp	 SHORT $L57245
  00047	d9 41 1c	 fld	 DWORD PTR [ecx+28]
  0004a	d9 42 1c	 fld	 DWORD PTR [edx+28]
  0004d	da e9		 fucompp
  0004f	df e0		 fnstsw	 ax
  00051	f6 c4 44	 test	 ah, 68			; 00000044H
  00054	7a 41		 jp	 SHORT $L57245
  00056	d9 41 20	 fld	 DWORD PTR [ecx+32]
  00059	d9 42 20	 fld	 DWORD PTR [edx+32]
  0005c	da e9		 fucompp
  0005e	df e0		 fnstsw	 ax
  00060	f6 c4 44	 test	 ah, 68			; 00000044H
  00063	7a 32		 jp	 SHORT $L57245
  00065	d9 41 24	 fld	 DWORD PTR [ecx+36]
  00068	d9 42 24	 fld	 DWORD PTR [edx+36]
  0006b	da e9		 fucompp
  0006d	df e0		 fnstsw	 ax
  0006f	f6 c4 44	 test	 ah, 68			; 00000044H
  00072	7a 23		 jp	 SHORT $L57245
  00074	d9 41 28	 fld	 DWORD PTR [ecx+40]
  00077	d9 42 28	 fld	 DWORD PTR [edx+40]
  0007a	da e9		 fucompp
  0007c	df e0		 fnstsw	 ax
  0007e	f6 c4 44	 test	 ah, 68			; 00000044H
  00081	7a 14		 jp	 SHORT $L57245
  00083	d9 41 2c	 fld	 DWORD PTR [ecx+44]
  00086	d9 42 2c	 fld	 DWORD PTR [edx+44]
  00089	da e9		 fucompp
  0008b	df e0		 fnstsw	 ax
  0008d	f6 c4 44	 test	 ah, 68			; 00000044H
  00090	7a 05		 jp	 SHORT $L57245
  00092	33 c0		 xor	 eax, eax
  00094	40		 inc	 eax

; 468  : }

  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
$L57245:

; 464  : 
; 465  :     return (lv1.m_color == lv2.m_color) 
; 466  :         && (lv1.m_uvTex1 == lv2.m_uvTex1)
; 467  :         && (lv1.m_vNormal == lv2.m_vNormal);

  00097	33 c0		 xor	 eax, eax

; 468  : }

  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?BEqualWedges@GXU@@YA_NAAUSLoadVertex@1@0@Z ENDP	; GXU::BEqualWedges
_TEXT	ENDS
PUBLIC	??$AddToDynamicArray@USLoadVertex@GXU@@@@YAHPAPAUSLoadVertex@GXU@@ABU01@PAK2@Z ; AddToDynamicArray<GXU::SLoadVertex>
EXTRN	__imp__HeapValidate@12:NEAR
EXTRN	__imp__GetProcessHeap@0:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T57296	DD	0ffffffffH
	DD	FLAT:$L57288
	DD	0ffffffffH
	DD	FLAT:$L57289
$T57291	DD	019930520H
	DD	02H
	DD	FLAT:$T57296
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogs
xdata$x	ENDS
;	COMDAT ??$AddToDynamicArray@USLoadVertex@GXU@@@@YAHPAPAUSLoadVertex@GXU@@ABU01@PAK2@Z
_TEXT	SEGMENT
_cNewMax$56953 = -24					; size = 4
$T57283 = -20						; size = 4
_pBase$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ppBase$ = 8						; size = 4
_obj$ = 12						; size = 4
_i$56962 = 16						; size = 4
$T57284 = 16						; size = 4
$T57279 = 16						; size = 4
_pcNum$ = 16						; size = 4
_pcMax$ = 20						; size = 4
??$AddToDynamicArray@USLoadVertex@GXU@@@@YAHPAPAUSLoadVertex@GXU@@ABU01@PAK2@Z PROC NEAR ; AddToDynamicArray<GXU::SLoadVertex>, COMDAT

; 45   : {

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$??$AddToDynamicArray@USLoadVertex@GXU@@@@YAHPAPAUSLoadVertex@GXU@@ABU01@PAK2@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 46   :     T *pBase = *ppBase;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _ppBase$[ebp]
  00010	8b 00		 mov	 eax, DWORD PTR [eax]
  00012	53		 push	 ebx

; 47   :     if ( ! pBase )

  00013	8b 5d 10	 mov	 ebx, DWORD PTR _pcNum$[ebp]
  00016	56		 push	 esi
  00017	33 f6		 xor	 esi, esi
  00019	3b c6		 cmp	 eax, esi
  0001b	57		 push	 edi
  0001c	89 45 f0	 mov	 DWORD PTR _pBase$[ebp], eax
  0001f	75 4a		 jne	 SHORT $L57294

; 48   :     {
; 49   :         HeapValidate( GetProcessHeap(), 0, NULL );

  00021	56		 push	 esi
  00022	56		 push	 esi
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00029	50		 push	 eax
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapValidate@12

; 50   :         pBase = new T[2];

  00030	68 88 00 00 00	 push	 136			; 00000088H
  00035	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003a	8b f8		 mov	 edi, eax
  0003c	59		 pop	 ecx
  0003d	89 7d 10	 mov	 DWORD PTR $T57279[ebp], edi
  00040	85 ff		 test	 edi, edi
  00042	6a 02		 push	 2
  00044	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  00047	5e		 pop	 esi
  00048	74 10		 je	 SHORT $L57280
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:??0SLoadVertex@GXU@@QAE@XZ
  0004f	56		 push	 esi
  00050	6a 44		 push	 68			; 00000044H
  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EPAX0@Z@Z
  00058	eb 02		 jmp	 SHORT $L57281
$L57280:
  0005a	33 ff		 xor	 edi, edi
$L57281:
  0005c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 51   :         *pcNum = 0;
; 52   :         *pcMax = 2;

  00060	8b 45 14	 mov	 eax, DWORD PTR _pcMax$[ebp]
  00063	83 23 00	 and	 DWORD PTR [ebx], 0
  00066	89 7d f0	 mov	 DWORD PTR _pBase$[ebp], edi
  00069	89 30		 mov	 DWORD PTR [eax], esi
$L57294:

; 53   :     }
; 54   :     if ( *pcNum == *pcMax )

  0006b	8b 45 14	 mov	 eax, DWORD PTR _pcMax$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	39 03		 cmp	 DWORD PTR [ebx], eax
  00072	0f 85 80 00 00
	00		 jne	 $L56952

; 55   :     {
; 56   :         DWORD cNewMax = *pcMax*2;

  00078	8d 34 00	 lea	 esi, DWORD PTR [eax+eax]

; 57   :         T *newarr = new T[cNewMax];

  0007b	8b c6		 mov	 eax, esi
  0007d	6b c0 44	 imul	 eax, 68			; 00000044H
  00080	50		 push	 eax
  00081	89 75 e8	 mov	 DWORD PTR _cNewMax$56953[ebp], esi
  00084	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00089	8b f8		 mov	 edi, eax
  0008b	59		 pop	 ecx
  0008c	89 7d 10	 mov	 DWORD PTR $T57284[ebp], edi
  0008f	85 ff		 test	 edi, edi
  00091	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00098	74 13		 je	 SHORT $L57285
  0009a	68 00 00 00 00	 push	 OFFSET FLAT:??0SLoadVertex@GXU@@QAE@XZ
  0009f	56		 push	 esi
  000a0	6a 44		 push	 68			; 00000044H
  000a2	57		 push	 edi
  000a3	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EPAX0@Z@Z
  000a8	89 7d ec	 mov	 DWORD PTR $T57283[ebp], edi
  000ab	eb 04		 jmp	 SHORT $L57286
$L57285:
  000ad	83 65 ec 00	 and	 DWORD PTR $T57283[ebp], 0
$L57286:

; 58   :         if ( ! newarr )

  000b1	8b 45 ec	 mov	 eax, DWORD PTR $T57283[ebp]
  000b4	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000b8	85 c0		 test	 eax, eax
  000ba	74 59		 je	 SHORT $L56944
$L56961:

; 59   :             return FALSE;
; 60   :         for (DWORD i = 0; i < *pcNum; i++)

  000bc	83 65 10 00	 and	 DWORD PTR _i$56962[ebp], 0
  000c0	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  000c3	76 1f		 jbe	 SHORT $L56965
  000c5	8b 55 f0	 mov	 edx, DWORD PTR _pBase$[ebp]
  000c8	2b d0		 sub	 edx, eax
$L56963:
  000ca	ff 45 10	 inc	 DWORD PTR _i$56962[ebp]

; 61   :             newarr[i] = pBase[i];

  000cd	6a 11		 push	 17			; 00000011H
  000cf	8d 34 02	 lea	 esi, DWORD PTR [edx+eax]
  000d2	8b f8		 mov	 edi, eax
  000d4	59		 pop	 ecx
  000d5	f3 a5		 rep movsd
  000d7	8b 4d 10	 mov	 ecx, DWORD PTR _i$56962[ebp]
  000da	83 c0 44	 add	 eax, 68			; 00000044H
  000dd	3b 0b		 cmp	 ecx, DWORD PTR [ebx]
  000df	72 e9		 jb	 SHORT $L56963

; 59   :             return FALSE;
; 60   :         for (DWORD i = 0; i < *pcNum; i++)

  000e1	8b 75 e8	 mov	 esi, DWORD PTR _cNewMax$56953[ebp]
$L56965:

; 62   :         *pcMax = cNewMax;

  000e4	8b 45 14	 mov	 eax, DWORD PTR _pcMax$[ebp]

; 63   :         delete []pBase;

  000e7	ff 75 f0	 push	 DWORD PTR _pBase$[ebp]
  000ea	89 30		 mov	 DWORD PTR [eax], esi
  000ec	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 64   :         pBase = newarr;

  000f1	8b 45 ec	 mov	 eax, DWORD PTR $T57283[ebp]
  000f4	59		 pop	 ecx
  000f5	89 45 f0	 mov	 DWORD PTR _pBase$[ebp], eax
$L56952:

; 65   :     }
; 66   :     pBase[ (*pcNum)++ ] = obj;

  000f8	8b 3b		 mov	 edi, DWORD PTR [ebx]
  000fa	8b 75 0c	 mov	 esi, DWORD PTR _obj$[ebp]
  000fd	6b ff 44	 imul	 edi, 68			; 00000044H
  00100	03 7d f0	 add	 edi, DWORD PTR _pBase$[ebp]

; 67   :     *ppBase = pBase;

  00103	8b 45 f0	 mov	 eax, DWORD PTR _pBase$[ebp]
  00106	6a 11		 push	 17			; 00000011H
  00108	59		 pop	 ecx
  00109	f3 a5		 rep movsd
  0010b	ff 03		 inc	 DWORD PTR [ebx]
  0010d	8b 4d 08	 mov	 ecx, DWORD PTR _ppBase$[ebp]
  00110	89 01		 mov	 DWORD PTR [ecx], eax

; 68   :     return TRUE;

  00112	33 c0		 xor	 eax, eax
  00114	40		 inc	 eax
$L56944:

; 69   : }

  00115	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00118	5f		 pop	 edi
  00119	5e		 pop	 esi
  0011a	5b		 pop	 ebx
  0011b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00122	c9		 leave
  00123	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L57288:
  00000	ff 75 10	 push	 DWORD PTR $T57279[ebp]
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
$L57289:
  0000a	ff 75 10	 push	 DWORD PTR $T57284[ebp]
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	59		 pop	 ecx
  00013	c3		 ret	 0
__ehhandler$??$AddToDynamicArray@USLoadVertex@GXU@@@@YAHPAPAUSLoadVertex@GXU@@ABU01@PAK2@Z:
  00014	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T57291
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$AddToDynamicArray@USLoadVertex@GXU@@@@YAHPAPAUSLoadVertex@GXU@@ABU01@PAK2@Z ENDP ; AddToDynamicArray<GXU::SLoadVertex>
PUBLIC	?SetVertexColor@GXU@@YAJPAUSLoadedFace@1@KAAUD3DXCOLOR@@PAPAUSLoadVertex@1@PAK3@Z ; GXU::SetVertexColor
; Function compile flags: /Ogs
;	COMDAT ?SetVertexColor@GXU@@YAJPAUSLoadedFace@1@KAAUD3DXCOLOR@@PAPAUSLoadVertex@1@PAK3@Z
_TEXT	SEGMENT
_lvVertexNew$ = -72					; size = 68
_hr$ = -4						; size = 4
_pface$ = 8						; size = 4
tv225 = 12						; size = 4
_iPoint$ = 12						; size = 4
_color$ = 16						; size = 4
_prglvLoaded$ = 20					; size = 4
_pcVertices$ = 24					; size = 4
_pcVerticesMax$ = 28					; size = 4
?SetVertexColor@GXU@@YAJPAUSLoadedFace@1@KAAUD3DXCOLOR@@PAPAUSLoadVertex@1@PAK3@Z PROC NEAR ; GXU::SetVertexColor, COMDAT

; 149  : }

  00000	8b ff		 npad	 2

; 78   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 48	 sub	 esp, 72			; 00000048H

; 79   :     HRESULT hr = S_OK;
; 80   :     SLoadVertex *plvVertex;
; 81   :     SLoadVertex lvVertexNew;
; 82   :     DWORD iVertex;
; 83   :     DWORD iVertexNew;
; 84   :     DWORD wCur;
; 85   :     DWORD wHead;
; 86   :     SLoadVertex *plvCur;
; 87   : 
; 88   :     GXASSERT(pface != NULL && prglvLoaded != NULL && pcVertices != NULL && pcVerticesMax != NULL);
; 89   : 
; 90   :     iVertex = pface->m_wIndices[iPoint];

  00008	8b 45 0c	 mov	 eax, DWORD PTR _iPoint$[ebp]
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _pface$[ebp]
  0000e	83 65 fc 00	 and	 DWORD PTR _hr$[ebp], 0
  00012	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 91   :     GXASSERT(iVertex < *pcVertices);
; 92   : 
; 93   :     plvVertex = &(*prglvLoaded)[iVertex];

  00015	8b 4d 14	 mov	 ecx, DWORD PTR _prglvLoaded$[ebp]
  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001a	89 45 0c	 mov	 DWORD PTR tv225[ebp], eax
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	6b c0 44	 imul	 eax, 68			; 00000044H
  00022	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]

; 94   : 
; 95   :     // if the vertex is not currently owned, take ownership
; 96   :     if (!plvVertex->m_bOwned)

  00025	80 7a 38 00	 cmp	 BYTE PTR [edx+56], 0
  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	75 13		 jne	 SHORT $L56401

; 97   :     {
; 98   :         plvVertex->m_bOwned = true;
; 99   :         plvVertex->m_color = color;

  0002d	8b 75 10	 mov	 esi, DWORD PTR _color$[ebp]
  00030	c6 42 38 01	 mov	 BYTE PTR [edx+56], 1
  00034	8d 7a 0c	 lea	 edi, DWORD PTR [edx+12]
  00037	a5		 movsd
  00038	a5		 movsd
  00039	a5		 movsd
  0003a	a5		 movsd

; 100  :     }
; 101  :     // else if the vertex is owned but the color is not the same 
; 102  :     //   NOTE: if the same, then just ignore the fact that the color was being set
; 103  :     else if (plvVertex->m_color != color)

  0003b	e9 f7 00 00 00	 jmp	 $e_Exit$56409
$L56401:
  00040	53		 push	 ebx
  00041	8b 5d 10	 mov	 ebx, DWORD PTR _color$[ebp]
  00044	d9 03		 fld	 DWORD PTR [ebx]
  00046	d9 42 0c	 fld	 DWORD PTR [edx+12]
  00049	da e9		 fucompp
  0004b	df e0		 fnstsw	 ax
  0004d	f6 c4 44	 test	 ah, 68			; 00000044H
  00050	7a 31		 jp	 SHORT $L57328
  00052	d9 43 04	 fld	 DWORD PTR [ebx+4]
  00055	d9 42 10	 fld	 DWORD PTR [edx+16]
  00058	da e9		 fucompp
  0005a	df e0		 fnstsw	 ax
  0005c	f6 c4 44	 test	 ah, 68			; 00000044H
  0005f	7a 22		 jp	 SHORT $L57328
  00061	d9 43 08	 fld	 DWORD PTR [ebx+8]
  00064	d9 42 14	 fld	 DWORD PTR [edx+20]
  00067	da e9		 fucompp
  00069	df e0		 fnstsw	 ax
  0006b	f6 c4 44	 test	 ah, 68			; 00000044H
  0006e	7a 13		 jp	 SHORT $L57328
  00070	d9 43 0c	 fld	 DWORD PTR [ebx+12]
  00073	d9 42 18	 fld	 DWORD PTR [edx+24]
  00076	da e9		 fucompp
  00078	df e0		 fnstsw	 ax
  0007a	f6 c4 44	 test	 ah, 68			; 00000044H
  0007d	0f 8b b3 00 00
	00		 jnp	 $L57344
$L57328:

; 104  :     {
; 105  :         lvVertexNew = *plvVertex;
; 106  :         GXASSERT(lvVertexNew.m_bOwned);
; 107  : 
; 108  :         // UNDONE - this is currently rechecking the first vertex, might be possible
; 109  :         //   to skip depending on sematics of the mesh file
; 110  :         wHead = iVertex;
; 111  :         wCur = wHead;

  00083	8b 45 0c	 mov	 eax, DWORD PTR tv225[ebp]
  00086	6a 11		 push	 17			; 00000011H
  00088	59		 pop	 ecx
  00089	8b f2		 mov	 esi, edx
  0008b	8d 7d b8	 lea	 edi, DWORD PTR _lvVertexNew$[ebp]
  0008e	f3 a5		 rep movsd
  00090	8b 38		 mov	 edi, DWORD PTR [eax]
  00092	8b f7		 mov	 esi, edi
$L56405:

; 112  :         do
; 113  :         {
; 114  :             plvCur = &( (*prglvLoaded)[wCur] );
; 115  : 
; 116  :             if (plvCur->m_color == color)

  00094	8b 45 14	 mov	 eax, DWORD PTR _prglvLoaded$[ebp]
  00097	d9 03		 fld	 DWORD PTR [ebx]
  00099	8b 00		 mov	 eax, DWORD PTR [eax]
  0009b	8b ce		 mov	 ecx, esi
  0009d	6b c9 44	 imul	 ecx, 68			; 00000044H
  000a0	03 c8		 add	 ecx, eax
  000a2	d9 41 0c	 fld	 DWORD PTR [ecx+12]
  000a5	da e9		 fucompp
  000a7	df e0		 fnstsw	 ax
  000a9	f6 c4 44	 test	 ah, 68			; 00000044H
  000ac	7a 2d		 jp	 SHORT $L57336
  000ae	d9 43 04	 fld	 DWORD PTR [ebx+4]
  000b1	d9 41 10	 fld	 DWORD PTR [ecx+16]
  000b4	da e9		 fucompp
  000b6	df e0		 fnstsw	 ax
  000b8	f6 c4 44	 test	 ah, 68			; 00000044H
  000bb	7a 1e		 jp	 SHORT $L57336
  000bd	d9 43 08	 fld	 DWORD PTR [ebx+8]
  000c0	d9 41 14	 fld	 DWORD PTR [ecx+20]
  000c3	da e9		 fucompp
  000c5	df e0		 fnstsw	 ax
  000c7	f6 c4 44	 test	 ah, 68			; 00000044H
  000ca	7a 0f		 jp	 SHORT $L57336
  000cc	d9 43 0c	 fld	 DWORD PTR [ebx+12]
  000cf	d9 41 18	 fld	 DWORD PTR [ecx+24]
  000d2	da e9		 fucompp
  000d4	df e0		 fnstsw	 ax
  000d6	f6 c4 44	 test	 ah, 68			; 00000044H
  000d9	7b 56		 jnp	 SHORT $L57342
$L57336:

; 117  :             {
; 118  :                 // found an equivalent wedge, just point at it
; 119  :                 pface->m_wIndices[iPoint] = wCur;
; 120  :                 goto e_Exit;
; 121  :             }
; 122  : 
; 123  :             // go to next wedge in the vertex
; 124  :             wCur = (*prglvLoaded)[wCur].m_wPointList;

  000db	8b 71 34	 mov	 esi, DWORD PTR [ecx+52]

; 125  :         } while (wCur != wHead);

  000de	3b f7		 cmp	 esi, edi
  000e0	75 b2		 jne	 SHORT $L56405

; 126  : 
; 127  :         // set both the color and the representative point to create a new vertex that is 
; 128  :         //   logically the same in the mesh, but has a different color attribute
; 129  :         lvVertexNew.m_color = color;
; 130  :         lvVertexNew.m_wPointRep = (*prglvLoaded)[iVertex].m_wPointRep;
; 131  : 
; 132  :         iVertexNew = (DWORD)*pcVertices;
; 133  : 
; 134  :         if ( ! AddToDynamicArray( prglvLoaded, lvVertexNew, pcVertices, pcVerticesMax ) )

  000e2	ff 75 1c	 push	 DWORD PTR _pcVerticesMax$[ebp]
  000e5	8b 45 18	 mov	 eax, DWORD PTR _pcVertices$[ebp]
  000e8	8b f3		 mov	 esi, ebx
  000ea	8b 5a 30	 mov	 ebx, DWORD PTR [edx+48]
  000ed	8d 7d c4	 lea	 edi, DWORD PTR _lvVertexNew$[ebp+12]
  000f0	a5		 movsd
  000f1	a5		 movsd
  000f2	a5		 movsd
  000f3	a5		 movsd
  000f4	8b 30		 mov	 esi, DWORD PTR [eax]
  000f6	8b 7d 14	 mov	 edi, DWORD PTR _prglvLoaded$[ebp]
  000f9	50		 push	 eax
  000fa	8d 45 b8	 lea	 eax, DWORD PTR _lvVertexNew$[ebp]
  000fd	50		 push	 eax
  000fe	57		 push	 edi
  000ff	89 5d e8	 mov	 DWORD PTR _lvVertexNew$[ebp+48], ebx
  00102	e8 00 00 00 00	 call	 ??$AddToDynamicArray@USLoadVertex@GXU@@@@YAHPAPAUSLoadVertex@GXU@@ABU01@PAK2@Z ; AddToDynamicArray<GXU::SLoadVertex>
  00107	83 c4 10	 add	 esp, 16			; 00000010H
  0010a	85 c0		 test	 eax, eax
  0010c	75 09		 jne	 SHORT $L56419

; 135  :         {
; 136  :             hr = E_OUTOFMEMORY;

  0010e	c7 45 fc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 145  :     }
; 146  : 
; 147  : e_Exit:

  00115	eb 1f		 jmp	 SHORT $L57344
$L56419:

; 137  :             goto e_Exit;
; 138  :         }
; 139  : 
; 140  :         (*prglvLoaded)[iVertexNew].m_wPointList = (*prglvLoaded)[lvVertexNew.m_wPointRep].m_wPointList;

  00117	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00119	8b c3		 mov	 eax, ebx
  0011b	6b c0 44	 imul	 eax, 68			; 00000044H
  0011e	8b 5c 08 34	 mov	 ebx, DWORD PTR [eax+ecx+52]
  00122	8b d6		 mov	 edx, esi
  00124	6b d2 44	 imul	 edx, 68			; 00000044H
  00127	89 5c 0a 34	 mov	 DWORD PTR [edx+ecx+52], ebx

; 141  :         (*prglvLoaded)[lvVertexNew.m_wPointRep].m_wPointList = iVertexNew;

  0012b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0012d	89 74 01 34	 mov	 DWORD PTR [ecx+eax+52], esi
$L57342:

; 142  : 
; 143  :         // now update the face to refer to the new point with the correct attributes
; 144  :         pface->m_wIndices[iPoint] = iVertexNew;

  00131	8b 45 0c	 mov	 eax, DWORD PTR tv225[ebp]
  00134	89 30		 mov	 DWORD PTR [eax], esi
$L57344:
  00136	5b		 pop	 ebx
$e_Exit$56409:

; 148  :     return hr;

  00137	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  0013a	5f		 pop	 edi
  0013b	5e		 pop	 esi

; 149  : }

  0013c	c9		 leave
  0013d	c3		 ret	 0
?SetVertexColor@GXU@@YAJPAUSLoadedFace@1@KAAUD3DXCOLOR@@PAPAUSLoadVertex@1@PAK3@Z ENDP ; GXU::SetVertexColor
_TEXT	ENDS
PUBLIC	?SetVertexAttributes@GXU@@YAJPAUSLoadedFace@1@KPAUD3DXVECTOR3@@PAUD3DXVECTOR2@@PAPAUSLoadVertex@1@PAK4@Z ; GXU::SetVertexAttributes
; Function compile flags: /Ogs
;	COMDAT ?SetVertexAttributes@GXU@@YAJPAUSLoadedFace@1@KPAUD3DXVECTOR3@@PAUD3DXVECTOR2@@PAPAUSLoadVertex@1@PAK4@Z
_TEXT	SEGMENT
_lvVertexNew$ = -76					; size = 68
_hr$ = -8						; size = 4
tv225 = -4						; size = 4
_iVertex$ = 8						; size = 4
_pface$ = 8						; size = 4
_wCur$ = 12						; size = 4
_iPoint$ = 12						; size = 4
_pvNormal$ = 16						; size = 4
_puvTex1$ = 20						; size = 4
tv281 = 24						; size = 4
_prglvLoaded$ = 24					; size = 4
_pcVertices$ = 28					; size = 4
_pcVerticesMax$ = 32					; size = 4
?SetVertexAttributes@GXU@@YAJPAUSLoadedFace@1@KPAUD3DXVECTOR3@@PAUD3DXVECTOR2@@PAPAUSLoadVertex@1@PAK4@Z PROC NEAR ; GXU::SetVertexAttributes, COMDAT

; 238  : }

  00000	8b ff		 npad	 2

; 153  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 154  :     HRESULT hr = S_OK;
; 155  :     SLoadVertex *plvVertex;
; 156  :     SLoadVertex lvVertexNew;
; 157  :     DWORD iVertex;
; 158  :     DWORD iVertexNew;
; 159  :     DWORD wCur;
; 160  :     DWORD wHead;
; 161  :     SLoadVertex *plvCur;
; 162  : 
; 163  :     GXASSERT(pface != NULL && prglvLoaded != NULL && pcVertices != NULL && pcVerticesMax != NULL);
; 164  : 
; 165  :     iVertex = pface->m_wIndices[iPoint];

  00008	8b 4d 08	 mov	 ecx, DWORD PTR _pface$[ebp]
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _iPoint$[ebp]
  0000e	83 65 f8 00	 and	 DWORD PTR _hr$[ebp], 0
  00012	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00015	53		 push	 ebx
  00016	89 45 fc	 mov	 DWORD PTR tv225[ebp], eax
  00019	8b 00		 mov	 eax, DWORD PTR [eax]

; 166  :     GXASSERT(iVertex < *pcVertices);
; 167  : 
; 168  :     plvVertex = &(*prglvLoaded)[iVertex];

  0001b	8b d8		 mov	 ebx, eax
  0001d	6b db 44	 imul	 ebx, 68			; 00000044H
  00020	89 45 08	 mov	 DWORD PTR _iVertex$[ebp], eax
  00023	8b 45 18	 mov	 eax, DWORD PTR _prglvLoaded$[ebp]
  00026	8b 10		 mov	 edx, DWORD PTR [eax]
  00028	03 d3		 add	 edx, ebx

; 169  : 
; 170  :     // UNDONE craigp - It might be useful to search all instances of a logical vertex
; 171  :     //   in order to find another one to share with
; 172  : 
; 173  :     // if the vertex is not currently owned, take ownership
; 174  :     if (!plvVertex->m_bOwned)

  0002a	80 7a 38 00	 cmp	 BYTE PTR [edx+56], 0
  0002e	56		 push	 esi
  0002f	57		 push	 edi
  00030	75 2c		 jne	 SHORT $L56444

; 175  :     {
; 176  :         plvVertex->m_bOwned = true;
; 177  : 
; 178  :         if (pvNormal != NULL)

  00032	8b 75 10	 mov	 esi, DWORD PTR _pvNormal$[ebp]
  00035	85 f6		 test	 esi, esi
  00037	c6 42 38 01	 mov	 BYTE PTR [edx+56], 1
  0003b	74 06		 je	 SHORT $L56445

; 179  :             plvVertex->m_vNormal = *pvNormal;

  0003d	8d 7a 24	 lea	 edi, DWORD PTR [edx+36]
  00040	a5		 movsd
  00041	a5		 movsd
  00042	a5		 movsd
$L56445:

; 180  : 
; 181  :         if (puvTex1 != NULL)

  00043	8b 45 14	 mov	 eax, DWORD PTR _puvTex1$[ebp]
  00046	85 c0		 test	 eax, eax
  00048	0f 84 25 01 00
	00		 je	 $e_Exit$56458

; 182  :             plvVertex->m_uvTex1 = *puvTex1;

  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx
  00053	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00056	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 183  :     }
; 184  :     else if (((pvNormal != NULL) && (plvVertex->m_vNormal != *pvNormal))

  00059	e9 15 01 00 00	 jmp	 $e_Exit$56458
$L56444:

; 185  :             || ((puvTex1 != NULL) && (plvVertex->m_uvTex1 != *puvTex1)))

  0005e	8b 4d 10	 mov	 ecx, DWORD PTR _pvNormal$[ebp]
  00061	85 c9		 test	 ecx, ecx
  00063	74 2c		 je	 SHORT $L56450
  00065	d9 01		 fld	 DWORD PTR [ecx]
  00067	d9 42 24	 fld	 DWORD PTR [edx+36]
  0006a	da e9		 fucompp
  0006c	df e0		 fnstsw	 ax
  0006e	f6 c4 44	 test	 ah, 68			; 00000044H
  00071	7a 4a		 jp	 SHORT $L57381
  00073	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00076	d9 42 28	 fld	 DWORD PTR [edx+40]
  00079	da e9		 fucompp
  0007b	df e0		 fnstsw	 ax
  0007d	f6 c4 44	 test	 ah, 68			; 00000044H
  00080	7a 3b		 jp	 SHORT $L57381
  00082	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00085	d9 42 2c	 fld	 DWORD PTR [edx+44]
  00088	da e9		 fucompp
  0008a	df e0		 fnstsw	 ax
  0008c	f6 c4 44	 test	 ah, 68			; 00000044H
  0008f	7a 2c		 jp	 SHORT $L57381
$L56450:
  00091	8b 4d 14	 mov	 ecx, DWORD PTR _puvTex1$[ebp]
  00094	85 c9		 test	 ecx, ecx
  00096	0f 84 d7 00 00
	00		 je	 $e_Exit$56458
  0009c	d9 01		 fld	 DWORD PTR [ecx]
  0009e	d9 42 1c	 fld	 DWORD PTR [edx+28]
  000a1	da e9		 fucompp
  000a3	df e0		 fnstsw	 ax
  000a5	f6 c4 44	 test	 ah, 68			; 00000044H
  000a8	7a 13		 jp	 SHORT $L57381
  000aa	d9 41 04	 fld	 DWORD PTR [ecx+4]
  000ad	d9 42 20	 fld	 DWORD PTR [edx+32]
  000b0	da e9		 fucompp
  000b2	df e0		 fnstsw	 ax
  000b4	f6 c4 44	 test	 ah, 68			; 00000044H
  000b7	0f 8b b6 00 00
	00		 jnp	 $e_Exit$56458
$L57381:

; 186  :     {
; 187  :         lvVertexNew = *plvVertex;

  000bd	6a 11		 push	 17			; 00000011H
  000bf	59		 pop	 ecx
  000c0	8b f2		 mov	 esi, edx
  000c2	8d 7d b4	 lea	 edi, DWORD PTR _lvVertexNew$[ebp]
  000c5	f3 a5		 rep movsd

; 188  :         GXASSERT(lvVertexNew.m_bOwned);
; 189  : 
; 190  :         // set both the attributes and the representative point to create a new vertex that is 
; 191  :         //   logically the same in the mesh, but has a different vertex attributes
; 192  : 
; 193  :         if (pvNormal != NULL)

  000c7	8b 75 10	 mov	 esi, DWORD PTR _pvNormal$[ebp]
  000ca	85 f6		 test	 esi, esi
  000cc	74 06		 je	 SHORT $L56452

; 194  :             lvVertexNew.m_vNormal = *pvNormal;

  000ce	8d 7d d8	 lea	 edi, DWORD PTR _lvVertexNew$[ebp+36]
  000d1	a5		 movsd
  000d2	a5		 movsd
  000d3	a5		 movsd
$L56452:

; 195  : 
; 196  :         if (puvTex1 != NULL)

  000d4	8b 45 14	 mov	 eax, DWORD PTR _puvTex1$[ebp]
  000d7	85 c0		 test	 eax, eax
  000d9	74 0b		 je	 SHORT $L56453

; 197  :             plvVertex->m_uvTex1 = *puvTex1;

  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx
  000e0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e3	89 42 20	 mov	 DWORD PTR [edx+32], eax
$L56453:

; 198  : 
; 199  :         // UNDONE - this is currently rechecking the first vertex, might be possible
; 200  :         //   to skip depending on sematics of the mesh file
; 201  :         wHead = iVertex;
; 202  :         wCur = wHead;

  000e6	8b 45 08	 mov	 eax, DWORD PTR _iVertex$[ebp]
  000e9	8b 7d 18	 mov	 edi, DWORD PTR _prglvLoaded$[ebp]
  000ec	8b 37		 mov	 esi, DWORD PTR [edi]
  000ee	89 45 0c	 mov	 DWORD PTR _wCur$[ebp], eax
$L56454:

; 203  :         do
; 204  :         {
; 205  :             plvCur = &( (*prglvLoaded)[wCur] );

  000f1	8b 45 0c	 mov	 eax, DWORD PTR _wCur$[ebp]
  000f4	6b c0 44	 imul	 eax, 68			; 00000044H
  000f7	03 c6		 add	 eax, esi

; 206  : 
; 207  :             if (plvCur->m_bOwned && BEqualWedges(*plvCur, lvVertexNew))

  000f9	80 78 38 00	 cmp	 BYTE PTR [eax+56], 0
  000fd	89 45 18	 mov	 DWORD PTR tv281[ebp], eax
  00100	74 13		 je	 SHORT $L56457
  00102	8d 4d b4	 lea	 ecx, DWORD PTR _lvVertexNew$[ebp]
  00105	51		 push	 ecx
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 ?BEqualWedges@GXU@@YA_NAAUSLoadVertex@1@0@Z ; GXU::BEqualWedges
  0010c	84 c0		 test	 al, al
  0010e	59		 pop	 ecx
  0010f	59		 pop	 ecx
  00110	75 38		 jne	 SHORT $L57386
  00112	8b 45 18	 mov	 eax, DWORD PTR tv281[ebp]
$L56457:

; 212  :             }
; 213  : 
; 214  :             // go to next wedge in the vertex
; 215  :             wCur = (*prglvLoaded)[wCur].m_wPointList;

  00115	8b 40 34	 mov	 eax, DWORD PTR [eax+52]

; 216  :         } while (wCur != wHead);

  00118	3b 45 08	 cmp	 eax, DWORD PTR _iVertex$[ebp]
  0011b	89 45 0c	 mov	 DWORD PTR _wCur$[ebp], eax
  0011e	75 d1		 jne	 SHORT $L56454

; 217  : 
; 218  :         lvVertexNew.m_wPointRep = (*prglvLoaded)[iVertex].m_wPointRep;
; 219  : 
; 220  :         iVertexNew = (DWORD)*pcVertices;
; 221  : 
; 222  :         if ( ! AddToDynamicArray( prglvLoaded, lvVertexNew, pcVertices, pcVerticesMax ) )

  00120	ff 75 20	 push	 DWORD PTR _pcVerticesMax$[ebp]
  00123	8b 45 1c	 mov	 eax, DWORD PTR _pcVertices$[ebp]
  00126	8b 5c 1e 30	 mov	 ebx, DWORD PTR [esi+ebx+48]
  0012a	8b 30		 mov	 esi, DWORD PTR [eax]
  0012c	50		 push	 eax
  0012d	8d 45 b4	 lea	 eax, DWORD PTR _lvVertexNew$[ebp]
  00130	50		 push	 eax
  00131	57		 push	 edi
  00132	89 5d e4	 mov	 DWORD PTR _lvVertexNew$[ebp+48], ebx
  00135	e8 00 00 00 00	 call	 ??$AddToDynamicArray@USLoadVertex@GXU@@@@YAHPAPAUSLoadVertex@GXU@@ABU01@PAK2@Z ; AddToDynamicArray<GXU::SLoadVertex>
  0013a	83 c4 10	 add	 esp, 16			; 00000010H
  0013d	85 c0		 test	 eax, eax
  0013f	75 13		 jne	 SHORT $L56461

; 223  :         {
; 224  :             hr = E_OUTOFMEMORY;

  00141	c7 45 f8 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 234  :     }
; 235  : 
; 236  : e_Exit:

  00148	eb 29		 jmp	 SHORT $e_Exit$56458
$L57386:

; 208  :             {
; 209  :                 // found an equivalent wedge, just point at it
; 210  :                 pface->m_wIndices[iPoint] = wCur;

  0014a	8b 45 fc	 mov	 eax, DWORD PTR tv225[ebp]
  0014d	8b 4d 0c	 mov	 ecx, DWORD PTR _wCur$[ebp]
  00150	89 08		 mov	 DWORD PTR [eax], ecx

; 211  :                 goto e_Exit;

  00152	eb 1f		 jmp	 SHORT $e_Exit$56458
$L56461:

; 225  :             goto e_Exit;
; 226  :         }
; 227  : 
; 228  :         // link the vertex in to the vertex list
; 229  :         (*prglvLoaded)[iVertexNew].m_wPointList = (*prglvLoaded)[lvVertexNew.m_wPointRep].m_wPointList;

  00154	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00156	8b c3		 mov	 eax, ebx
  00158	6b c0 44	 imul	 eax, 68			; 00000044H
  0015b	8b 5c 08 34	 mov	 ebx, DWORD PTR [eax+ecx+52]
  0015f	8b d6		 mov	 edx, esi
  00161	6b d2 44	 imul	 edx, 68			; 00000044H
  00164	89 5c 0a 34	 mov	 DWORD PTR [edx+ecx+52], ebx

; 230  :         (*prglvLoaded)[lvVertexNew.m_wPointRep].m_wPointList = iVertexNew;

  00168	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0016a	89 74 01 34	 mov	 DWORD PTR [ecx+eax+52], esi

; 231  : 
; 232  :         // now update the face to refer to the new point with the correct attributes
; 233  :         pface->m_wIndices[iPoint] = iVertexNew;

  0016e	8b 45 fc	 mov	 eax, DWORD PTR tv225[ebp]
  00171	89 30		 mov	 DWORD PTR [eax], esi
$e_Exit$56458:

; 237  :     return hr;

  00173	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
  00176	5f		 pop	 edi
  00177	5e		 pop	 esi
  00178	5b		 pop	 ebx

; 238  : }

  00179	c9		 leave
  0017a	c3		 ret	 0
?SetVertexAttributes@GXU@@YAJPAUSLoadedFace@1@KPAUD3DXVECTOR3@@PAUD3DXVECTOR2@@PAPAUSLoadVertex@1@PAK4@Z ENDP ; GXU::SetVertexAttributes
_TEXT	ENDS
PUBLIC	?SetSmoothingGroup@GXU@@YAJPAUSLoadedFace@1@KGAAUD3DXVECTOR3@@PAPAUSLoadVertex@1@PAK3@Z ; GXU::SetSmoothingGroup
; Function compile flags: /Ogs
;	COMDAT ?SetSmoothingGroup@GXU@@YAJPAUSLoadedFace@1@KGAAUD3DXVECTOR3@@PAPAUSLoadVertex@1@PAK3@Z
_TEXT	SEGMENT
_lvVertexNew$ = -72					; size = 68
_hr$ = -4						; size = 4
_pface$ = 8						; size = 4
tv257 = 12						; size = 4
_iPoint$ = 12						; size = 4
_iSmoothingGroup$ = 16					; size = 2
_vNormal$ = 20						; size = 4
_prglvLoaded$ = 24					; size = 4
_pcVertices$ = 28					; size = 4
_pcVerticesMax$ = 32					; size = 4
?SetSmoothingGroup@GXU@@YAJPAUSLoadedFace@1@KGAAUD3DXVECTOR3@@PAPAUSLoadVertex@1@PAK3@Z PROC NEAR ; GXU::SetSmoothingGroup, COMDAT

; 355  : }

  00000	8b ff		 npad	 2

; 242  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 48	 sub	 esp, 72			; 00000048H

; 243  :     HRESULT hr = S_OK;
; 244  :     SLoadVertex *plvVertex;
; 245  :     SLoadVertex lvVertexNew;
; 246  :     DWORD iVertex;
; 247  :     DWORD iVertexNew;
; 248  :     DWORD wCur;
; 249  :     DWORD wHead;
; 250  :     DWORD wWedgeFound;
; 251  :     SLoadVertex *plvCur;
; 252  : 
; 253  :     GXASSERT(pface != NULL && prglvLoaded != NULL && pcVertices != NULL && pcVerticesMax != NULL);
; 254  : 
; 255  :     iVertex = pface->m_wIndices[iPoint];

  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _iPoint$[ebp]
  0000b	8b 55 08	 mov	 edx, DWORD PTR _pface$[ebp]
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d 3c 8a	 lea	 edi, DWORD PTR [edx+ecx*4]
  00013	8b 37		 mov	 esi, DWORD PTR [edi]

; 256  :     GXASSERT(iVertex < *pcVertices);
; 257  : 
; 258  :     plvVertex = &(*prglvLoaded)[iVertex];

  00015	8b 4d 18	 mov	 ecx, DWORD PTR _prglvLoaded$[ebp]
  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001a	8b d6		 mov	 edx, esi
  0001c	6b d2 44	 imul	 edx, 68			; 00000044H
  0001f	33 c0		 xor	 eax, eax
  00021	03 d1		 add	 edx, ecx

; 259  : 
; 260  :     // if the vertex is not currently owned, take ownership
; 261  :     if (plvVertex->m_cSmoothingGroupFaces == 0)

  00023	66 39 42 3c	 cmp	 WORD PTR [edx+60], ax
  00027	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  0002a	89 7d 0c	 mov	 DWORD PTR tv257[ebp], edi
  0002d	75 1c		 jne	 SHORT $L56485

; 262  :     {
; 263  :         GXASSERT(plvVertex->m_iSmoothingGroup == 0);
; 264  : 
; 265  :         plvVertex->m_cSmoothingGroupFaces = 1;
; 266  :         plvVertex->m_iSmoothingGroup = iSmoothingGroup;

  0002f	66 8b 45 10	 mov	 ax, WORD PTR _iSmoothingGroup$[ebp]

; 267  : 
; 268  :         plvVertex->m_vNormal = vNormal;

  00033	8b 75 14	 mov	 esi, DWORD PTR _vNormal$[ebp]
  00036	66 c7 42 3c 01
	00		 mov	 WORD PTR [edx+60], 1
  0003c	66 89 42 3a	 mov	 WORD PTR [edx+58], ax
  00040	8d 7a 24	 lea	 edi, DWORD PTR [edx+36]
  00043	a5		 movsd
  00044	a5		 movsd
  00045	a5		 movsd

; 269  :     }
; 270  :     else

  00046	e9 17 01 00 00	 jmp	 $e_Exit$56503
$L56485:

; 271  :     {       
; 272  : 
; 273  :         if (iSmoothingGroup > 0)

  0004b	66 39 45 10	 cmp	 WORD PTR _iSmoothingGroup$[ebp], ax
  0004f	53		 push	 ebx
  00050	8b 5d 14	 mov	 ebx, DWORD PTR _vNormal$[ebp]
  00053	76 6c		 jbe	 SHORT $L56494
$L56489:

; 274  :         {
; 275  :             wHead = iVertex;
; 276  :             wCur = wHead;
; 277  :             wWedgeFound = UNUSED32;
; 278  :             do
; 279  :             {
; 280  :                 plvCur = &( (*prglvLoaded)[wCur] );
; 281  : 
; 282  :                 if (plvVertex->m_iSmoothingGroup == iSmoothingGroup)

  00055	66 8b 42 3a	 mov	 ax, WORD PTR [edx+58]
  00059	66 3b 45 10	 cmp	 ax, WORD PTR _iSmoothingGroup$[ebp]
  0005d	0f 84 a4 00 00
	00		 je	 $L56496

; 283  :                 {
; 284  :                     // found a wedge of this smoothing group
; 285  :                     wWedgeFound = wCur;
; 286  :                     break;
; 287  :                 }
; 288  : 
; 289  :                 // go to next wedge in the vertex
; 290  :                 wCur = (*prglvLoaded)[wCur].m_wPointList;

  00063	6b f6 44	 imul	 esi, 68			; 00000044H
  00066	8b 74 0e 34	 mov	 esi, DWORD PTR [esi+ecx+52]

; 291  :             } while (wCur != wHead);

  0006a	3b 37		 cmp	 esi, DWORD PTR [edi]
  0006c	75 e7		 jne	 SHORT $L56489
$L56498:

; 326  :         {
; 327  :             lvVertexNew = *plvVertex;
; 328  : 
; 329  :             lvVertexNew.m_wPointRep = (*prglvLoaded)[iVertex].m_wPointRep;

  0006e	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00071	6a 11		 push	 17			; 00000011H
  00073	59		 pop	 ecx

; 330  : 
; 331  :             lvVertexNew.m_iSmoothingGroup = iSmoothingGroup;
; 332  :             lvVertexNew.m_cSmoothingGroupFaces = 1;
; 333  :             lvVertexNew.m_vNormal = vNormal;
; 334  : 
; 335  :             iVertexNew = (DWORD)*pcVertices;
; 336  : 
; 337  :             if ( ! AddToDynamicArray( prglvLoaded, lvVertexNew, pcVertices, pcVerticesMax ) )

  00074	ff 75 20	 push	 DWORD PTR _pcVerticesMax$[ebp]
  00077	8b f2		 mov	 esi, edx
  00079	8d 7d b8	 lea	 edi, DWORD PTR _lvVertexNew$[ebp]
  0007c	f3 a5		 rep movsd
  0007e	89 45 e8	 mov	 DWORD PTR _lvVertexNew$[ebp+48], eax
  00081	66 8b 45 10	 mov	 ax, WORD PTR _iSmoothingGroup$[ebp]
  00085	66 89 45 f2	 mov	 WORD PTR _lvVertexNew$[ebp+58], ax
  00089	8b 45 1c	 mov	 eax, DWORD PTR _pcVertices$[ebp]
  0008c	66 c7 45 f4 01
	00		 mov	 WORD PTR _lvVertexNew$[ebp+60], 1
  00092	8b f3		 mov	 esi, ebx
  00094	8d 7d dc	 lea	 edi, DWORD PTR _lvVertexNew$[ebp+36]
  00097	a5		 movsd
  00098	a5		 movsd
  00099	a5		 movsd
  0009a	8b 30		 mov	 esi, DWORD PTR [eax]
  0009c	8b 7d 18	 mov	 edi, DWORD PTR _prglvLoaded$[ebp]
  0009f	50		 push	 eax
  000a0	8d 45 b8	 lea	 eax, DWORD PTR _lvVertexNew$[ebp]
  000a3	50		 push	 eax
  000a4	57		 push	 edi
  000a5	e8 00 00 00 00	 call	 ??$AddToDynamicArray@USLoadVertex@GXU@@@@YAHPAPAUSLoadVertex@GXU@@ABU01@PAK2@Z ; AddToDynamicArray<GXU::SLoadVertex>
  000aa	83 c4 10	 add	 esp, 16			; 00000010H
  000ad	85 c0		 test	 eax, eax
  000af	0f 85 8c 00 00
	00		 jne	 $L56501

; 338  :             {
; 339  :                 hr = E_OUTOFMEMORY;

  000b5	c7 45 fc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 340  :                 goto e_Exit;

  000bc	e9 a0 00 00 00	 jmp	 $L57429
$L56494:

; 292  :         }
; 293  :         else  // in the 0 case, need to approximate flat shading so always
; 294  :             //  insert a new wedge
; 295  :         {           
; 296  :             wHead = iVertex;
; 297  :             wCur = wHead;
; 298  :             wWedgeFound = UNUSED32;
; 299  :             do
; 300  :             {
; 301  :                 plvCur = &( (*prglvLoaded)[wCur] );
; 302  : 
; 303  :                 if ((plvVertex->m_iSmoothingGroup == iSmoothingGroup) &&
; 304  :                     (plvVertex->m_vNormal == vNormal))

  000c1	66 8b 42 3a	 mov	 ax, WORD PTR [edx+58]
  000c5	66 3b 45 10	 cmp	 ax, WORD PTR _iSmoothingGroup$[ebp]
  000c9	75 2c		 jne	 SHORT $L57416
  000cb	d9 03		 fld	 DWORD PTR [ebx]
  000cd	d9 42 24	 fld	 DWORD PTR [edx+36]
  000d0	da e9		 fucompp
  000d2	df e0		 fnstsw	 ax
  000d4	f6 c4 44	 test	 ah, 68			; 00000044H
  000d7	7a 1e		 jp	 SHORT $L57416
  000d9	d9 43 04	 fld	 DWORD PTR [ebx+4]
  000dc	d9 42 28	 fld	 DWORD PTR [edx+40]
  000df	da e9		 fucompp
  000e1	df e0		 fnstsw	 ax
  000e3	f6 c4 44	 test	 ah, 68			; 00000044H
  000e6	7a 0f		 jp	 SHORT $L57416
  000e8	d9 43 08	 fld	 DWORD PTR [ebx+8]
  000eb	d9 42 2c	 fld	 DWORD PTR [edx+44]
  000ee	da e9		 fucompp
  000f0	df e0		 fnstsw	 ax
  000f2	f6 c4 44	 test	 ah, 68			; 00000044H
  000f5	7b 10		 jnp	 SHORT $L56496
$L57416:

; 305  :                 {
; 306  :                     // found a wedge of this smoothing group
; 307  :                     wWedgeFound = wCur;
; 308  :                     break;
; 309  :                 }
; 310  : 
; 311  :                 // go to next wedge in the vertex
; 312  :                 wCur = (*prglvLoaded)[wCur].m_wPointList;

  000f7	6b f6 44	 imul	 esi, 68			; 00000044H
  000fa	8b 74 0e 34	 mov	 esi, DWORD PTR [esi+ecx+52]

; 313  :             } while (wCur != wHead);

  000fe	3b 37		 cmp	 esi, DWORD PTR [edi]
  00100	75 bf		 jne	 SHORT $L56494
  00102	e9 67 ff ff ff	 jmp	 $L56498
$L56496:

; 314  :         }
; 315  : 
; 316  :         // if a wedge was found, add the current normal in to the wedge
; 317  :         if (wWedgeFound != UNUSED32)

  00107	83 fe ff	 cmp	 esi, -1
  0010a	0f 84 5e ff ff
	ff		 je	 $L56498

; 318  :         {
; 319  :             (*prglvLoaded)[wWedgeFound].m_cSmoothingGroupFaces += 1;

  00110	8b c6		 mov	 eax, esi
  00112	6b c0 44	 imul	 eax, 68			; 00000044H
  00115	8d 4c 08 3c	 lea	 ecx, DWORD PTR [eax+ecx+60]
  00119	66 ff 01	 inc	 WORD PTR [ecx]

; 320  :             (*prglvLoaded)[wWedgeFound].m_vNormal += vNormal;

  0011c	8b 4d 18	 mov	 ecx, DWORD PTR _prglvLoaded$[ebp]
  0011f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00121	d9 03		 fld	 DWORD PTR [ebx]
  00123	8d 44 01 24	 lea	 eax, DWORD PTR [ecx+eax+36]
  00127	d8 00		 fadd	 DWORD PTR [eax]
  00129	d9 18		 fstp	 DWORD PTR [eax]
  0012b	d9 43 04	 fld	 DWORD PTR [ebx+4]
  0012e	d8 40 04	 fadd	 DWORD PTR [eax+4]
  00131	d9 58 04	 fstp	 DWORD PTR [eax+4]
  00134	d9 43 08	 fld	 DWORD PTR [ebx+8]
  00137	d8 40 08	 fadd	 DWORD PTR [eax+8]
  0013a	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 321  : 
; 322  :             // now update the face to refer to the new point with the correct attributes
; 323  :             pface->m_wIndices[iPoint] = wWedgeFound;

  0013d	89 37		 mov	 DWORD PTR [edi], esi

; 324  :         }
; 325  :         else  // if no matching wedge found.  add a new wedge

  0013f	eb 20		 jmp	 SHORT $L57429
$L56501:

; 341  :             }
; 342  : 
; 343  :             // link the vertex in to the vertex list
; 344  :             (*prglvLoaded)[iVertexNew].m_wPointList = (*prglvLoaded)[lvVertexNew.m_wPointRep].m_wPointList;

  00141	8b 45 e8	 mov	 eax, DWORD PTR _lvVertexNew$[ebp+48]
  00144	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00146	6b c0 44	 imul	 eax, 68			; 00000044H
  00149	8b 5c 08 34	 mov	 ebx, DWORD PTR [eax+ecx+52]
  0014d	8b d6		 mov	 edx, esi
  0014f	6b d2 44	 imul	 edx, 68			; 00000044H
  00152	89 5c 0a 34	 mov	 DWORD PTR [edx+ecx+52], ebx

; 345  :             (*prglvLoaded)[lvVertexNew.m_wPointRep].m_wPointList = iVertexNew;

  00156	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00158	89 74 01 34	 mov	 DWORD PTR [ecx+eax+52], esi

; 346  : 
; 347  :             // now update the face to refer to the new point with the correct attributes
; 348  :             pface->m_wIndices[iPoint] = iVertexNew;

  0015c	8b 45 0c	 mov	 eax, DWORD PTR tv257[ebp]
  0015f	89 30		 mov	 DWORD PTR [eax], esi
$L57429:
  00161	5b		 pop	 ebx
$e_Exit$56503:

; 349  :         }
; 350  : 
; 351  :     }
; 352  : 
; 353  : e_Exit:
; 354  :     return hr;

  00162	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00165	5f		 pop	 edi
  00166	5e		 pop	 esi

; 355  : }

  00167	c9		 leave
  00168	c3		 ret	 0
?SetSmoothingGroup@GXU@@YAJPAUSLoadedFace@1@KGAAUD3DXVECTOR3@@PAPAUSLoadVertex@1@PAK3@Z ENDP ; GXU::SetSmoothingGroup
_TEXT	ENDS
PUBLIC	?InitCorners@GXU@@YAJAAPAUSCorner@1@K@Z		; GXU::InitCorners
;	COMDAT xdata$x
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.inl
xdata$x	SEGMENT
$T57450	DD	0ffffffffH
	DD	FLAT:$L57438
$T57446	DD	019930520H
	DD	01H
	DD	FLAT:$T57450
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\loadutil.cpp
xdata$x	ENDS
;	COMDAT ?InitCorners@GXU@@YAJAAPAUSCorner@1@K@Z
_TEXT	SEGMENT
$T57436 = -36						; size = 12
$T57437 = -24						; size = 8
_hr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_rgCorners$ = 8						; size = 4
$T57433 = 12						; size = 4
_cCorners$ = 12						; size = 4
?InitCorners@GXU@@YAJAAPAUSCorner@1@K@Z PROC NEAR	; GXU::InitCorners, COMDAT

; 412  : {

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?InitCorners@GXU@@YAJAAPAUSCorner@1@K@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 18	 sub	 esp, 24			; 00000018H

; 413  :     HRESULT hr = S_OK;

  0000d	83 65 f0 00	 and	 DWORD PTR _hr$[ebp], 0
  00011	53		 push	 ebx

; 414  :     DWORD iCorner;
; 415  : 
; 416  :     rgCorners = new SCorner[cCorners];

  00012	8b 5d 0c	 mov	 ebx, DWORD PTR _cCorners$[ebp]
  00015	8b c3		 mov	 eax, ebx
  00017	c1 e0 05	 shl	 eax, 5
  0001a	56		 push	 esi
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00021	8b f0		 mov	 esi, eax
  00023	59		 pop	 ecx
  00024	89 75 0c	 mov	 DWORD PTR $T57433[ebp], esi
  00027	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	85 f6		 test	 esi, esi
  0002d	74 12		 je	 SHORT $L57434
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??0SCorner@GXU@@QAE@XZ
  00034	53		 push	 ebx
  00035	6a 20		 push	 32			; 00000020H
  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 ??_H@YGXPAXIHP6EPAX0@Z@Z
  0003d	8b c6		 mov	 eax, esi
  0003f	eb 02		 jmp	 SHORT $L57435
$L57434:
  00041	33 c0		 xor	 eax, eax
$L57435:

; 417  :     if (rgCorners == NULL)

  00043	85 c0		 test	 eax, eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _rgCorners$[ebp]
  00048	89 01		 mov	 DWORD PTR [ecx], eax
  0004a	75 09		 jne	 SHORT $L56553

; 418  :     {
; 419  :         hr = E_OUTOFMEMORY;

  0004c	c7 45 f0 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 420  :         goto e_Exit;

  00053	eb 62		 jmp	 SHORT $e_Exit$56555
$L56553:

; 421  :     }
; 422  : 
; 423  :     for (iCorner = 0; iCorner < cCorners; iCorner++)

  00055	85 db		 test	 ebx, ebx
  00057	76 5e		 jbe	 SHORT $e_Exit$56555

; 424  :     {
; 425  :         rgCorners[iCorner].m_wPoint = UNUSED32;
; 426  :         rgCorners[iCorner].m_wFace = UNUSED32;
; 427  : 
; 428  :         rgCorners[iCorner].m_vNormal = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  00059	d9 ee		 fldz
  0005b	33 c0		 xor	 eax, eax
  0005d	d9 5d dc	 fstp	 DWORD PTR $T57436[ebp]
  00060	57		 push	 edi
  00061	d9 ee		 fldz
  00063	d9 5d e0	 fstp	 DWORD PTR $T57436[ebp+4]
  00066	d9 ee		 fldz
  00068	d9 5d e4	 fstp	 DWORD PTR $T57436[ebp+8]

; 429  :         rgCorners[iCorner].m_uvTex1 = D3DXVECTOR2(0.0f, 0.0f);

  0006b	d9 ee		 fldz
  0006d	d9 5d e8	 fstp	 DWORD PTR $T57437[ebp]
  00070	d9 ee		 fldz
  00072	d9 5d ec	 fstp	 DWORD PTR $T57437[ebp+4]
$L56557:
  00075	8b 11		 mov	 edx, DWORD PTR [ecx]
  00077	83 0c 10 ff	 or	 DWORD PTR [eax+edx], -1
  0007b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007d	83 4c 10 04 ff	 or	 DWORD PTR [eax+edx+4], -1
  00082	8b 11		 mov	 edx, DWORD PTR [ecx]
  00084	8d 7c 10 14	 lea	 edi, DWORD PTR [eax+edx+20]
  00088	8d 75 dc	 lea	 esi, DWORD PTR $T57436[ebp]
  0008b	a5		 movsd
  0008c	a5		 movsd
  0008d	a5		 movsd
  0008e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00090	8b 75 e8	 mov	 esi, DWORD PTR $T57437[ebp]
  00093	89 74 10 0c	 mov	 DWORD PTR [eax+edx+12], esi
  00097	8b 75 ec	 mov	 esi, DWORD PTR $T57437[ebp+4]
  0009a	89 74 10 10	 mov	 DWORD PTR [eax+edx+16], esi

; 430  : 
; 431  :         rgCorners[iCorner].m_bNormalSpecified = false;

  0009e	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a0	8d 54 10 08	 lea	 edx, DWORD PTR [eax+edx+8]
  000a4	80 22 fe	 and	 BYTE PTR [edx], -2	; fffffffeH

; 432  :         rgCorners[iCorner].m_bUvSpecified = false;

  000a7	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a9	8d 54 10 08	 lea	 edx, DWORD PTR [eax+edx+8]
  000ad	80 22 fd	 and	 BYTE PTR [edx], -3	; fffffffdH
  000b0	83 c0 20	 add	 eax, 32			; 00000020H
  000b3	4b		 dec	 ebx
  000b4	75 bf		 jne	 SHORT $L56557
  000b6	5f		 pop	 edi
$e_Exit$56555:

; 433  :     }
; 434  : 
; 435  : e_Exit:
; 436  :     return hr;
; 437  : }

  000b7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ba	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000c6	c9		 leave
  000c7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L57438:
  00000	ff 75 0c	 push	 DWORD PTR $T57433[ebp]
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
__ehhandler$?InitCorners@GXU@@YAJAAPAUSCorner@1@K@Z:
  0000a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T57446
  0000f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?InitCorners@GXU@@YAJAAPAUSCorner@1@K@Z ENDP		; GXU::InitCorners
PUBLIC	?SetMesh@GXU@@YAJAAPAUSLoadedFace@1@KAAPAUSLoadVertex@1@KPAUSCorner@1@KPAUSFVFData@1@HPAKKKPAUIDirect3DDevice9@@PAPAUID3DXMesh@@PAPAUID3DXBuffer@@@Z ; GXU::SetMesh
EXTRN	_D3DXCreateMeshFVF@24:NEAR
; Function compile flags: /Ogs
;	COMDAT ?SetMesh@GXU@@YAJAAPAUSLoadedFace@1@KAAPAUSLoadVertex@1@KPAUSCorner@1@KPAUSFVFData@1@HPAKKKPAUIDirect3DDevice9@@PAPAUID3DXMesh@@PAPAUID3DXBuffer@@@Z
_TEXT	SEGMENT
_rgdwTexCoordSizesOtherData$ = -304			; size = 32
_cfvfOtherData$ = -272					; size = 64
_cfvf$ = -208						; size = 64
$T57457 = -144						; size = 12
_v$57504 = -132						; size = 12
$T57456 = -120						; size = 12
tv2083 = -108						; size = 4
tv2087 = -104						; size = 4
$T57565 = -100						; size = 4
_vEdge1$56678 = -96					; size = 12
_vEdge2$56679 = -84					; size = 12
_iTexCoord$ = -72					; size = 4
_rgdwFaceRemap$ = -68					; size = 4
_rgdwPointRepsTemp$ = -64				; size = 4
_vNormal$ = -60						; size = 12
tv216 = -48						; size = 4
_iPoint$ = -48						; size = 4
_pvPoints$ = -44					; size = 4
_pvFaces$ = -40						; size = 4
_rgiAttribIds$ = -36					; size = 4
tv2080 = -32						; size = 4
tv435 = -32						; size = 4
_pvCurPoint$ = -28					; size = 4
_pbufAdjacency$ = -24					; size = 4
_cFacesActual$ = -20					; size = 4
_cVerticesMax$ = -20					; size = 4
tv2069 = -16						; size = 4
_iCorner$ = -16						; size = 4
tv2424 = -12						; size = 4
_pbTexCur$ = -12					; size = 4
_iFace$ = -12						; size = 4
_ptmMesh$ = -8						; size = 4
tv2038 = -4						; size = 4
_hr$ = -4						; size = 4
_rglfFaces$ = 8						; size = 4
_cFaces$ = 12						; size = 4
_rglvLoaded$ = 16					; size = 4
tv2402 = 20						; size = 4
_cVertices$ = 20					; size = 4
_rgCorners$ = 24					; size = 4
_cCorners$ = 28						; size = 4
tv757 = 32						; size = 4
_pdwAdjacency$ = 32					; size = 4
_pFVFData$ = 32						; size = 4
_bUsePointRepData$ = 36					; size = 4
_rgdwAdjacencyFile$ = 40				; size = 4
_dwOptions$ = 44					; size = 4
_dwFVF$ = 48						; size = 4
_pD3DDevice$ = 52					; size = 4
_ppMesh$ = 56						; size = 4
_ppbufAdjacency$ = 60					; size = 4
?SetMesh@GXU@@YAJAAPAUSLoadedFace@1@KAAPAUSLoadVertex@1@KPAUSCorner@1@KPAUSFVFData@1@HPAKKKPAUIDirect3DDevice9@@PAPAUID3DXMesh@@PAPAUID3DXBuffer@@@Z PROC NEAR ; GXU::SetMesh, COMDAT

; 955  : }

  00000	8b ff		 npad	 2

; 497  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H

; 498  :     HRESULT hr = S_OK;
; 499  :     PBYTE pvPoints = NULL;
; 500  :     D3DXVECTOR3 vNormal;
; 501  : 
; 502  :     DWORD iVertex;
; 503  :     D3DXVECTOR3 *pvNormal;
; 504  :     D3DXVECTOR2 *puvTex1;
; 505  :     DWORD iPoint;
; 506  :     DWORD iFace;
; 507  :     DWORD iCorner;
; 508  :     PBYTE pvCurPoint;
; 509  :     DWORD iWeight;
; 510  :     DWORD iTexCoord;
; 511  :     DWORD iInitialTexCoord;
; 512  :     PBYTE pbCur;
; 513  :     DWORD cFacesActual;
; 514  :     DWORD iFaceActual;
; 515  : 
; 516  :     ID3DXMesh *ptmMesh = NULL;
; 517  :     DWORD *rgdwFaces = NULL;
; 518  :     UINT16 *rgwFaces = NULL;
; 519  :     DWORD *rgiAttribIds = NULL;
; 520  :     DWORD *pdwFaceCur;
; 521  :     UINT16 *pwFaceCur;
; 522  :     PVOID pvFaces = NULL;
; 523  : 
; 524  :     DWORD cVerticesMax = cVertices;

  0000b	8b 45 14	 mov	 eax, DWORD PTR _cVertices$[ebp]
  0000e	56		 push	 esi

; 525  :     BOOL bSmoothingGroups;
; 526  : 
; 527  :     DWORD *rgdwPointRepsTemp = NULL;
; 528  :     LPD3DXBUFFER pbufAdjacency = NULL;
; 529  :     DWORD *pdwAdjacency;
; 530  :     DWORD rgdwTexCoordSizesOtherData[8];
; 531  :     PBYTE pbTexCur;
; 532  :     DWORD *rgdwFaceRemap = NULL;
; 533  : 
; 534  :     GXASSERT(ppMesh != NULL);
; 535  :     GXASSERT(rglfFaces != NULL);
; 536  :     GXASSERT(rglvLoaded != NULL);
; 537  :     // Corners are allowed to be NULL
; 538  :     DXCrackFVF  cfvf(dwFVF);                                

  0000f	ff 75 30	 push	 DWORD PTR _dwFVF$[ebp]
  00012	33 f6		 xor	 esi, esi
  00014	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _cfvf$[ebp]
  0001a	89 75 d4	 mov	 DWORD PTR _pvPoints$[ebp], esi
  0001d	89 75 f8	 mov	 DWORD PTR _ptmMesh$[ebp], esi
  00020	89 75 dc	 mov	 DWORD PTR _rgiAttribIds$[ebp], esi
  00023	89 75 d8	 mov	 DWORD PTR _pvFaces$[ebp], esi
  00026	89 45 ec	 mov	 DWORD PTR _cVerticesMax$[ebp], eax
  00029	89 75 c0	 mov	 DWORD PTR _rgdwPointRepsTemp$[ebp], esi
  0002c	89 75 e8	 mov	 DWORD PTR _pbufAdjacency$[ebp], esi
  0002f	89 75 bc	 mov	 DWORD PTR _rgdwFaceRemap$[ebp], esi
  00032	e8 00 00 00 00	 call	 ??0DXCrackFVF@@QAE@K@Z	; DXCrackFVF::DXCrackFVF

; 539  :     DXCrackFVF  cfvfOtherData(pFVFData != NULL ? pFVFData->dwFVF : D3DFVF_XYZ);                                

  00037	8b 45 20	 mov	 eax, DWORD PTR _pFVFData$[ebp]
  0003a	3b c6		 cmp	 eax, esi
  0003c	74 04		 je	 SHORT $L57454
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	eb 03		 jmp	 SHORT $L57455
$L57454:
  00042	6a 02		 push	 2
  00044	58		 pop	 eax
$L57455:
  00045	53		 push	 ebx
  00046	57		 push	 edi
  00047	50		 push	 eax
  00048	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _cfvfOtherData$[ebp]
  0004e	e8 00 00 00 00	 call	 ??0DXCrackFVF@@QAE@K@Z	; DXCrackFVF::DXCrackFVF

; 540  : 
; 541  :     cfvfOtherData.GetTexCoordSizes(rgdwTexCoordSizesOtherData);

  00053	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _rgdwTexCoordSizesOtherData$[ebp]
  00059	50		 push	 eax
  0005a	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _cfvfOtherData$[ebp]
  00060	e8 00 00 00 00	 call	 ?GetTexCoordSizes@DXCrackFVF@@QAEXPAK@Z ; DXCrackFVF::GetTexCoordSizes

; 542  : 
; 543  :     // handle smoothing groups
; 544  :     bSmoothingGroups = false;

  00065	33 c9		 xor	 ecx, ecx

; 545  :     for (iFace = 0; iFace < cFaces; iFace++)

  00067	39 75 0c	 cmp	 DWORD PTR _cFaces$[ebp], esi
  0006a	0f 86 d0 01 00
	00		 jbe	 $L56698
  00070	8b 45 08	 mov	 eax, DWORD PTR _rglfFaces$[ebp]
  00073	8b 00		 mov	 eax, DWORD PTR [eax]
  00075	8b 55 0c	 mov	 edx, DWORD PTR _cFaces$[ebp]
  00078	83 c0 0c	 add	 eax, 12			; 0000000cH
$L56669:

; 546  :     {
; 547  :         if (rglfFaces[iFace].m_bSmoothingGroupSpecified)

  0007b	f6 00 08	 test	 BYTE PTR [eax], 8
  0007e	74 03		 je	 SHORT $L56670

; 548  :         {
; 549  :             bSmoothingGroups = true;

  00080	33 c9		 xor	 ecx, ecx
  00082	41		 inc	 ecx
$L56670:
  00083	83 c0 2c	 add	 eax, 44			; 0000002cH
  00086	4a		 dec	 edx
  00087	75 f2		 jne	 SHORT $L56669

; 550  :         }
; 551  :     }
; 552  : 
; 553  :     // if there are smoothing groups, and the normals are there is a 
; 554  :     //   reason to compute smoothing groups, then compute them.
; 555  :     if (bSmoothingGroups && cfvf.BNormal())

  00089	85 c9		 test	 ecx, ecx
  0008b	0f 84 af 01 00
	00		 je	 $L56698
  00091	83 bd 38 ff ff
	ff 00		 cmp	 DWORD PTR _cfvf$[ebp+8], 0
  00098	0f 86 a2 01 00
	00		 jbe	 $L56698

; 556  :     {
; 557  :         SLoadedFace *plfFace;
; 558  :         SLoadVertex *plvPos0;
; 559  :         SLoadVertex *plvPos1;
; 560  :         SLoadVertex *plvPos2;
; 561  :         D3DXVECTOR3 vEdge1;
; 562  :         D3DXVECTOR3 vEdge2;
; 563  :         SLoadVertex *plvVert;
; 564  :         DWORD iVert;
; 565  : 
; 566  :         for (iFace = 0 ; iFace < cFaces; iFace++)

  0009e	33 db		 xor	 ebx, ebx
  000a0	89 5d f4	 mov	 DWORD PTR _iFace$[ebp], ebx
$L56682:

; 567  :         {
; 568  :             plfFace = &rglfFaces[iFace];

  000a3	8b 45 08	 mov	 eax, DWORD PTR _rglfFaces$[ebp]
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	03 d3		 add	 edx, ebx

; 569  :             if (plfFace->m_bSmoothingGroupSpecified)

  000aa	f6 42 0c 08	 test	 BYTE PTR [edx+12], 8
  000ae	0f 84 20 01 00
	00		 je	 $L56683

; 570  :             {
; 571  :                 plvPos0 = &rglvLoaded[plfFace->m_wIndices[0]];

  000b4	8b 45 10	 mov	 eax, DWORD PTR _rglvLoaded$[ebp]
  000b7	8b 30		 mov	 esi, DWORD PTR [eax]
  000b9	8b 02		 mov	 eax, DWORD PTR [edx]

; 572  :                 plvPos1 = &rglvLoaded[plfFace->m_wIndices[1]];

  000bb	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000be	6b c0 44	 imul	 eax, 68			; 00000044H

; 573  :                 plvPos2 = &rglvLoaded[plfFace->m_wIndices[2]];

  000c1	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  000c4	6b c9 44	 imul	 ecx, 68			; 00000044H
  000c7	03 c6		 add	 eax, esi
  000c9	6b d2 44	 imul	 edx, 68			; 00000044H

; 574  : 
; 575  :                 vEdge1 = plvPos0->m_vPos - plvPos1->m_vPos;

  000cc	d9 00		 fld	 DWORD PTR [eax]
  000ce	03 ce		 add	 ecx, esi
  000d0	03 d6		 add	 edx, esi
  000d2	8d 75 88	 lea	 esi, DWORD PTR $T57456[ebp]
  000d5	d8 21		 fsub	 DWORD PTR [ecx]
  000d7	8d 7d a0	 lea	 edi, DWORD PTR _vEdge1$56678[ebp]
  000da	d9 5d 88	 fstp	 DWORD PTR $T57456[ebp]
  000dd	d9 40 04	 fld	 DWORD PTR [eax+4]
  000e0	d8 61 04	 fsub	 DWORD PTR [ecx+4]
  000e3	d9 5d 8c	 fstp	 DWORD PTR $T57456[ebp+4]
  000e6	d9 40 08	 fld	 DWORD PTR [eax+8]
  000e9	d8 61 08	 fsub	 DWORD PTR [ecx+8]
  000ec	d9 5d 90	 fstp	 DWORD PTR $T57456[ebp+8]
  000ef	a5		 movsd

; 576  :                 vEdge2 = plvPos0->m_vPos - plvPos2->m_vPos;

  000f0	d9 00		 fld	 DWORD PTR [eax]
  000f2	d8 22		 fsub	 DWORD PTR [edx]
  000f4	a5		 movsd
  000f5	d9 9d 70 ff ff
	ff		 fstp	 DWORD PTR $T57457[ebp]
  000fb	d9 40 04	 fld	 DWORD PTR [eax+4]
  000fe	a5		 movsd
  000ff	d8 62 04	 fsub	 DWORD PTR [edx+4]
  00102	d9 9d 74 ff ff
	ff		 fstp	 DWORD PTR $T57457[ebp+4]
  00108	8d b5 70 ff ff
	ff		 lea	 esi, DWORD PTR $T57457[ebp]
  0010e	d9 40 08	 fld	 DWORD PTR [eax+8]
  00111	8d 7d ac	 lea	 edi, DWORD PTR _vEdge2$56679[ebp]
  00114	d8 62 08	 fsub	 DWORD PTR [edx+8]
  00117	d9 9d 78 ff ff
	ff		 fstp	 DWORD PTR $T57457[ebp+8]
  0011d	a5		 movsd
  0011e	a5		 movsd
  0011f	a5		 movsd

; 577  : 
; 578  :                 // calculate the normal of the face from the two edge vectors
; 579  :                 D3DXVec3Cross(&vNormal, &vEdge1, &vEdge2);

  00120	d9 45 b4	 fld	 DWORD PTR _vEdge2$56679[ebp+8]
  00123	d8 4d a4	 fmul	 DWORD PTR _vEdge1$56678[ebp+4]
  00126	d9 45 b0	 fld	 DWORD PTR _vEdge2$56679[ebp+4]
  00129	8d b5 7c ff ff
	ff		 lea	 esi, DWORD PTR _v$57504[ebp]
  0012f	d8 4d a8	 fmul	 DWORD PTR _vEdge1$56678[ebp+8]
  00132	8d 7d c4	 lea	 edi, DWORD PTR _vNormal$[ebp]
  00135	de e9		 fsubp	 ST(1), ST(0)
  00137	d9 9d 7c ff ff
	ff		 fstp	 DWORD PTR _v$57504[ebp]
  0013d	d9 45 a8	 fld	 DWORD PTR _vEdge1$56678[ebp+8]
  00140	d8 4d ac	 fmul	 DWORD PTR _vEdge2$56679[ebp]
  00143	d9 45 b4	 fld	 DWORD PTR _vEdge2$56679[ebp+8]
  00146	d8 4d a0	 fmul	 DWORD PTR _vEdge1$56678[ebp]
  00149	de e9		 fsubp	 ST(1), ST(0)
  0014b	d9 5d 80	 fstp	 DWORD PTR _v$57504[ebp+4]
  0014e	d9 45 b0	 fld	 DWORD PTR _vEdge2$56679[ebp+4]
  00151	d8 4d a0	 fmul	 DWORD PTR _vEdge1$56678[ebp]
  00154	d9 45 a4	 fld	 DWORD PTR _vEdge1$56678[ebp+4]
  00157	d8 4d ac	 fmul	 DWORD PTR _vEdge2$56679[ebp]
  0015a	de e9		 fsubp	 ST(1), ST(0)
  0015c	d9 5d 84	 fstp	 DWORD PTR _v$57504[ebp+8]
  0015f	a5		 movsd
  00160	a5		 movsd
  00161	a5		 movsd

; 580  :                 vNormal /= D3DXVec3Length(&vNormal);

  00162	d9 45 c4	 fld	 DWORD PTR _vNormal$[ebp]
  00165	d8 4d c4	 fmul	 DWORD PTR _vNormal$[ebp]
  00168	d9 45 cc	 fld	 DWORD PTR _vNormal$[ebp+8]
  0016b	d8 4d cc	 fmul	 DWORD PTR _vNormal$[ebp+8]

; 953  : 
; 954  :     return hr;

  0016e	de c1		 faddp	 ST(1), ST(0)
  00170	d9 45 c8	 fld	 DWORD PTR _vNormal$[ebp+4]
  00173	d8 4d c8	 fmul	 DWORD PTR _vNormal$[ebp+4]
  00176	de c1		 faddp	 ST(1), ST(0)
  00178	d9 fa		 fsqrt
  0017a	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@3f800000
  00180	d9 45 c4	 fld	 DWORD PTR _vNormal$[ebp]
  00183	d8 c9		 fmul	 ST(0), ST(1)
  00185	d9 5d c4	 fstp	 DWORD PTR _vNormal$[ebp]
  00188	d9 45 c8	 fld	 DWORD PTR _vNormal$[ebp+4]
  0018b	d8 c9		 fmul	 ST(0), ST(1)
  0018d	d9 5d c8	 fstp	 DWORD PTR _vNormal$[ebp+4]
  00190	d9 45 cc	 fld	 DWORD PTR _vNormal$[ebp+8]
  00193	33 f6		 xor	 esi, esi
  00195	d8 c9		 fmul	 ST(0), ST(1)
  00197	d9 5d cc	 fstp	 DWORD PTR _vNormal$[ebp+8]
  0019a	dd d8		 fstp	 ST(0)
$L56688:
  0019c	8b 45 08	 mov	 eax, DWORD PTR _rglfFaces$[ebp]
  0019f	8b 00		 mov	 eax, DWORD PTR [eax]
  001a1	8d 4d ec	 lea	 ecx, DWORD PTR _cVerticesMax$[ebp]
  001a4	51		 push	 ecx
  001a5	8d 4d 14	 lea	 ecx, DWORD PTR _cVertices$[ebp]
  001a8	51		 push	 ecx
  001a9	ff 75 10	 push	 DWORD PTR _rglvLoaded$[ebp]
  001ac	8d 4d c4	 lea	 ecx, DWORD PTR _vNormal$[ebp]
  001af	51		 push	 ecx
  001b0	03 c3		 add	 eax, ebx
  001b2	33 c9		 xor	 ecx, ecx
  001b4	66 8b 48 28	 mov	 cx, WORD PTR [eax+40]
  001b8	51		 push	 ecx
  001b9	56		 push	 esi
  001ba	50		 push	 eax
  001bb	e8 00 00 00 00	 call	 ?SetSmoothingGroup@GXU@@YAJPAUSLoadedFace@1@KGAAUD3DXVECTOR3@@PAPAUSLoadVertex@1@PAK3@Z ; GXU::SetSmoothingGroup
  001c0	83 c4 1c	 add	 esp, 28			; 0000001cH
  001c3	85 c0		 test	 eax, eax
  001c5	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  001c8	0f 8c 75 06 00
	00		 jl	 $e_Exit$56693
  001ce	46		 inc	 esi
  001cf	83 fe 03	 cmp	 esi, 3
  001d2	72 c8		 jb	 SHORT $L56688
$L56683:

; 556  :     {
; 557  :         SLoadedFace *plfFace;
; 558  :         SLoadVertex *plvPos0;
; 559  :         SLoadVertex *plvPos1;
; 560  :         SLoadVertex *plvPos2;
; 561  :         D3DXVECTOR3 vEdge1;
; 562  :         D3DXVECTOR3 vEdge2;
; 563  :         SLoadVertex *plvVert;
; 564  :         DWORD iVert;
; 565  : 
; 566  :         for (iFace = 0 ; iFace < cFaces; iFace++)

  001d4	ff 45 f4	 inc	 DWORD PTR _iFace$[ebp]
  001d7	8b 45 f4	 mov	 eax, DWORD PTR _iFace$[ebp]
  001da	83 c3 2c	 add	 ebx, 44			; 0000002cH
  001dd	3b 45 0c	 cmp	 eax, DWORD PTR _cFaces$[ebp]
  001e0	0f 82 bd fe ff
	ff		 jb	 $L56682

; 581  :                 //vNormal *= -1;
; 582  : 
; 583  :                 for (iPoint = 0; iPoint < 3; iPoint++)
; 584  :                 {
; 585  :                     hr = SetSmoothingGroup(&rglfFaces[iFace], iPoint, rglfFaces[iFace].m_iSmoothingGroup, vNormal, &rglvLoaded, &cVertices, &cVerticesMax);
; 586  :                     if (FAILED(hr))
; 587  :                         goto e_Exit;
; 588  :                 }
; 589  :             }
; 590  :         }
; 591  : 
; 592  :         DWORD iTest;
; 593  :         iTest = 0;
; 594  :         // average and renormalize vertices shared among faces of the same smoothing group
; 595  :         for (iVert = 0; iVert < cVertices; iVert++)

  001e6	8b 55 14	 mov	 edx, DWORD PTR _cVertices$[ebp]
  001e9	85 d2		 test	 edx, edx
  001eb	76 53		 jbe	 SHORT $L56698
  001ed	33 c9		 xor	 ecx, ecx
$L56696:

; 596  :         {
; 597  :             plvVert = &rglvLoaded[iVert];

  001ef	8b 45 10	 mov	 eax, DWORD PTR _rglvLoaded$[ebp]
  001f2	8b 00		 mov	 eax, DWORD PTR [eax]
  001f4	03 c1		 add	 eax, ecx

; 598  : 
; 599  :             if (plvVert->m_cSmoothingGroupFaces > 1)

  001f6	66 83 78 3c 01	 cmp	 WORD PTR [eax+60], 1
  001fb	76 3d		 jbe	 SHORT $L56697

; 600  :             {
; 601  :                 /*plvVert->m_vNormal /= plvVert->m_cSmoothingGroupFaces*/;
; 602  :                 plvVert->m_vNormal /= D3DXVec3Length(&plvVert->m_vNormal);

  001fd	d9 40 2c	 fld	 DWORD PTR [eax+44]
  00200	d9 40 28	 fld	 DWORD PTR [eax+40]
  00203	d9 40 24	 fld	 DWORD PTR [eax+36]
  00206	d9 c0		 fld	 ST(0)
  00208	d8 c9		 fmul	 ST(0), ST(1)
  0020a	d9 c2		 fld	 ST(2)
  0020c	d8 cb		 fmul	 ST(0), ST(3)

; 953  : 
; 954  :     return hr;

  0020e	de c1		 faddp	 ST(1), ST(0)
  00210	d9 c3		 fld	 ST(3)
  00212	d8 cc		 fmul	 ST(0), ST(4)
  00214	de c1		 faddp	 ST(1), ST(0)
  00216	d9 fa		 fsqrt
  00218	dd db		 fstp	 ST(3)
  0021a	dd d8		 fstp	 ST(0)
  0021c	dd d8		 fstp	 ST(0)
  0021e	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@3f800000
  00224	d9 c0		 fld	 ST(0)
  00226	d8 48 24	 fmul	 DWORD PTR [eax+36]
  00229	d9 58 24	 fstp	 DWORD PTR [eax+36]
  0022c	d9 c0		 fld	 ST(0)
  0022e	d8 48 28	 fmul	 DWORD PTR [eax+40]
  00231	d9 58 28	 fstp	 DWORD PTR [eax+40]
  00234	d8 48 2c	 fmul	 DWORD PTR [eax+44]
  00237	d9 58 2c	 fstp	 DWORD PTR [eax+44]
$L56697:
  0023a	83 c1 44	 add	 ecx, 68			; 00000044H
  0023d	4a		 dec	 edx
  0023e	75 af		 jne	 SHORT $L56696
$L56698:

; 603  :             }
; 604  : 
; 605  :             if (plvVert->m_iSmoothingGroup == 0)
; 606  :             {
; 607  :                 iTest += 1;
; 608  :             }
; 609  :         }
; 610  : 
; 611  :     }
; 612  : 
; 613  :     if (cfvf.BDiffuse())

  00240	33 f6		 xor	 esi, esi
  00242	39 b5 40 ff ff
	ff		 cmp	 DWORD PTR _cfvf$[ebp+16], esi
  00248	76 4f		 jbe	 SHORT $L57645

; 614  :     {
; 615  :         // propagate face color attributes into vertex attributes
; 616  :         for (iFace = 0; iFace < cFaces; iFace++)

  0024a	33 db		 xor	 ebx, ebx
  0024c	39 75 0c	 cmp	 DWORD PTR _cFaces$[ebp], esi
  0024f	76 48		 jbe	 SHORT $L57645
$L57651:

; 617  :         {
; 618  :             if (rglfFaces[iFace].m_bColorSpecified)

  00251	8b 45 08	 mov	 eax, DWORD PTR _rglfFaces$[ebp]
  00254	8b 00		 mov	 eax, DWORD PTR [eax]
  00256	f6 44 06 0c 01	 test	 BYTE PTR [esi+eax+12], 1
  0025b	74 33		 je	 SHORT $L56703

; 619  :             {
; 620  :                 for (iPoint = 0; iPoint < 3; iPoint++)

  0025d	33 ff		 xor	 edi, edi
$L57644:

; 621  :                 {
; 622  :                     hr = SetVertexColor(&rglfFaces[iFace], iPoint, rglfFaces[iFace].m_colorFace, &rglvLoaded, &cVertices, &cVerticesMax);

  0025f	8b 45 08	 mov	 eax, DWORD PTR _rglfFaces$[ebp]
  00262	8b 00		 mov	 eax, DWORD PTR [eax]
  00264	8d 4d ec	 lea	 ecx, DWORD PTR _cVerticesMax$[ebp]
  00267	51		 push	 ecx
  00268	8d 4d 14	 lea	 ecx, DWORD PTR _cVertices$[ebp]
  0026b	51		 push	 ecx
  0026c	ff 75 10	 push	 DWORD PTR _rglvLoaded$[ebp]
  0026f	03 c6		 add	 eax, esi
  00271	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  00274	51		 push	 ecx
  00275	57		 push	 edi
  00276	50		 push	 eax
  00277	e8 00 00 00 00	 call	 ?SetVertexColor@GXU@@YAJPAUSLoadedFace@1@KAAUD3DXCOLOR@@PAPAUSLoadVertex@1@PAK3@Z ; GXU::SetVertexColor
  0027c	83 c4 18	 add	 esp, 24			; 00000018H

; 623  :                     if (FAILED(hr))

  0027f	85 c0		 test	 eax, eax
  00281	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00284	0f 8c b9 05 00
	00		 jl	 $e_Exit$56693
  0028a	47		 inc	 edi
  0028b	83 ff 03	 cmp	 edi, 3
  0028e	72 cf		 jb	 SHORT $L57644
$L56703:

; 614  :     {
; 615  :         // propagate face color attributes into vertex attributes
; 616  :         for (iFace = 0; iFace < cFaces; iFace++)

  00290	43		 inc	 ebx
  00291	83 c6 2c	 add	 esi, 44			; 0000002cH
  00294	3b 5d 0c	 cmp	 ebx, DWORD PTR _cFaces$[ebp]
  00297	72 b8		 jb	 SHORT $L57651
$L57645:

; 624  :                         goto e_Exit;
; 625  :                 }
; 626  :             }
; 627  : 
; 628  :         }
; 629  :     }
; 630  : 
; 631  :     // after dealing face attributes, reset owned flags to false, and reprocess
; 632  :     // the 
; 633  :     for (iVertex = 0; iVertex < cVertices; iVertex++)

  00299	8b 4d 14	 mov	 ecx, DWORD PTR _cVertices$[ebp]
  0029c	85 c9		 test	 ecx, ecx
  0029e	76 12		 jbe	 SHORT $L56714
  002a0	33 c0		 xor	 eax, eax
$L56712:

; 634  :     {
; 635  :         rglvLoaded[iVertex].m_bOwned = false;

  002a2	8b 55 10	 mov	 edx, DWORD PTR _rglvLoaded$[ebp]
  002a5	8b 12		 mov	 edx, DWORD PTR [edx]
  002a7	c6 44 10 38 00	 mov	 BYTE PTR [eax+edx+56], 0
  002ac	83 c0 44	 add	 eax, 68			; 00000044H
  002af	49		 dec	 ecx
  002b0	75 f0		 jne	 SHORT $L56712
$L56714:

; 636  :     }
; 637  : 
; 638  :     // propogate corner attributes into vertex attributes
; 639  :     for (iCorner = 0; iCorner < cCorners; iCorner++)

  002b2	83 65 f0 00	 and	 DWORD PTR _iCorner$[ebp], 0
  002b6	83 7d 1c 00	 cmp	 DWORD PTR _cCorners$[ebp], 0
  002ba	0f 86 9f 00 00
	00		 jbe	 $L57653
  002c0	8b 75 18	 mov	 esi, DWORD PTR _rgCorners$[ebp]
  002c3	83 c6 08	 add	 esi, 8
$L57647:

; 640  :     {
; 641  :         if (rgCorners[iCorner].m_bNormalSpecified || rgCorners[iCorner].m_bUvSpecified)

  002c6	33 c0		 xor	 eax, eax
  002c8	66 8b 06	 mov	 ax, WORD PTR [esi]
  002cb	89 45 f4	 mov	 DWORD PTR tv2424[ebp], eax
  002ce	83 65 f4 01	 and	 DWORD PTR tv2424[ebp], 1
  002d2	75 04		 jne	 SHORT $L56719
  002d4	a8 02		 test	 al, 2
  002d6	74 75		 je	 SHORT $L56716
$L56719:

; 642  :         {
; 643  :             iFace = rgCorners[iCorner].m_wFace;

  002d8	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]

; 644  : 			if ((iFace >= cFaces) || (rglfFaces[iFace].m_wIndices[0] == UNUSED32))

  002db	3b 45 0c	 cmp	 eax, DWORD PTR _cFaces$[ebp]
  002de	73 6d		 jae	 SHORT $L56716
  002e0	8b 4d 08	 mov	 ecx, DWORD PTR _rglfFaces$[ebp]
  002e3	6b c0 2c	 imul	 eax, 44			; 0000002cH
  002e6	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002e8	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  002eb	83 3f ff	 cmp	 DWORD PTR [edi], -1
  002ee	74 5d		 je	 SHORT $L56716

; 645  : 				continue;
; 646  : 
; 647  :             iPoint = FindPoint(rglfFaces[iFace].m_wIndices, rgCorners[iCorner].m_wPoint, rglvLoaded);

  002f0	8b 5d 10	 mov	 ebx, DWORD PTR _rglvLoaded$[ebp]
  002f3	ff 33		 push	 DWORD PTR [ebx]
  002f5	ff 76 f8	 push	 DWORD PTR [esi-8]
  002f8	57		 push	 edi
  002f9	e8 00 00 00 00	 call	 ?FindPoint@GXU@@YAKPAKKPAUSLoadVertex@1@@Z ; GXU::FindPoint

; 648  : 
; 649  :             GXASSERT(iPoint < 3);
; 650  : 
; 651  :             pvNormal = NULL;

  002fe	33 d2		 xor	 edx, edx
  00300	83 c4 0c	 add	 esp, 12			; 0000000cH

; 652  :             if (rgCorners[iCorner].m_bNormalSpecified && cfvf.BNormal())

  00303	66 39 55 f4	 cmp	 WORD PTR tv2424[ebp], dx
  00307	89 45 d0	 mov	 DWORD PTR _iPoint$[ebp], eax
  0030a	74 0d		 je	 SHORT $L57648
  0030c	39 95 38 ff ff
	ff		 cmp	 DWORD PTR _cfvf$[ebp+8], edx
  00312	76 05		 jbe	 SHORT $L57648

; 653  :             {
; 654  :                 pvNormal = &rgCorners[iCorner].m_vNormal;

  00314	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00317	8b d1		 mov	 edx, ecx
$L57648:

; 655  :             }
; 656  :             
; 657  :             puvTex1 = NULL;

  00319	33 c9		 xor	 ecx, ecx

; 658  :             if (rgCorners[iCorner].m_bUvSpecified && cfvf.BTex1())

  0031b	f6 06 02	 test	 BYTE PTR [esi], 2
  0031e	74 0b		 je	 SHORT $L56724
  00320	39 8d 48 ff ff
	ff		 cmp	 DWORD PTR _cfvf$[ebp+24], ecx
  00326	76 03		 jbe	 SHORT $L56724

; 659  :             {
; 660  :                 puvTex1 = &rgCorners[iCorner].m_uvTex1;

  00328	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
$L56724:

; 661  :             }
; 662  : 
; 663  :             hr = SetVertexAttributes(&rglfFaces[iFace], iPoint, pvNormal, puvTex1, &rglvLoaded, &cVertices, &cVerticesMax);

  0032b	8d 45 ec	 lea	 eax, DWORD PTR _cVerticesMax$[ebp]
  0032e	50		 push	 eax
  0032f	8d 45 14	 lea	 eax, DWORD PTR _cVertices$[ebp]
  00332	50		 push	 eax
  00333	53		 push	 ebx
  00334	51		 push	 ecx
  00335	52		 push	 edx
  00336	ff 75 d0	 push	 DWORD PTR _iPoint$[ebp]
  00339	57		 push	 edi
  0033a	e8 00 00 00 00	 call	 ?SetVertexAttributes@GXU@@YAJPAUSLoadedFace@1@KPAUD3DXVECTOR3@@PAUD3DXVECTOR2@@PAPAUSLoadVertex@1@PAK4@Z ; GXU::SetVertexAttributes
  0033f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 664  :             if (FAILED(hr))

  00342	85 c0		 test	 eax, eax
  00344	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00347	0f 8c f6 04 00
	00		 jl	 $e_Exit$56693
$L56716:

; 636  :     }
; 637  : 
; 638  :     // propogate corner attributes into vertex attributes
; 639  :     for (iCorner = 0; iCorner < cCorners; iCorner++)

  0034d	ff 45 f0	 inc	 DWORD PTR _iCorner$[ebp]
  00350	8b 45 f0	 mov	 eax, DWORD PTR _iCorner$[ebp]
  00353	83 c6 20	 add	 esi, 32			; 00000020H
  00356	3b 45 1c	 cmp	 eax, DWORD PTR _cCorners$[ebp]
  00359	0f 82 67 ff ff
	ff		 jb	 $L57647
$L57653:

; 665  :                 goto e_Exit;
; 666  :         }
; 667  :     }
; 668  : 
; 669  : 
; 670  :     if ((cFaces >= UNUSED16) || (cVertices >= UNUSED16))

  0035f	8b 55 0c	 mov	 edx, DWORD PTR _cFaces$[ebp]
  00362	8b 5d 08	 mov	 ebx, DWORD PTR _rglfFaces$[ebp]
  00365	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0036a	3b d0		 cmp	 edx, eax
  0036c	73 05		 jae	 SHORT $L56729
  0036e	39 45 14	 cmp	 DWORD PTR _cVertices$[ebp], eax
  00371	72 04		 jb	 SHORT $L57639
$L56729:

; 671  :     {
; 672  :         dwOptions |= D3DXMESH_32BIT;

  00373	83 4d 2c 01	 or	 DWORD PTR _dwOptions$[ebp], 1
$L57639:

; 673  :     }
; 674  : 
; 675  :     // need to remove degenerate triangles
; 676  :     cFacesActual = 0;

  00377	33 c9		 xor	 ecx, ecx

; 677  :     for (iFace = 0; iFace < cFaces; iFace++)

  00379	3b d1		 cmp	 edx, ecx
  0037b	89 4d ec	 mov	 DWORD PTR _cFacesActual$[ebp], ecx
  0037e	0f 86 b8 04 00
	00		 jbe	 $L56737

; 673  :     }
; 674  : 
; 675  :     // need to remove degenerate triangles
; 676  :     cFacesActual = 0;

  00384	89 55 e0	 mov	 DWORD PTR tv435[ebp], edx
$L56730:

; 678  :     {
; 679  :         if ((rglfFaces[iFace].m_wIndices[0] == rglfFaces[iFace].m_wIndices[1])
; 680  :             || (rglfFaces[iFace].m_wIndices[0] == rglfFaces[iFace].m_wIndices[2])
; 681  :             || (rglfFaces[iFace].m_wIndices[1] == rglfFaces[iFace].m_wIndices[2]))

  00387	8b 03		 mov	 eax, DWORD PTR [ebx]
  00389	03 c1		 add	 eax, ecx
  0038b	8b 10		 mov	 edx, DWORD PTR [eax]
  0038d	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00390	3b d6		 cmp	 edx, esi
  00392	74 10		 je	 SHORT $L56734
  00394	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00397	3b d7		 cmp	 edx, edi
  00399	74 09		 je	 SHORT $L56734
  0039b	3b f7		 cmp	 esi, edi
  0039d	74 05		 je	 SHORT $L56734

; 686  :         }
; 687  :         else
; 688  :         {
; 689  :             cFacesActual += 1;

  0039f	ff 45 ec	 inc	 DWORD PTR _cFacesActual$[ebp]
  003a2	eb 11		 jmp	 SHORT $L56731
$L56734:

; 682  :         {
; 683  :             rglfFaces[iFace].m_wIndices[0] = UNUSED32;

  003a4	83 08 ff	 or	 DWORD PTR [eax], -1

; 684  :             rglfFaces[iFace].m_wIndices[1] = UNUSED32;

  003a7	8b 03		 mov	 eax, DWORD PTR [ebx]
  003a9	83 4c 01 04 ff	 or	 DWORD PTR [ecx+eax+4], -1

; 685  :             rglfFaces[iFace].m_wIndices[2] = UNUSED32;

  003ae	8b 03		 mov	 eax, DWORD PTR [ebx]
  003b0	83 4c 01 08 ff	 or	 DWORD PTR [ecx+eax+8], -1
$L56731:
  003b5	83 c1 2c	 add	 ecx, 44			; 0000002cH
  003b8	ff 4d e0	 dec	 DWORD PTR tv435[ebp]
  003bb	75 ca		 jne	 SHORT $L56730

; 690  :         }
; 691  :     }
; 692  : 
; 693  :     if ((cFacesActual == 0) || (cVertices == 0))

  003bd	83 7d ec 00	 cmp	 DWORD PTR _cFacesActual$[ebp], 0
  003c1	0f 84 75 04 00
	00		 je	 $L56737
  003c7	83 7d 14 00	 cmp	 DWORD PTR _cVertices$[ebp], 0
  003cb	0f 84 6b 04 00
	00		 je	 $L56737

; 696  :         goto e_Exit;
; 697  :     }
; 698  : 
; 699  :     // create the mesh now that we know the correct size
; 700  :     hr = D3DXCreateMeshFVF(cFacesActual, cVertices, dwOptions, dwFVF, pD3DDevice, &ptmMesh);

  003d1	8d 45 f8	 lea	 eax, DWORD PTR _ptmMesh$[ebp]
  003d4	50		 push	 eax
  003d5	ff 75 34	 push	 DWORD PTR _pD3DDevice$[ebp]
  003d8	ff 75 30	 push	 DWORD PTR _dwFVF$[ebp]
  003db	ff 75 2c	 push	 DWORD PTR _dwOptions$[ebp]
  003de	ff 75 14	 push	 DWORD PTR _cVertices$[ebp]
  003e1	ff 75 ec	 push	 DWORD PTR _cFacesActual$[ebp]
  003e4	e8 00 00 00 00	 call	 _D3DXCreateMeshFVF@24

; 701  :     if (FAILED(hr))

  003e9	85 c0		 test	 eax, eax
  003eb	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  003ee	0f 8c 4f 04 00
	00		 jl	 $e_Exit$56693

; 702  :         goto e_Exit;
; 703  : 
; 704  :     // get the vertex buffer, fill the vertices in place
; 705  :     hr = ptmMesh->LockVertexBuffer(0, (PVOID*)&pvPoints);

  003f4	8b 45 f8	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  003f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f9	8d 55 d4	 lea	 edx, DWORD PTR _pvPoints$[ebp]
  003fc	52		 push	 edx
  003fd	6a 00		 push	 0
  003ff	50		 push	 eax
  00400	ff 51 3c	 call	 DWORD PTR [ecx+60]

; 706  :     if (FAILED(hr))

  00403	85 c0		 test	 eax, eax
  00405	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00408	0f 8c 35 04 00
	00		 jl	 $e_Exit$56693

; 707  :         goto e_Exit;
; 708  : 
; 709  :     // transform the points into the proper FVF format
; 710  :     for (iPoint=0, pvCurPoint = pvPoints; iPoint < cVertices; iPoint++, pvCurPoint+=cfvf.m_cBytesPerVertex)

  0040e	83 7d 14 00	 cmp	 DWORD PTR _cVertices$[ebp], 0
  00412	8b 45 d4	 mov	 eax, DWORD PTR _pvPoints$[ebp]
  00415	89 45 e4	 mov	 DWORD PTR _pvCurPoint$[ebp], eax
  00418	0f 86 cc 01 00
	00		 jbe	 $L57650
  0041e	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _cfvf$[ebp+16]
  00424	83 65 fc 00	 and	 DWORD PTR tv2038[ebp], 0
  00428	03 c1		 add	 eax, ecx
  0042a	89 45 f0	 mov	 DWORD PTR tv2069[ebp], eax
  0042d	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cfvf$[ebp+20]
  00433	2b c1		 sub	 eax, ecx
  00435	89 45 94	 mov	 DWORD PTR tv2083[ebp], eax
  00438	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _cfvf$[ebp+24]
  0043e	c7 45 e0 0c 00
	00 00		 mov	 DWORD PTR tv2080[ebp], 12 ; 0000000cH
  00445	29 4d e0	 sub	 DWORD PTR tv2080[ebp], ecx
  00448	2b c1		 sub	 eax, ecx
  0044a	89 45 98	 mov	 DWORD PTR tv2087[ebp], eax
  0044d	8b 45 14	 mov	 eax, DWORD PTR _cVertices$[ebp]
  00450	89 45 d0	 mov	 DWORD PTR tv216[ebp], eax
$L56746:

; 711  :     {
; 712  :         cfvf.SetPosition(pvCurPoint, &rglvLoaded[iPoint].m_vPos);

  00453	8b 5d 10	 mov	 ebx, DWORD PTR _rglvLoaded$[ebp]
  00456	8b 33		 mov	 esi, DWORD PTR [ebx]
  00458	8b 45 fc	 mov	 eax, DWORD PTR tv2038[ebp]
  0045b	8b 7d e4	 mov	 edi, DWORD PTR _pvCurPoint$[ebp]
  0045e	03 f0		 add	 esi, eax
  00460	a5		 movsd
  00461	a5		 movsd
  00462	a5		 movsd

; 713  : 
; 714  :         cfvf.SetNormal(pvCurPoint, &rglvLoaded[iPoint].m_vNormal);

  00463	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00465	8d 44 08 24	 lea	 eax, DWORD PTR [eax+ecx+36]
  00469	50		 push	 eax
  0046a	ff 75 e4	 push	 DWORD PTR _pvCurPoint$[ebp]
  0046d	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _cfvf$[ebp]
  00473	e8 00 00 00 00	 call	 ?SetNormal@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetNormal

; 715  :         cfvf.SetDiffuse(pvCurPoint, ConvertColor(rglvLoaded[iPoint].m_color));

  00478	83 bd 40 ff ff
	ff 00		 cmp	 DWORD PTR _cfvf$[ebp+16], 0
  0047f	74 15		 je	 SHORT $L57643
  00481	8b 4d fc	 mov	 ecx, DWORD PTR tv2038[ebp]
  00484	8b 03		 mov	 eax, DWORD PTR [ebx]
  00486	8d 44 01 0c	 lea	 eax, DWORD PTR [ecx+eax+12]
  0048a	50		 push	 eax
  0048b	e8 00 00 00 00	 call	 ?ConvertColor@GXU@@YAKAAUD3DXCOLOR@@@Z ; GXU::ConvertColor
  00490	59		 pop	 ecx
  00491	8b 4d f0	 mov	 ecx, DWORD PTR tv2069[ebp]
  00494	89 01		 mov	 DWORD PTR [ecx], eax
$L57643:

; 716  :         cfvf.SetTex1(pvCurPoint, &rglvLoaded[iPoint].m_uvTex1);

  00496	8b 03		 mov	 eax, DWORD PTR [ebx]
  00498	8b 4d fc	 mov	 ecx, DWORD PTR tv2038[ebp]
  0049b	8d 44 01 1c	 lea	 eax, DWORD PTR [ecx+eax+28]
  0049f	50		 push	 eax
  004a0	ff 75 e4	 push	 DWORD PTR _pvCurPoint$[ebp]
  004a3	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _cfvf$[ebp]
  004a9	e8 00 00 00 00	 call	 ?SetTex1@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR2@@@Z ; DXCrackFVF::SetTex1

; 717  : 
; 718  :         if (pFVFData != NULL)

  004ae	83 7d 20 00	 cmp	 DWORD PTR _pFVFData$[ebp], 0
  004b2	0f 84 19 01 00
	00		 je	 $L56747

; 719  :         {
; 720  :             pbCur = (PBYTE)&pFVFData->rgiFVFData[pFVFData->cBytesPerVertex/sizeof(DWORD) * rglvLoaded[iPoint].m_iFVFDataOffset];

  004b8	8b 45 20	 mov	 eax, DWORD PTR _pFVFData$[ebp]
  004bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004be	8b 55 10	 mov	 edx, DWORD PTR _rglvLoaded$[ebp]
  004c1	8b 12		 mov	 edx, DWORD PTR [edx]
  004c3	8b 75 fc	 mov	 esi, DWORD PTR tv2038[ebp]
  004c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  004c9	c1 e9 02	 shr	 ecx, 2
  004cc	0f af 4c 16 40	 imul	 ecx, DWORD PTR [esi+edx+64]

; 721  : 
; 722  :             if (cfvfOtherData.CWeights() > 0)

  004d1	33 ff		 xor	 edi, edi
  004d3	39 bd 28 ff ff
	ff		 cmp	 DWORD PTR _cfvfOtherData$[ebp+56], edi
  004d9	8d 1c 88	 lea	 ebx, DWORD PTR [eax+ecx*4]
  004dc	76 32		 jbe	 SHORT $L57641

; 723  :             {
; 724  :                 for (iWeight = 0; iWeight < cfvfOtherData.CWeights(); iWeight++)

  004de	33 c9		 xor	 ecx, ecx
  004e0	39 bd 28 ff ff
	ff		 cmp	 DWORD PTR _cfvfOtherData$[ebp+56], edi
  004e6	76 28		 jbe	 SHORT $L57641
  004e8	8b 45 e0	 mov	 eax, DWORD PTR tv2080[ebp]
  004eb	8b 75 f0	 mov	 esi, DWORD PTR tv2069[ebp]
  004ee	03 c6		 add	 eax, esi
$L56753:

; 725  :                 {
; 726  :                     cfvf.SetWeight(pvCurPoint, iWeight, *(float*)pbCur);

  004f0	3b 8d 68 ff ff
	ff		 cmp	 ecx, DWORD PTR _cfvf$[ebp+56]
  004f6	8b 13		 mov	 edx, DWORD PTR [ebx]
  004f8	89 55 9c	 mov	 DWORD PTR $T57565[ebp], edx
  004fb	73 02		 jae	 SHORT $L57564
  004fd	89 10		 mov	 DWORD PTR [eax], edx
$L57564:

; 727  :                     pbCur += sizeof(float);

  004ff	83 c3 04	 add	 ebx, 4
  00502	41		 inc	 ecx
  00503	83 c0 04	 add	 eax, 4
  00506	3b 8d 28 ff ff
	ff		 cmp	 ecx, DWORD PTR _cfvfOtherData$[ebp+56]
  0050c	72 e2		 jb	 SHORT $L56753

; 723  :             {
; 724  :                 for (iWeight = 0; iWeight < cfvfOtherData.CWeights(); iWeight++)

  0050e	eb 03		 jmp	 SHORT $L56755
$L57641:
  00510	8b 75 f0	 mov	 esi, DWORD PTR tv2069[ebp]
$L56755:

; 728  :                 }
; 729  :             }
; 730  : 
; 731  :             if (cfvfOtherData.BNormal())

  00513	39 bd f8 fe ff
	ff		 cmp	 DWORD PTR _cfvfOtherData$[ebp+8], edi
  00519	76 12		 jbe	 SHORT $L56758

; 732  :             {
; 733  :                 cfvf.SetNormal(pvCurPoint, (D3DXVECTOR3*)pbCur);

  0051b	53		 push	 ebx
  0051c	ff 75 e4	 push	 DWORD PTR _pvCurPoint$[ebp]
  0051f	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _cfvf$[ebp]
  00525	e8 00 00 00 00	 call	 ?SetNormal@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetNormal

; 734  :                 pbCur += sizeof(D3DXVECTOR3);

  0052a	83 c3 0c	 add	 ebx, 12			; 0000000cH
$L56758:

; 735  :             }
; 736  : 
; 737  :             if (cfvfOtherData.BDiffuse())

  0052d	39 bd 00 ff ff
	ff		 cmp	 DWORD PTR _cfvfOtherData$[ebp+16], edi
  00533	76 0f		 jbe	 SHORT $L57654

; 738  :             {
; 739  :                 cfvf.SetDiffuse(pvCurPoint, *(D3DCOLOR*)pbCur);

  00535	39 bd 40 ff ff
	ff		 cmp	 DWORD PTR _cfvf$[ebp+16], edi
  0053b	74 04		 je	 SHORT $L57575
  0053d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0053f	89 06		 mov	 DWORD PTR [esi], eax
$L57575:

; 740  :                 pbCur += sizeof(D3DCOLOR);

  00541	83 c3 04	 add	 ebx, 4
$L57654:

; 741  :             }
; 742  : 
; 743  :             if (cfvfOtherData.BSpecular())

  00544	39 bd 04 ff ff
	ff		 cmp	 DWORD PTR _cfvfOtherData$[ebp+20], edi
  0054a	76 13		 jbe	 SHORT $L56764

; 744  :             {
; 745  :                 cfvf.SetSpecular(pvCurPoint, *(D3DCOLOR*)pbCur);

  0054c	39 bd 44 ff ff
	ff		 cmp	 DWORD PTR _cfvf$[ebp+20], edi
  00552	74 08		 je	 SHORT $L57583
  00554	8b 03		 mov	 eax, DWORD PTR [ebx]
  00556	8b 4d 94	 mov	 ecx, DWORD PTR tv2083[ebp]
  00559	89 04 31	 mov	 DWORD PTR [ecx+esi], eax
$L57583:

; 746  :                 pbCur += sizeof(D3DCOLOR);

  0055c	83 c3 04	 add	 ebx, 4
$L56764:

; 747  :             }
; 748  : 
; 749  :             if (cfvfOtherData.CTexCoords() > 0)

  0055f	39 bd 2c ff ff
	ff		 cmp	 DWORD PTR _cfvfOtherData$[ebp+60], edi
  00565	76 6a		 jbe	 SHORT $L56747

; 750  :             {
; 751  :                 // UNDONE UNDONE - fix when 3d tex coords are handled
; 752  :                 //iInitialTexCoord = cfvf.BTex1() ? 1 : 0;
; 753  :                 iInitialTexCoord = pFVFData->iTexCoordOffset;

  00567	8b 45 20	 mov	 eax, DWORD PTR _pFVFData$[ebp]
  0056a	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  0056d	8b 45 98	 mov	 eax, DWORD PTR tv2087[ebp]
  00570	8b 4d f0	 mov	 ecx, DWORD PTR tv2069[ebp]
  00573	03 c1		 add	 eax, ecx

; 754  : 
; 755  :                 pbTexCur = (PBYTE)cfvf.PuvGetTex1(pvCurPoint);
; 756  : 
; 757  :                 // if offset into the FVF, then move the texture pointer to the correct
; 758  :                 //    starting position. i.e. 2d coord from template and other coords from fvf data
; 759  :                 for (iTexCoord = 0; iTexCoord < iInitialTexCoord; iTexCoord++)

  00575	33 ff		 xor	 edi, edi
  00577	85 f6		 test	 esi, esi
  00579	89 45 f4	 mov	 DWORD PTR _pbTexCur$[ebp], eax
  0057c	76 14		 jbe	 SHORT $L56771
$L56769:

; 760  :                 {
; 761  :                     pbTexCur += cfvf.CbTexCoordSize(iTexCoord);

  0057e	57		 push	 edi
  0057f	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _cfvf$[ebp]
  00585	e8 00 00 00 00	 call	 ?CbTexCoordSize@DXCrackFVF@@QAEKK@Z ; DXCrackFVF::CbTexCoordSize
  0058a	01 45 f4	 add	 DWORD PTR _pbTexCur$[ebp], eax
  0058d	47		 inc	 edi
  0058e	3b fe		 cmp	 edi, esi
  00590	72 ec		 jb	 SHORT $L56769
$L56771:

; 762  :                 }
; 763  : 
; 764  :                 for (iTexCoord = 0; iTexCoord < cfvfOtherData.CTexCoords(); iTexCoord++)

  00592	33 c0		 xor	 eax, eax
  00594	39 85 2c ff ff
	ff		 cmp	 DWORD PTR _cfvfOtherData$[ebp+60], eax
  0059a	89 45 b8	 mov	 DWORD PTR _iTexCoord$[ebp], eax
  0059d	76 32		 jbe	 SHORT $L56747
$L56772:

; 765  :                 {
; 766  :                     memcpy(pbTexCur, pbCur, sizeof(BYTE) * rgdwTexCoordSizesOtherData[iTexCoord]);

  0059f	8b 7d f4	 mov	 edi, DWORD PTR _pbTexCur$[ebp]
  005a2	8d 84 85 d0 fe
	ff ff		 lea	 eax, DWORD PTR _rgdwTexCoordSizesOtherData$[ebp+eax*4]
  005a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  005ab	8b d1		 mov	 edx, ecx
  005ad	c1 e9 02	 shr	 ecx, 2
  005b0	8b f3		 mov	 esi, ebx
  005b2	f3 a5		 rep movsd

; 767  :                     pbTexCur += rgdwTexCoordSizesOtherData[iTexCoord];

  005b4	8b c2		 mov	 eax, edx
  005b6	01 45 f4	 add	 DWORD PTR _pbTexCur$[ebp], eax

; 768  :                     pbCur += rgdwTexCoordSizesOtherData[iTexCoord];

  005b9	03 d8		 add	 ebx, eax
  005bb	8b 45 b8	 mov	 eax, DWORD PTR _iTexCoord$[ebp]
  005be	8b ca		 mov	 ecx, edx
  005c0	83 e1 03	 and	 ecx, 3
  005c3	40		 inc	 eax
  005c4	3b 85 2c ff ff
	ff		 cmp	 eax, DWORD PTR _cfvfOtherData$[ebp+60]
  005ca	f3 a4		 rep movsb
  005cc	89 45 b8	 mov	 DWORD PTR _iTexCoord$[ebp], eax
  005cf	72 ce		 jb	 SHORT $L56772
$L56747:

; 707  :         goto e_Exit;
; 708  : 
; 709  :     // transform the points into the proper FVF format
; 710  :     for (iPoint=0, pvCurPoint = pvPoints; iPoint < cVertices; iPoint++, pvCurPoint+=cfvf.m_cBytesPerVertex)

  005d1	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _cfvf$[ebp+4]
  005d7	83 45 fc 44	 add	 DWORD PTR tv2038[ebp], 68 ; 00000044H
  005db	01 45 e4	 add	 DWORD PTR _pvCurPoint$[ebp], eax
  005de	01 45 f0	 add	 DWORD PTR tv2069[ebp], eax
  005e1	ff 4d d0	 dec	 DWORD PTR tv216[ebp]
  005e4	0f 85 69 fe ff
	ff		 jne	 $L56746
$L57650:

; 769  :                 }
; 770  :             }
; 771  :         }
; 772  :     }
; 773  : 
; 774  :     hr = ptmMesh->LockIndexBuffer(0, (LPVOID*)&pvFaces);

  005ea	8b 45 f8	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  005ed	8b 08		 mov	 ecx, DWORD PTR [eax]
  005ef	8d 55 d8	 lea	 edx, DWORD PTR _pvFaces$[ebp]
  005f2	52		 push	 edx
  005f3	6a 00		 push	 0
  005f5	50		 push	 eax
  005f6	ff 51 44	 call	 DWORD PTR [ecx+68]

; 775  :     if (FAILED(hr))

  005f9	85 c0		 test	 eax, eax
  005fb	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  005fe	0f 8c 3f 02 00
	00		 jl	 $e_Exit$56693

; 776  :         goto e_Exit;
; 777  : 
; 778  :     hr = ptmMesh->LockAttributeBuffer(0, &rgiAttribIds);

  00604	8b 45 f8	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  00607	8b 08		 mov	 ecx, DWORD PTR [eax]
  00609	8d 55 dc	 lea	 edx, DWORD PTR _rgiAttribIds$[ebp]
  0060c	52		 push	 edx
  0060d	6a 00		 push	 0
  0060f	50		 push	 eax
  00610	ff 51 60	 call	 DWORD PTR [ecx+96]

; 779  :     if (FAILED(hr))

  00613	85 c0		 test	 eax, eax
  00615	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00618	0f 8c 25 02 00
	00		 jl	 $e_Exit$56693

; 780  :         goto e_Exit;
; 781  : 
; 782  :     // copy the material data to arrays understood by ID3DXMesh::SetMesh
; 783  :     for (iFace = iFaceActual = 0; iFace < cFaces; iFace++)

  0061e	8b 7d 0c	 mov	 edi, DWORD PTR _cFaces$[ebp]
  00621	8b 75 08	 mov	 esi, DWORD PTR _rglfFaces$[ebp]
  00624	33 db		 xor	 ebx, ebx
  00626	33 d2		 xor	 edx, edx
  00628	33 c9		 xor	 ecx, ecx
  0062a	89 7d 20	 mov	 DWORD PTR tv757[ebp], edi
$L56783:

; 784  :     {
; 785  :         if (rglfFaces[iFace].m_wIndices[0] == UNUSED32)

  0062d	8b 06		 mov	 eax, DWORD PTR [esi]
  0062f	03 c1		 add	 eax, ecx
  00631	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00634	74 1c		 je	 SHORT $L56784

; 786  :             continue;
; 787  : 
; 788  :         if (rglfFaces[iFace].m_bAttributeSpecified)

  00636	f6 40 0c 04	 test	 BYTE PTR [eax+12], 4
  0063a	74 0d		 je	 SHORT $L56787

; 789  :         {
; 790  :             rgiAttribIds[iFaceActual] = rglfFaces[iFace].m_attr;

  0063c	8b 5d dc	 mov	 ebx, DWORD PTR _rgiAttribIds$[ebp]
  0063f	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00642	89 04 1a	 mov	 DWORD PTR [edx+ebx], eax

; 791  :         }
; 792  :         else

  00645	33 db		 xor	 ebx, ebx
  00647	eb 06		 jmp	 SHORT $L56788
$L56787:

; 793  :         {
; 794  :             //rgiAttribIds[iFace] = UNUSED32;
; 795  :             rgiAttribIds[iFaceActual] = 0;

  00649	8b 45 dc	 mov	 eax, DWORD PTR _rgiAttribIds$[ebp]
  0064c	89 1c 02	 mov	 DWORD PTR [edx+eax], ebx
$L56788:

; 796  :         }
; 797  : 
; 798  :         iFaceActual += 1;

  0064f	83 c2 04	 add	 edx, 4
$L56784:

; 780  :         goto e_Exit;
; 781  : 
; 782  :     // copy the material data to arrays understood by ID3DXMesh::SetMesh
; 783  :     for (iFace = iFaceActual = 0; iFace < cFaces; iFace++)

  00652	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00655	ff 4d 20	 dec	 DWORD PTR tv757[ebp]
  00658	75 d3		 jne	 SHORT $L56783

; 799  :     }
; 800  : 
; 801  :     if ( dwOptions & D3DXMESH_32BIT)

  0065a	f6 45 2c 01	 test	 BYTE PTR _dwOptions$[ebp], 1

; 802  :     {
; 803  :         rgdwFaces = (DWORD*)pvFaces;
; 804  : 
; 805  :         for (iFace = 0, pdwFaceCur = rgdwFaces; iFace < cFaces; iFace++)

  0065e	8b 45 d8	 mov	 eax, DWORD PTR _pvFaces$[ebp]
  00661	74 2e		 je	 SHORT $L56789
  00663	83 c0 08	 add	 eax, 8
  00666	33 c9		 xor	 ecx, ecx
$L56791:

; 806  :         {
; 807  :             if (rglfFaces[iFace].m_wIndices[0] == UNUSED32)

  00668	8b 16		 mov	 edx, DWORD PTR [esi]
  0066a	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  0066d	83 fa ff	 cmp	 edx, -1
  00670	74 17		 je	 SHORT $L56792

; 808  :                 continue;
; 809  : 
; 810  :             pdwFaceCur[0] = rglfFaces[iFace].m_wIndices[0];

  00672	89 50 f8	 mov	 DWORD PTR [eax-8], edx

; 811  :             pdwFaceCur[1] = rglfFaces[iFace].m_wIndices[1];

  00675	8b 16		 mov	 edx, DWORD PTR [esi]
  00677	8b 54 0a 04	 mov	 edx, DWORD PTR [edx+ecx+4]
  0067b	89 50 fc	 mov	 DWORD PTR [eax-4], edx

; 812  :             pdwFaceCur[2] = rglfFaces[iFace].m_wIndices[2];

  0067e	8b 16		 mov	 edx, DWORD PTR [esi]
  00680	8b 54 0a 08	 mov	 edx, DWORD PTR [edx+ecx+8]
  00684	89 10		 mov	 DWORD PTR [eax], edx

; 813  :             pdwFaceCur += 3;

  00686	83 c0 0c	 add	 eax, 12			; 0000000cH
$L56792:
  00689	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0068c	4f		 dec	 edi
  0068d	75 d9		 jne	 SHORT $L56791

; 814  :         }
; 815  :     }
; 816  :     else // 16 bit indices

  0068f	eb 33		 jmp	 SHORT $L56799
$L56789:

; 817  :     {
; 818  :         rgwFaces = (UINT16*)pvFaces;
; 819  : 
; 820  :         for (iFace = 0, pwFaceCur = rgwFaces; iFace < cFaces; iFace++)

  00691	83 c0 04	 add	 eax, 4
  00694	33 c9		 xor	 ecx, ecx
$L56797:

; 821  :         {
; 822  :             if (rglfFaces[iFace].m_wIndices[0] == UNUSED32)

  00696	8b 16		 mov	 edx, DWORD PTR [esi]
  00698	03 d1		 add	 edx, ecx
  0069a	83 3a ff	 cmp	 DWORD PTR [edx], -1
  0069d	74 1f		 je	 SHORT $L56798

; 823  :                 continue;
; 824  : 
; 825  :             pwFaceCur[0] = (UINT16)rglfFaces[iFace].m_wIndices[0];

  0069f	66 8b 12	 mov	 dx, WORD PTR [edx]
  006a2	66 89 50 fc	 mov	 WORD PTR [eax-4], dx

; 826  :             pwFaceCur[1] = (UINT16)rglfFaces[iFace].m_wIndices[1];

  006a6	8b 16		 mov	 edx, DWORD PTR [esi]
  006a8	66 8b 54 0a 04	 mov	 dx, WORD PTR [edx+ecx+4]
  006ad	66 89 50 fe	 mov	 WORD PTR [eax-2], dx

; 827  :             pwFaceCur[2] = (UINT16)rglfFaces[iFace].m_wIndices[2];

  006b1	8b 16		 mov	 edx, DWORD PTR [esi]
  006b3	66 8b 54 0a 08	 mov	 dx, WORD PTR [edx+ecx+8]
  006b8	66 89 10	 mov	 WORD PTR [eax], dx

; 828  : 
; 829  :             pwFaceCur += 3;

  006bb	83 c0 06	 add	 eax, 6
$L56798:
  006be	83 c1 2c	 add	 ecx, 44			; 0000002cH
  006c1	4f		 dec	 edi
  006c2	75 d2		 jne	 SHORT $L56797
$L56799:

; 830  :         }
; 831  :     }
; 832  : 
; 833  :     ptmMesh->UnlockAttributeBuffer();

  006c4	8b 45 f8	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  006c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  006c9	50		 push	 eax
  006ca	ff 51 64	 call	 DWORD PTR [ecx+100]

; 834  :     rgiAttribIds = NULL;
; 835  :     ptmMesh->UnlockIndexBuffer();

  006cd	8b 45 f8	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  006d0	89 5d dc	 mov	 DWORD PTR _rgiAttribIds$[ebp], ebx
  006d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  006d5	50		 push	 eax
  006d6	ff 51 48	 call	 DWORD PTR [ecx+72]

; 836  :     pvFaces = NULL;
; 837  :     ptmMesh->UnlockVertexBuffer();

  006d9	8b 45 f8	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  006dc	89 5d d8	 mov	 DWORD PTR _pvFaces$[ebp], ebx
  006df	8b 08		 mov	 ecx, DWORD PTR [eax]
  006e1	50		 push	 eax
  006e2	ff 51 40	 call	 DWORD PTR [ecx+64]

; 838  :     pvPoints = NULL;
; 839  : 
; 840  :     // if adjacency information is desired, generate it from point rep information
; 841  :     if (ppbufAdjacency != NULL)

  006e5	39 5d 3c	 cmp	 DWORD PTR _ppbufAdjacency$[ebp], ebx
  006e8	89 5d d4	 mov	 DWORD PTR _pvPoints$[ebp], ebx
  006eb	0f 84 41 01 00
	00		 je	 $L56804

; 842  :     {
; 843  :         hr = D3DXCreateBuffer(cFacesActual * 3 * sizeof(DWORD), &pbufAdjacency);

  006f1	8b 75 ec	 mov	 esi, DWORD PTR _cFacesActual$[ebp]
  006f4	8d 45 e8	 lea	 eax, DWORD PTR _pbufAdjacency$[ebp]
  006f7	8d 34 76	 lea	 esi, DWORD PTR [esi+esi*2]
  006fa	50		 push	 eax
  006fb	c1 e6 02	 shl	 esi, 2
  006fe	56		 push	 esi
  006ff	e8 00 00 00 00	 call	 _D3DXCreateBuffer@8

; 844  :         if (FAILED(hr))

  00704	3b c3		 cmp	 eax, ebx
  00706	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00709	0f 8c 34 01 00
	00		 jl	 $e_Exit$56693

; 845  :             goto e_Exit;
; 846  :         
; 847  :         pdwAdjacency = (DWORD*)pbufAdjacency->GetBufferPointer();

  0070f	8b 45 e8	 mov	 eax, DWORD PTR _pbufAdjacency$[ebp]
  00712	8b 08		 mov	 ecx, DWORD PTR [eax]
  00714	50		 push	 eax
  00715	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 848  :         GXASSERT(cFacesActual * 3 * sizeof(DWORD) == pbufAdjacency->GetBufferSize());
; 849  : 
; 850  :         rgdwPointRepsTemp = new DWORD[cVertices];

  00718	8b 7d 14	 mov	 edi, DWORD PTR _cVertices$[ebp]
  0071b	89 45 20	 mov	 DWORD PTR _pdwAdjacency$[ebp], eax
  0071e	8b c7		 mov	 eax, edi
  00720	c1 e0 02	 shl	 eax, 2
  00723	50		 push	 eax
  00724	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00729	8b d0		 mov	 edx, eax

; 851  :         if (rgdwPointRepsTemp == NULL)

  0072b	85 d2		 test	 edx, edx
  0072d	59		 pop	 ecx
  0072e	89 55 c0	 mov	 DWORD PTR _rgdwPointRepsTemp$[ebp], edx
  00731	75 0c		 jne	 SHORT $L56813
$L57656:

; 852  :         {
; 853  :             hr = E_OUTOFMEMORY;

  00733	c7 45 fc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 928  :     }
; 929  : 
; 930  :     *ppMesh = ptmMesh;

  0073a	e9 04 01 00 00	 jmp	 $e_Exit$56693
$L56813:

; 854  :             goto e_Exit;
; 855  :         }
; 856  : 
; 857  :         // load the point reps into the temp array
; 858  :         for (iPoint = 0; iPoint < cVertices; iPoint++)

  0073f	33 c0		 xor	 eax, eax
  00741	85 ff		 test	 edi, edi
  00743	76 16		 jbe	 SHORT $L57649
  00745	33 c9		 xor	 ecx, ecx
$L56816:

; 859  :         {
; 860  :             rgdwPointRepsTemp[iPoint] = rglvLoaded[iPoint].m_wPointRep;

  00747	8b 5d 10	 mov	 ebx, DWORD PTR _rglvLoaded$[ebp]
  0074a	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  0074c	8b 5c 0b 30	 mov	 ebx, DWORD PTR [ebx+ecx+48]
  00750	89 1c 82	 mov	 DWORD PTR [edx+eax*4], ebx
  00753	40		 inc	 eax
  00754	83 c1 44	 add	 ecx, 68			; 00000044H
  00757	3b c7		 cmp	 eax, edi
  00759	72 ec		 jb	 SHORT $L56816
$L57649:

; 861  :         }
; 862  : 
; 863  :         // if adjacency was provided copy it (remap if faces removed)
; 864  :         if (rgdwAdjacencyFile != NULL)

  0075b	83 7d 28 00	 cmp	 DWORD PTR _rgdwAdjacencyFile$[ebp], 0
  0075f	0f 84 9b 00 00
	00		 je	 $L56819

; 865  :         {
; 866  :             if (cFacesActual == cFaces)

  00765	8b 45 ec	 mov	 eax, DWORD PTR _cFacesActual$[ebp]
  00768	3b 45 0c	 cmp	 eax, DWORD PTR _cFaces$[ebp]
  0076b	75 1b		 jne	 SHORT $L56820

; 867  :             {
; 868  :                 memcpy(pdwAdjacency, rgdwAdjacencyFile, sizeof(DWORD) * 3 * cFacesActual);

  0076d	8b 7d 20	 mov	 edi, DWORD PTR _pdwAdjacency$[ebp]
  00770	8b ce		 mov	 ecx, esi
  00772	8b 75 28	 mov	 esi, DWORD PTR _rgdwAdjacencyFile$[ebp]
  00775	8b c1		 mov	 eax, ecx
  00777	c1 e9 02	 shr	 ecx, 2
  0077a	f3 a5		 rep movsd
  0077c	8b c8		 mov	 ecx, eax
  0077e	83 e1 03	 and	 ecx, 3
  00781	f3 a4		 rep movsb

; 869  :             }
; 870  :             else

  00783	e9 9e 00 00 00	 jmp	 $L56849
$L56820:

; 871  :             {
; 872  :                 rgdwFaceRemap = new DWORD[cFaces];

  00788	8b 75 0c	 mov	 esi, DWORD PTR _cFaces$[ebp]
  0078b	8b c6		 mov	 eax, esi
  0078d	c1 e0 02	 shl	 eax, 2
  00790	50		 push	 eax
  00791	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00796	8b d8		 mov	 ebx, eax

; 873  :                 if (rgdwFaceRemap == NULL)

  00798	85 db		 test	 ebx, ebx
  0079a	59		 pop	 ecx
  0079b	89 5d bc	 mov	 DWORD PTR _rgdwFaceRemap$[ebp], ebx

; 928  :     }
; 929  : 
; 930  :     *ppMesh = ptmMesh;

  0079e	74 93		 je	 SHORT $L57656
  007a0	33 d2		 xor	 edx, edx
  007a2	33 c0		 xor	 eax, eax
  007a4	33 c9		 xor	 ecx, ecx
$L56828:
  007a6	8b 7d 08	 mov	 edi, DWORD PTR _rglfFaces$[ebp]
  007a9	8b 3f		 mov	 edi, DWORD PTR [edi]
  007ab	83 3c 39 ff	 cmp	 DWORD PTR [ecx+edi], -1
  007af	75 06		 jne	 SHORT $L56831

; 874  :                 {
; 875  :                     hr = E_OUTOFMEMORY;
; 876  :                     goto e_Exit;
; 877  :                 }
; 878  : 
; 879  :                 // generate a remapping to ignore removed faces
; 880  :                 for (iFace = iFaceActual = 0; iFace < cFaces; iFace++)
; 881  :                 {
; 882  :                     if (rglfFaces[iFace].m_wIndices[0] == UNUSED32)
; 883  :                     {
; 884  :                         rgdwFaceRemap[iFace] = UNUSED32;

  007b1	83 0c 83 ff	 or	 DWORD PTR [ebx+eax*4], -1

; 885  :                     }
; 886  :                     else

  007b5	eb 04		 jmp	 SHORT $L56829
$L56831:

; 887  :                     {
; 888  :                         rgdwFaceRemap[iFace] = iFaceActual;

  007b7	89 14 83	 mov	 DWORD PTR [ebx+eax*4], edx

; 889  :                         iFaceActual += 1;

  007ba	42		 inc	 edx
$L56829:
  007bb	40		 inc	 eax
  007bc	83 c1 2c	 add	 ecx, 44			; 0000002cH
  007bf	3b c6		 cmp	 eax, esi
  007c1	72 e3		 jb	 SHORT $L56828

; 890  :                     }
; 891  :                 }
; 892  : 
; 893  :                 // now copy and remap the face adjacency
; 894  :                 for (iFace = iFaceActual = 0; iFace < cFaces; iFace++)

  007c3	8b 45 28	 mov	 eax, DWORD PTR _rgdwAdjacencyFile$[ebp]
  007c6	89 45 14	 mov	 DWORD PTR tv2402[ebp], eax
  007c9	8b 45 20	 mov	 eax, DWORD PTR _pdwAdjacency$[ebp]
  007cc	33 f6		 xor	 esi, esi
$L56833:

; 895  :                 {
; 896  :                     if (rgdwFaceRemap[iFace] == UNUSED32)

  007ce	83 3c b3 ff	 cmp	 DWORD PTR [ebx+esi*4], -1
  007d2	74 20		 je	 SHORT $L56834

; 897  :                         continue;
; 898  : 
; 899  :                     for (iPoint = 0; iPoint < 3; iPoint++)

  007d4	8b 55 14	 mov	 edx, DWORD PTR tv2402[ebp]
  007d7	6a 03		 push	 3
  007d9	5f		 pop	 edi
$L56837:

; 900  :                     {
; 901  :                         if (rgdwAdjacencyFile[iFace * 3 + iPoint] != UNUSED32)

  007da	8b 0a		 mov	 ecx, DWORD PTR [edx]
  007dc	83 f9 ff	 cmp	 ecx, -1
  007df	74 07		 je	 SHORT $L56840

; 902  :                             pdwAdjacency[iFaceActual * 3 + iPoint] = rgdwFaceRemap[rgdwAdjacencyFile[iFace * 3 + iPoint]];

  007e1	8b 0c 8b	 mov	 ecx, DWORD PTR [ebx+ecx*4]
  007e4	89 08		 mov	 DWORD PTR [eax], ecx

; 903  :                         else

  007e6	eb 03		 jmp	 SHORT $L56838
$L56840:

; 904  :                             pdwAdjacency[iFaceActual * 3 + iPoint] = UNUSED32;

  007e8	83 08 ff	 or	 DWORD PTR [eax], -1
$L56838:

; 897  :                         continue;
; 898  : 
; 899  :                     for (iPoint = 0; iPoint < 3; iPoint++)

  007eb	83 c2 04	 add	 edx, 4
  007ee	83 c0 04	 add	 eax, 4
  007f1	4f		 dec	 edi
  007f2	75 e6		 jne	 SHORT $L56837
$L56834:

; 890  :                     }
; 891  :                 }
; 892  : 
; 893  :                 // now copy and remap the face adjacency
; 894  :                 for (iFace = iFaceActual = 0; iFace < cFaces; iFace++)

  007f4	83 45 14 0c	 add	 DWORD PTR tv2402[ebp], 12 ; 0000000cH
  007f8	46		 inc	 esi
  007f9	3b 75 0c	 cmp	 esi, DWORD PTR _cFaces$[ebp]
  007fc	72 d0		 jb	 SHORT $L56833

; 905  :                     }
; 906  : 
; 907  :                     iFaceActual += 1;
; 908  :                 }
; 909  : 
; 910  :             }
; 911  :         }
; 912  :         // if point rep data provided, use it to generate adjacency
; 913  :         else if (bUsePointRepData)

  007fe	eb 26		 jmp	 SHORT $L56849
$L56819:
  00800	83 7d 24 00	 cmp	 DWORD PTR _bUsePointRepData$[ebp], 0

; 914  :         {
; 915  :             hr = ptmMesh->ConvertPointRepsToAdjacency(rgdwPointRepsTemp, pdwAdjacency);

  00804	8b 45 f8	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  00807	ff 75 20	 push	 DWORD PTR _pdwAdjacency$[ebp]
  0080a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0080c	74 07		 je	 SHORT $L56843
  0080e	52		 push	 edx
  0080f	50		 push	 eax
  00810	ff 51 50	 call	 DWORD PTR [ecx+80]

; 916  :             if (FAILED(hr))
; 917  :                 goto e_Exit;
; 918  :         }
; 919  :         else  // generate adjacency based on position of vertices

  00813	eb 0a		 jmp	 SHORT $L57655
$L56843:

; 920  :         {
; 921  :             hr = ptmMesh->GenerateAdjacency(0.0f, pdwAdjacency);

  00815	51		 push	 ecx
  00816	d9 ee		 fldz
  00818	d9 1c 24	 fstp	 DWORD PTR [esp]
  0081b	50		 push	 eax
  0081c	ff 51 58	 call	 DWORD PTR [ecx+88]
$L57655:

; 922  :             if (FAILED(hr))

  0081f	85 c0		 test	 eax, eax
  00821	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00824	7c 1d		 jl	 SHORT $e_Exit$56693
$L56849:

; 923  :                 goto e_Exit;
; 924  :         }
; 925  : 
; 926  :         *ppbufAdjacency = pbufAdjacency;

  00826	8b 45 e8	 mov	 eax, DWORD PTR _pbufAdjacency$[ebp]
  00829	8b 4d 3c	 mov	 ecx, DWORD PTR _ppbufAdjacency$[ebp]

; 927  :         pbufAdjacency = NULL;

  0082c	83 65 e8 00	 and	 DWORD PTR _pbufAdjacency$[ebp], 0
  00830	89 01		 mov	 DWORD PTR [ecx], eax
$L56804:

; 928  :     }
; 929  : 
; 930  :     *ppMesh = ptmMesh;

  00832	8b 45 38	 mov	 eax, DWORD PTR _ppMesh$[ebp]
  00835	8b 4d f8	 mov	 ecx, DWORD PTR _ptmMesh$[ebp]
  00838	89 08		 mov	 DWORD PTR [eax], ecx
  0083a	eb 07		 jmp	 SHORT $e_Exit$56693
$L56737:

; 694  :     {
; 695  :         hr = D3DXERR_LOADEDMESHASNODATA;

  0083c	c7 45 fc 5a 0b
	76 88		 mov	 DWORD PTR _hr$[ebp], -2005529766 ; 88760b5aH
$e_Exit$56693:

; 931  : e_Exit:
; 932  :     if (rgiAttribIds != NULL)

  00843	33 f6		 xor	 esi, esi
  00845	39 75 dc	 cmp	 DWORD PTR _rgiAttribIds$[ebp], esi
  00848	5f		 pop	 edi
  00849	5b		 pop	 ebx
  0084a	74 09		 je	 SHORT $L56851

; 933  :     {
; 934  :         ptmMesh->UnlockAttributeBuffer();

  0084c	8b 45 f8	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  0084f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00851	50		 push	 eax
  00852	ff 51 64	 call	 DWORD PTR [ecx+100]
$L56851:

; 935  :     }
; 936  :     if (pvFaces != NULL)

  00855	39 75 d8	 cmp	 DWORD PTR _pvFaces$[ebp], esi
  00858	74 09		 je	 SHORT $L56852

; 937  :     {
; 938  :         ptmMesh->UnlockIndexBuffer();

  0085a	8b 45 f8	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  0085d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0085f	50		 push	 eax
  00860	ff 51 48	 call	 DWORD PTR [ecx+72]
$L56852:

; 939  :     }
; 940  : 
; 941  :     delete []rgdwPointRepsTemp;

  00863	ff 75 c0	 push	 DWORD PTR _rgdwPointRepsTemp$[ebp]
  00866	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 942  :     delete []rgdwFaceRemap;

  0086b	ff 75 bc	 push	 DWORD PTR _rgdwFaceRemap$[ebp]
  0086e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 943  : 
; 944  :     GXRELEASE(pbufAdjacency);

  00873	8b 45 e8	 mov	 eax, DWORD PTR _pbufAdjacency$[ebp]
  00876	3b c6		 cmp	 eax, esi
  00878	59		 pop	 ecx
  00879	59		 pop	 ecx
  0087a	74 09		 je	 SHORT $L56856
  0087c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0087e	50		 push	 eax
  0087f	ff 51 08	 call	 DWORD PTR [ecx+8]
  00882	89 75 e8	 mov	 DWORD PTR _pbufAdjacency$[ebp], esi
$L56856:

; 945  : 
; 946  :     if (pvPoints != NULL)

  00885	39 75 d4	 cmp	 DWORD PTR _pvPoints$[ebp], esi
  00888	74 09		 je	 SHORT $L56859

; 947  :     {
; 948  :         ptmMesh->UnlockVertexBuffer();

  0088a	8b 45 f8	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  0088d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0088f	50		 push	 eax
  00890	ff 51 40	 call	 DWORD PTR [ecx+64]
$L56859:

; 949  :     }
; 950  : 
; 951  :     if (FAILED(hr))

  00893	39 75 fc	 cmp	 DWORD PTR _hr$[ebp], esi
  00896	7d 0d		 jge	 SHORT $L56864

; 952  :         GXRELEASE(ptmMesh);

  00898	8b 45 f8	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  0089b	3b c6		 cmp	 eax, esi
  0089d	74 06		 je	 SHORT $L56864
  0089f	8b 08		 mov	 ecx, DWORD PTR [eax]
  008a1	50		 push	 eax
  008a2	ff 51 08	 call	 DWORD PTR [ecx+8]
$L56864:

; 953  : 
; 954  :     return hr;

  008a5	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  008a8	5e		 pop	 esi

; 955  : }

  008a9	c9		 leave
  008aa	c3		 ret	 0
?SetMesh@GXU@@YAJAAPAUSLoadedFace@1@KAAPAUSLoadVertex@1@KPAUSCorner@1@KPAUSFVFData@1@HPAKKKPAUIDirect3DDevice9@@PAPAUID3DXMesh@@PAPAUID3DXBuffer@@@Z ENDP ; GXU::SetMesh
_TEXT	ENDS
END
