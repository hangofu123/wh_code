; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.4035 

	TITLE	.\loadmesh.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04EOLLOPJI@?5?6?$AN?7?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06LEBKBMLE@Vertex?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06OFCMNDMK@Corner?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04DPOPNPPG@Face?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03FNOJMHE@rgb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PMMPHFOC@matid?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06IKLLLDHL@normal?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02CLOBFCCG@uv?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01NEMOKFLO@?$DN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02KGHIDFGE@?$HN?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0SLoadedFace@GXU@@QAE@KKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@SLoadedFace@GXU@@QAEXKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitEmpty@SLoadedFace@GXU@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFileContext@GXU@@QAE@PAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Rewind@CFileContext@GXU@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetChar@CFileContext@GXU@@AAEJPADAA_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCharHelper@CFileContext@GXU@@AAEJPADAA_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLine@CFileContext@GXU@@QAEJPADHAA_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CParseOptionalArgs@GXU@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?COptionalArgs@CParseOptionalArgs@GXU@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EatWhiteSpace@GXU@@YAPADPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NotZero@GXU@@YA_NAAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EatNonWhiteSpace@GXU@@YAPADPADD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EatUntilTerminator@GXU@@YAPADPADD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Parse@CParseOptionalArgs@GXU@@QAEJPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BCompareArg@CParseOptionalArgs@GXU@@QAE_NIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDWORD@CParseOptionalArgs@GXU@@QAEJIPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetColorRGB@CParseOptionalArgs@GXU@@QAEJIPAUD3DXCOLOR@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPoint2@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR2@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVector3@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCoVector3@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadCounts@GXU@@YAJPAVCFileContext@1@PAI11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadVertex@GXU@@YAJPADPAUSLoadVertex@1@IAA_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFace@GXU@@YAJPADIPAUSLoadedFace@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadCorner@GXU@@YAJPADIIIPAUSCorner@1@AA_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadMeshFromM@GXU@@YGJPAUIStream@@KKPAUIDirect3DDevice9@@PAPAUID3DXMesh@@PAPAUID3DXBuffer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?x_szSeparators@GXU@@3PBDB			; GXU::x_szSeparators
PUBLIC	??_C@_04EOLLOPJI@?5?6?$AN?7?$AA@		; `string'
PUBLIC	?x_szVertex@GXU@@3PBDB				; GXU::x_szVertex
PUBLIC	??_C@_06LEBKBMLE@Vertex?$AA@			; `string'
PUBLIC	?x_szCorner@GXU@@3PBDB				; GXU::x_szCorner
PUBLIC	??_C@_06OFCMNDMK@Corner?$AA@			; `string'
PUBLIC	?x_szFace@GXU@@3PBDB				; GXU::x_szFace
PUBLIC	??_C@_04DPOPNPPG@Face?$AA@			; `string'
PUBLIC	?x_szOpenParen@GXU@@3PBDB			; GXU::x_szOpenParen
PUBLIC	??_C@_01ODHLEDKK@?$CI?$AA@			; `string'
PUBLIC	?x_szCloseParen@GXU@@3PBDB			; GXU::x_szCloseParen
PUBLIC	??_C@_01PKGAHCOL@?$CJ?$AA@			; `string'
PUBLIC	?x_szOptionalArgStart@GXU@@3PBDB		; GXU::x_szOptionalArgStart
PUBLIC	??_C@_01HCONENDN@?$HL?$AA@			; `string'
PUBLIC	?x_szOptionalArgEnd@GXU@@3PBDB			; GXU::x_szOptionalArgEnd
PUBLIC	??_C@_01CELHOKLL@?$HN?$AA@			; `string'
PUBLIC	?x_szRGB@GXU@@3PBDB				; GXU::x_szRGB
PUBLIC	??_C@_03FNOJMHE@rgb?$AA@			; `string'
PUBLIC	?x_szMatId@GXU@@3PBDB				; GXU::x_szMatId
PUBLIC	??_C@_05PMMPHFOC@matid?$AA@			; `string'
PUBLIC	?x_szNormal@GXU@@3PBDB				; GXU::x_szNormal
PUBLIC	??_C@_06IKLLLDHL@normal?$AA@			; `string'
PUBLIC	?x_szUv@GXU@@3PBDB				; GXU::x_szUv
PUBLIC	??_C@_02CLOBFCCG@uv?$AA@			; `string'
PUBLIC	?x_szEquals@GXU@@3PBDB				; GXU::x_szEquals
PUBLIC	??_C@_01NEMOKFLO@?$DN?$AA@			; `string'
;	COMDAT ??_C@_04EOLLOPJI@?5?6?$AN?7?$AA@
CONST	SEGMENT
??_C@_04EOLLOPJI@?5?6?$AN?7?$AA@ DB ' ', 0aH, 0dH, 09H, 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?x_szSeparators@GXU@@3PBDB DD FLAT:??_C@_04EOLLOPJI@?5?6?$AN?7?$AA@ ; GXU::x_szSeparators
_DATA	ENDS
;	COMDAT ??_C@_06LEBKBMLE@Vertex?$AA@
CONST	SEGMENT
??_C@_06LEBKBMLE@Vertex?$AA@ DB 'Vertex', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?x_szVertex@GXU@@3PBDB DD FLAT:??_C@_06LEBKBMLE@Vertex?$AA@ ; GXU::x_szVertex
_DATA	ENDS
;	COMDAT ??_C@_06OFCMNDMK@Corner?$AA@
CONST	SEGMENT
??_C@_06OFCMNDMK@Corner?$AA@ DB 'Corner', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?x_szCorner@GXU@@3PBDB DD FLAT:??_C@_06OFCMNDMK@Corner?$AA@ ; GXU::x_szCorner
_DATA	ENDS
;	COMDAT ??_C@_04DPOPNPPG@Face?$AA@
CONST	SEGMENT
??_C@_04DPOPNPPG@Face?$AA@ DB 'Face', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?x_szFace@GXU@@3PBDB DD FLAT:??_C@_04DPOPNPPG@Face?$AA@	; GXU::x_szFace
_DATA	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI?$AA@
CONST	SEGMENT
??_C@_01ODHLEDKK@?$CI?$AA@ DB '(', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?x_szOpenParen@GXU@@3PBDB DD FLAT:??_C@_01ODHLEDKK@?$CI?$AA@ ; GXU::x_szOpenParen
_DATA	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ?$AA@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ?$AA@ DB ')', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?x_szCloseParen@GXU@@3PBDB DD FLAT:??_C@_01PKGAHCOL@?$CJ?$AA@ ; GXU::x_szCloseParen
_DATA	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL?$AA@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL?$AA@ DB '{', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?x_szOptionalArgStart@GXU@@3PBDB DD FLAT:??_C@_01HCONENDN@?$HL?$AA@ ; GXU::x_szOptionalArgStart
_DATA	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN?$AA@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN?$AA@ DB '}', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?x_szOptionalArgEnd@GXU@@3PBDB DD FLAT:??_C@_01CELHOKLL@?$HN?$AA@ ; GXU::x_szOptionalArgEnd
_DATA	ENDS
;	COMDAT ??_C@_03FNOJMHE@rgb?$AA@
CONST	SEGMENT
??_C@_03FNOJMHE@rgb?$AA@ DB 'rgb', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?x_szRGB@GXU@@3PBDB DD FLAT:??_C@_03FNOJMHE@rgb?$AA@	; GXU::x_szRGB
_DATA	ENDS
;	COMDAT ??_C@_05PMMPHFOC@matid?$AA@
CONST	SEGMENT
??_C@_05PMMPHFOC@matid?$AA@ DB 'matid', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?x_szMatId@GXU@@3PBDB DD FLAT:??_C@_05PMMPHFOC@matid?$AA@ ; GXU::x_szMatId
_DATA	ENDS
;	COMDAT ??_C@_06IKLLLDHL@normal?$AA@
CONST	SEGMENT
??_C@_06IKLLLDHL@normal?$AA@ DB 'normal', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?x_szNormal@GXU@@3PBDB DD FLAT:??_C@_06IKLLLDHL@normal?$AA@ ; GXU::x_szNormal
_DATA	ENDS
;	COMDAT ??_C@_02CLOBFCCG@uv?$AA@
CONST	SEGMENT
??_C@_02CLOBFCCG@uv?$AA@ DB 'uv', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?x_szUv@GXU@@3PBDB DD FLAT:??_C@_02CLOBFCCG@uv?$AA@	; GXU::x_szUv
_DATA	ENDS
;	COMDAT ??_C@_01NEMOKFLO@?$DN?$AA@
CONST	SEGMENT
??_C@_01NEMOKFLO@?$DN?$AA@ DB '=', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?x_szEquals@GXU@@3PBDB DD FLAT:??_C@_01NEMOKFLO@?$DN?$AA@ ; GXU::x_szEquals
_DATA	ENDS
PUBLIC	?Init@SLoadedFace@GXU@@QAEXKKK@Z		; GXU::SLoadedFace::Init
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\loadutil.h
;	COMDAT ?Init@SLoadedFace@GXU@@QAEXKKK@Z
_TEXT	SEGMENT
_w0$ = 8						; size = 4
_w1$ = 12						; size = 4
_w2$ = 16						; size = 4
?Init@SLoadedFace@GXU@@QAEXKKK@Z PROC NEAR		; GXU::SLoadedFace::Init, COMDAT
; _this$ = ecx

; 63   :     }

  00000	8b ff		 npad	 2

; 55   :     {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 56   :         m_bColorSpecified = false;
; 57   :         m_bMaterialSpecified = false;
; 58   :         m_bAttributeSpecified = false;
; 59   :         m_bSmoothingGroupSpecified = false;
; 60   :         m_wIndices[0] = w0;

  00005	8b 45 08	 mov	 eax, DWORD PTR _w0$[ebp]
  00008	80 61 0c f0	 and	 BYTE PTR [ecx+12], -16	; fffffff0H
  0000c	89 01		 mov	 DWORD PTR [ecx], eax

; 61   :         m_wIndices[1] = w1;

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _w1$[ebp]
  00011	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 62   :         m_wIndices[2] = w2;

  00014	8b 45 10	 mov	 eax, DWORD PTR _w2$[ebp]
  00017	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 63   :     }

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
?Init@SLoadedFace@GXU@@QAEXKKK@Z ENDP			; GXU::SLoadedFace::Init
_TEXT	ENDS
PUBLIC	??0CFileContext@GXU@@QAE@PAUIStream@@@Z		; GXU::CFileContext::CFileContext
; Function compile flags: /Ogs
;	COMDAT ??0CFileContext@GXU@@QAE@PAUIStream@@@Z
_TEXT	SEGMENT
_pstream$ = 8						; size = 4
??0CFileContext@GXU@@QAE@PAUIStream@@@Z PROC NEAR	; GXU::CFileContext::CFileContext, COMDAT
; _this$ = ecx

; 126  :     CFileContext(IStream *pstream)

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pstream$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	33 c9		 xor	 ecx, ecx
  0000e	89 88 04 01 00
	00		 mov	 DWORD PTR [eax+260], ecx
  00014	89 88 08 01 00
	00		 mov	 DWORD PTR [eax+264], ecx
  0001a	88 88 0c 01 00
	00		 mov	 BYTE PTR [eax+268], cl
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0CFileContext@GXU@@QAE@PAUIStream@@@Z ENDP		; GXU::CFileContext::CFileContext
_TEXT	ENDS
PUBLIC	?Rewind@CFileContext@GXU@@QAEJXZ		; GXU::CFileContext::Rewind
; Function compile flags: /Ogs
;	COMDAT ?Rewind@CFileContext@GXU@@QAEJXZ
_TEXT	SEGMENT
?Rewind@CFileContext@GXU@@QAEJXZ PROC NEAR		; GXU::CFileContext::Rewind, COMDAT
; _this$ = ecx

; 138  :     }

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 133  :         m_bEndOfFile = false;

  00003	33 c0		 xor	 eax, eax

; 134  : 
; 135  :         LARGE_INTEGER li;
; 136  :         li.QuadPart = 0;
; 137  :         return m_pstream->Seek(li, STREAM_SEEK_SET, NULL);

  00005	50		 push	 eax
  00006	50		 push	 eax
  00007	33 d2		 xor	 edx, edx
  00009	52		 push	 edx
  0000a	88 81 0c 01 00
	00		 mov	 BYTE PTR [ecx+268], al
  00010	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00012	8b 31		 mov	 esi, DWORD PTR [ecx]
  00014	50		 push	 eax
  00015	51		 push	 ecx
  00016	ff 56 14	 call	 DWORD PTR [esi+20]
  00019	5e		 pop	 esi

; 138  :     }

  0001a	c3		 ret	 0
?Rewind@CFileContext@GXU@@QAEJXZ ENDP			; GXU::CFileContext::Rewind
_TEXT	ENDS
PUBLIC	?GetChar@CFileContext@GXU@@AAEJPADAA_N@Z	; GXU::CFileContext::GetChar
PUBLIC	?GetCharHelper@CFileContext@GXU@@AAEJPADAA_N@Z	; GXU::CFileContext::GetCharHelper
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\loadmesh.cpp
;	COMDAT ?GetCharHelper@CFileContext@GXU@@AAEJPADAA_N@Z
_TEXT	SEGMENT
_cchRead$ = -4						; size = 4
_pchBuffer$ = 8						; size = 4
_bEOF$ = 12						; size = 4
?GetCharHelper@CFileContext@GXU@@AAEJPADAA_N@Z PROC NEAR ; GXU::CFileContext::GetCharHelper, COMDAT
; _this$ = ecx

; 176  :     return hr;
; 177  : }

  00000	8b ff		 npad	 2

; 143  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 144  :     HRESULT hr = S_OK;

  00009	33 c0		 xor	 eax, eax

; 145  :     unsigned long cchRead;
; 146  : 
; 147  :     GXASSERT(m_ichBuffer == m_cchBuffer);
; 148  : 
; 149  :     if (m_bEndOfFile)

  0000b	38 86 0c 01 00
	00		 cmp	 BYTE PTR [esi+268], al
  00011	74 08		 je	 SHORT $L56415

; 150  :     {
; 151  :         bEOF = true;

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _bEOF$[ebp]
  00016	c6 01 01	 mov	 BYTE PTR [ecx], 1

; 152  :         goto e_Exit;

  00019	eb 54		 jmp	 SHORT $e_Exit$56416
$L56415:

; 153  :     }
; 154  : 
; 155  :     hr = m_pstream->Read(m_szBuffer, x_cbBufferSize, &cchRead);

  0001b	8b 06		 mov	 eax, DWORD PTR [esi]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	8d 55 fc	 lea	 edx, DWORD PTR _cchRead$[ebp]
  00022	52		 push	 edx
  00023	68 00 01 00 00	 push	 256			; 00000100H
  00028	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  0002b	52		 push	 edx
  0002c	50		 push	 eax
  0002d	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 156  :     if (FAILED(hr) || (cchRead == 0))

  00030	85 c0		 test	 eax, eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _cchRead$[ebp]
  00035	7c 20		 jl	 SHORT $L56420
  00037	85 c9		 test	 ecx, ecx
  00039	74 1c		 je	 SHORT $L56420

; 163  :         }
; 164  : 
; 165  :         goto e_Exit;
; 166  :     }
; 167  : 
; 168  :     m_cchBuffer = cchRead;
; 169  :     m_ichBuffer = 0;
; 170  : 
; 171  :     hr = GetChar(pchBuffer, bEOF);

  0003b	ff 75 0c	 push	 DWORD PTR _bEOF$[ebp]
  0003e	83 a6 04 01 00
	00 00		 and	 DWORD PTR [esi+260], 0
  00045	ff 75 08	 push	 DWORD PTR _pchBuffer$[ebp]
  00048	89 8e 08 01 00
	00		 mov	 DWORD PTR [esi+264], ecx
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?GetChar@CFileContext@GXU@@AAEJPADAA_N@Z ; GXU::CFileContext::GetChar

; 172  :     if (FAILED(hr))
; 173  :         goto e_Exit;
; 174  : 
; 175  : e_Exit:

  00055	eb 18		 jmp	 SHORT $e_Exit$56416
$L56420:

; 157  :     {
; 158  :         if ((hr == S_FALSE) || (cchRead == 0))

  00057	83 f8 01	 cmp	 eax, 1
  0005a	74 04		 je	 SHORT $L56423
  0005c	85 c9		 test	 ecx, ecx
  0005e	75 0f		 jne	 SHORT $e_Exit$56416
$L56423:

; 159  :         {
; 160  :             m_bEndOfFile = true;
; 161  :             bEOF = true;

  00060	8b 45 0c	 mov	 eax, DWORD PTR _bEOF$[ebp]
  00063	c6 86 0c 01 00
	00 01		 mov	 BYTE PTR [esi+268], 1
  0006a	c6 00 01	 mov	 BYTE PTR [eax], 1

; 162  :             hr = S_OK;

  0006d	33 c0		 xor	 eax, eax
$e_Exit$56416:
  0006f	5e		 pop	 esi

; 176  :     return hr;
; 177  : }

  00070	c9		 leave
  00071	c2 08 00	 ret	 8
?GetCharHelper@CFileContext@GXU@@AAEJPADAA_N@Z ENDP	; GXU::CFileContext::GetCharHelper
_TEXT	ENDS
PUBLIC	??0CParseOptionalArgs@GXU@@QAE@XZ		; GXU::CParseOptionalArgs::CParseOptionalArgs
; Function compile flags: /Ogs
;	COMDAT ??0CParseOptionalArgs@GXU@@QAE@XZ
_TEXT	SEGMENT
??0CParseOptionalArgs@GXU@@QAE@XZ PROC NEAR		; GXU::CParseOptionalArgs::CParseOptionalArgs, COMDAT
; _this$ = ecx

; 247  :     CParseOptionalArgs()

  00000	8b c1		 mov	 eax, ecx
  00002	83 60 40 00	 and	 DWORD PTR [eax+64], 0
  00006	c3		 ret	 0
??0CParseOptionalArgs@GXU@@QAE@XZ ENDP			; GXU::CParseOptionalArgs::CParseOptionalArgs
_TEXT	ENDS
PUBLIC	?COptionalArgs@CParseOptionalArgs@GXU@@QBEIXZ	; GXU::CParseOptionalArgs::COptionalArgs
; Function compile flags: /Ogs
;	COMDAT ?COptionalArgs@CParseOptionalArgs@GXU@@QBEIXZ
_TEXT	SEGMENT
?COptionalArgs@CParseOptionalArgs@GXU@@QBEIXZ PROC NEAR	; GXU::CParseOptionalArgs::COptionalArgs, COMDAT
; _this$ = ecx

; 250  :     UINT COptionalArgs() const { return m_cOptionalArgs; }

  00000	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  00003	c3		 ret	 0
?COptionalArgs@CParseOptionalArgs@GXU@@QBEIXZ ENDP	; GXU::CParseOptionalArgs::COptionalArgs
_TEXT	ENDS
PUBLIC	?EatWhiteSpace@GXU@@YAPADPAD@Z			; GXU::EatWhiteSpace
; Function compile flags: /Ogs
;	COMDAT ?EatWhiteSpace@GXU@@YAPADPAD@Z
_TEXT	SEGMENT
_szBuf$ = 8						; size = 4
?EatWhiteSpace@GXU@@YAPADPAD@Z PROC NEAR		; GXU::EatWhiteSpace, COMDAT

; 270  : 
; 271  :     return szBuf;
; 272  : }

  00000	8b ff		 npad	 2

; 265  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 45 08	 mov	 eax, DWORD PTR _szBuf$[ebp]
$L56503:

; 266  :     while ((*szBuf == ' ') || (*szBuf == '\t'))

  00008	8a 08		 mov	 cl, BYTE PTR [eax]
  0000a	80 f9 20	 cmp	 cl, 32			; 00000020H
  0000d	74 05		 je	 SHORT $L56505
  0000f	80 f9 09	 cmp	 cl, 9
  00012	75 03		 jne	 SHORT $L56504
$L56505:

; 267  :     {
; 268  :         szBuf++;

  00014	40		 inc	 eax

; 269  :     }

  00015	eb f1		 jmp	 SHORT $L56503
$L56504:

; 270  : 
; 271  :     return szBuf;
; 272  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?EatWhiteSpace@GXU@@YAPADPAD@Z ENDP			; GXU::EatWhiteSpace
_TEXT	ENDS
PUBLIC	?NotZero@GXU@@YA_NAAUD3DXVECTOR3@@@Z		; GXU::NotZero
PUBLIC	__real@00000000
EXTRN	__fltused:NEAR
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogs
CONST	ENDS
;	COMDAT ?NotZero@GXU@@YA_NAAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_vNormal$ = 8						; size = 4
?NotZero@GXU@@YA_NAAUD3DXVECTOR3@@@Z PROC NEAR		; GXU::NotZero, COMDAT

; 277  : }

  00000	8b ff		 npad	 2

; 275  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 276  :     return (vNormal.x != 0.0f) || (vNormal.y != 0.0f) || (vNormal.z != 0.0f);

  00005	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _vNormal$[ebp]
  0000e	d9 01		 fld	 DWORD PTR [ecx]
  00010	da e9		 fucompp
  00012	df e0		 fnstsw	 ax
  00014	f6 c4 44	 test	 ah, 68			; 00000044H
  00017	7a 28		 jp	 SHORT $L56954
  00019	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  0001f	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00022	da e9		 fucompp
  00024	df e0		 fnstsw	 ax
  00026	f6 c4 44	 test	 ah, 68			; 00000044H
  00029	7a 16		 jp	 SHORT $L56954
  0002b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  00031	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00034	da e9		 fucompp
  00036	df e0		 fnstsw	 ax
  00038	f6 c4 44	 test	 ah, 68			; 00000044H
  0003b	7a 04		 jp	 SHORT $L56954
  0003d	33 c0		 xor	 eax, eax

; 277  : }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$L56954:

; 276  :     return (vNormal.x != 0.0f) || (vNormal.y != 0.0f) || (vNormal.z != 0.0f);

  00041	33 c0		 xor	 eax, eax
  00043	40		 inc	 eax

; 277  : }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?NotZero@GXU@@YA_NAAUD3DXVECTOR3@@@Z ENDP		; GXU::NotZero
_TEXT	ENDS
PUBLIC	?EatNonWhiteSpace@GXU@@YAPADPADD@Z		; GXU::EatNonWhiteSpace
; Function compile flags: /Ogs
;	COMDAT ?EatNonWhiteSpace@GXU@@YAPADPADD@Z
_TEXT	SEGMENT
_szBuf$ = 8						; size = 4
_chTerminator$ = 12					; size = 1
?EatNonWhiteSpace@GXU@@YAPADPADD@Z PROC NEAR		; GXU::EatNonWhiteSpace, COMDAT

; 285  :     }
; 286  : 
; 287  :     return szBuf;
; 288  : }

  00000	8b ff		 npad	 2

; 281  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 282  :     while ((*szBuf != '\0') && (*szBuf != ' ') && (*szBuf != '\t') && (*szBuf != chTerminator))

  00005	8b 45 08	 mov	 eax, DWORD PTR _szBuf$[ebp]
  00008	eb 10		 jmp	 SHORT $L56963
$L56514:
  0000a	80 f9 20	 cmp	 cl, 32			; 00000020H
  0000d	74 11		 je	 SHORT $L56515
  0000f	80 f9 09	 cmp	 cl, 9
  00012	74 0c		 je	 SHORT $L56515
  00014	3a 4d 0c	 cmp	 cl, BYTE PTR _chTerminator$[ebp]
  00017	74 07		 je	 SHORT $L56515

; 283  :     {
; 284  :         szBuf++;

  00019	40		 inc	 eax
$L56963:

; 282  :     while ((*szBuf != '\0') && (*szBuf != ' ') && (*szBuf != '\t') && (*szBuf != chTerminator))

  0001a	8a 08		 mov	 cl, BYTE PTR [eax]
  0001c	84 c9		 test	 cl, cl
  0001e	75 ea		 jne	 SHORT $L56514
$L56515:

; 285  :     }
; 286  : 
; 287  :     return szBuf;
; 288  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?EatNonWhiteSpace@GXU@@YAPADPADD@Z ENDP			; GXU::EatNonWhiteSpace
_TEXT	ENDS
PUBLIC	?EatUntilTerminator@GXU@@YAPADPADD@Z		; GXU::EatUntilTerminator
; Function compile flags: /Ogs
;	COMDAT ?EatUntilTerminator@GXU@@YAPADPADD@Z
_TEXT	SEGMENT
_szBuf$ = 8						; size = 4
_chTerminator$ = 12					; size = 1
?EatUntilTerminator@GXU@@YAPADPADD@Z PROC NEAR		; GXU::EatUntilTerminator, COMDAT

; 296  :     }
; 297  : 
; 298  :     return szBuf;
; 299  : }

  00000	8b ff		 npad	 2

; 292  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 293  :     while ((*szBuf != '\0') && (*szBuf != chTerminator))

  00005	8b 45 08	 mov	 eax, DWORD PTR _szBuf$[ebp]
  00008	eb 06		 jmp	 SHORT $L56968
$L56521:
  0000a	3a 4d 0c	 cmp	 cl, BYTE PTR _chTerminator$[ebp]
  0000d	74 07		 je	 SHORT $L56522

; 294  :     {
; 295  :         szBuf++;

  0000f	40		 inc	 eax
$L56968:

; 293  :     while ((*szBuf != '\0') && (*szBuf != chTerminator))

  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	84 c9		 test	 cl, cl
  00014	75 f4		 jne	 SHORT $L56521
$L56522:

; 296  :     }
; 297  : 
; 298  :     return szBuf;
; 299  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?EatUntilTerminator@GXU@@YAPADPADD@Z ENDP		; GXU::EatUntilTerminator
_TEXT	ENDS
PUBLIC	?Parse@CParseOptionalArgs@GXU@@QAEJPAD@Z	; GXU::CParseOptionalArgs::Parse
; Function compile flags: /Ogs
;	COMDAT ?Parse@CParseOptionalArgs@GXU@@QAEJPAD@Z
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_szOptionalArgs$ = 8					; size = 4
?Parse@CParseOptionalArgs@GXU@@QAEJPAD@Z PROC NEAR	; GXU::CParseOptionalArgs::Parse, COMDAT
; _this$ = ecx

; 386  : }

  00000	8b ff		 npad	 2

; 303  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 304  :     HRESULT hr = S_OK;
; 305  :     char *szCur = szOptionalArgs;
; 306  :     UINT iOptionalArg;
; 307  : 
; 308  :     // find the start of the string
; 309  :     szCur = EatWhiteSpace(szCur);

  00008	ff 75 08	 push	 DWORD PTR _szOptionalArgs$[ebp]
  0000b	33 db		 xor	 ebx, ebx
  0000d	8b f1		 mov	 esi, ecx
  0000f	89 5d fc	 mov	 DWORD PTR _hr$[ebp], ebx
  00012	e8 00 00 00 00	 call	 ?EatWhiteSpace@GXU@@YAPADPAD@Z ; GXU::EatWhiteSpace

; 310  : 
; 311  :     if (*szCur != '{')

  00017	80 38 7b	 cmp	 BYTE PTR [eax], 123	; 0000007bH
  0001a	59		 pop	 ecx
  0001b	74 0c		 je	 SHORT $L56531

; 312  :     {
; 313  :         hr = E_FAIL;

  0001d	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 314  :         goto e_Exit;

  00024	e9 90 00 00 00	 jmp	 $e_Exit$56533
$L56531:

; 315  :     }
; 316  :     szCur++;

  00029	40		 inc	 eax

; 317  : 
; 318  :     while (szCur != '\0')

  0002a	0f 84 89 00 00
	00		 je	 $e_Exit$56533
  00030	57		 push	 edi
$L56536:

; 319  :     {
; 320  :         szCur = EatWhiteSpace(szCur);

  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?EatWhiteSpace@GXU@@YAPADPAD@Z ; GXU::EatWhiteSpace

; 321  : 
; 322  :         // if at the end of the string, then exit
; 323  :         if (*szCur == '\0')

  00037	38 18		 cmp	 BYTE PTR [eax], bl
  00039	59		 pop	 ecx
  0003a	74 7c		 je	 SHORT $L56975

; 324  :             break;
; 325  : 
; 326  :         // found the first argument
; 327  :         iOptionalArg = m_cOptionalArgs;

  0003c	8b 56 40	 mov	 edx, DWORD PTR [esi+64]

; 328  :         m_cOptionalArgs += 1;

  0003f	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]

; 329  : 
; 330  :         m_rgszArgs[iOptionalArg] = szCur;
; 331  : 
; 332  : 
; 333  :         // now figure out how long it is
; 334  :         szCur = EatNonWhiteSpace(szCur, '=');

  00042	6a 3d		 push	 61			; 0000003dH
  00044	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  00047	50		 push	 eax
  00048	89 04 96	 mov	 DWORD PTR [esi+edx*4], eax
  0004b	e8 00 00 00 00	 call	 ?EatNonWhiteSpace@GXU@@YAPADPADD@Z ; GXU::EatNonWhiteSpace

; 335  :         m_rgcchArgs[iOptionalArg] = (DWORD)(szCur - m_rgszArgs[iOptionalArg]);

  00050	8b c8		 mov	 ecx, eax
  00052	2b 0c 96	 sub	 ecx, DWORD PTR [esi+edx*4]

; 336  : 
; 337  :         szCur = EatWhiteSpace(szCur);

  00055	50		 push	 eax
  00056	89 4c 96 10	 mov	 DWORD PTR [esi+edx*4+16], ecx
  0005a	e8 00 00 00 00	 call	 ?EatWhiteSpace@GXU@@YAPADPAD@Z ; GXU::EatWhiteSpace
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 338  : 
; 339  :         // if there is a value, find it, else go to next arg
; 340  :         if (*szCur == '=')

  00062	80 38 3d	 cmp	 BYTE PTR [eax], 61	; 0000003dH
  00065	75 3c		 jne	 SHORT $L56540

; 341  :         {
; 342  :             szCur++; // skip the '='

  00067	40		 inc	 eax

; 343  : 
; 344  :             szCur = EatWhiteSpace(szCur);

  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?EatWhiteSpace@GXU@@YAPADPAD@Z ; GXU::EatWhiteSpace

; 345  : 
; 346  :             // had better be an argument if there was an '='
; 347  :             if (*szCur == '\0')

  0006e	38 18		 cmp	 BYTE PTR [eax], bl
  00070	59		 pop	 ecx
  00071	74 3e		 je	 SHORT $L56973

; 348  :             {
; 349  :                 hr = E_FAIL;
; 350  :                 goto e_Exit;
; 351  :             }
; 352  : 
; 353  :             m_rgszValues[iOptionalArg] = szCur;

  00073	8d 7c 96 20	 lea	 edi, DWORD PTR [esi+edx*4+32]
  00077	89 07		 mov	 DWORD PTR [edi], eax

; 354  : 
; 355  :             if (*szCur == '(')

  00079	80 38 28	 cmp	 BYTE PTR [eax], 40	; 00000028H
  0007c	75 19		 jne	 SHORT $L56544

; 356  :             {
; 357  :                 szCur = EatUntilTerminator(szCur, ')');

  0007e	6a 29		 push	 41			; 00000029H
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ?EatUntilTerminator@GXU@@YAPADPADD@Z ; GXU::EatUntilTerminator

; 358  :                 if (*szCur == '\0')

  00086	38 18		 cmp	 BYTE PTR [eax], bl
  00088	59		 pop	 ecx
  00089	59		 pop	 ecx
  0008a	74 25		 je	 SHORT $L56973

; 361  :                     goto e_Exit;
; 362  :                 }
; 363  :                 szCur++;  // move beyond the ')'

  0008c	40		 inc	 eax
$L56976:

; 364  : 
; 365  :                 m_rgcchValues[iOptionalArg] = (DWORD)(szCur - m_rgszValues[iOptionalArg]);

  0008d	8b c8		 mov	 ecx, eax
  0008f	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00091	89 4c 96 30	 mov	 DWORD PTR [esi+edx*4+48], ecx

; 366  :             }
; 367  :             else

  00095	eb 14		 jmp	 SHORT $L56551
$L56544:

; 368  :             {
; 369  :                 // NOTE: hitting end of string here is completely acceptable
; 370  :                 //   and pass in ' ' as the terminator because there is no special terminator
; 371  :                 szCur = EatNonWhiteSpace(szCur, ' ');

  00097	6a 20		 push	 32			; 00000020H
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?EatNonWhiteSpace@GXU@@YAPADPADD@Z ; GXU::EatNonWhiteSpace
  0009f	59		 pop	 ecx
  000a0	59		 pop	 ecx

; 372  : 
; 373  :                 m_rgcchValues[iOptionalArg] = (DWORD)(szCur - m_rgszValues[iOptionalArg]);
; 374  :             }
; 375  : 
; 376  :         }
; 377  :         else

  000a1	eb ea		 jmp	 SHORT $L56976
$L56540:

; 378  :         {
; 379  :             m_rgszValues[iOptionalArg] = NULL;

  000a3	89 5c 96 20	 mov	 DWORD PTR [esi+edx*4+32], ebx

; 380  :             m_rgcchValues[iOptionalArg] = 0;

  000a7	89 5c 96 30	 mov	 DWORD PTR [esi+edx*4+48], ebx
$L56551:

; 317  : 
; 318  :     while (szCur != '\0')

  000ab	3b c3		 cmp	 eax, ebx
  000ad	75 82		 jne	 SHORT $L56536

; 358  :                 if (*szCur == '\0')

  000af	eb 07		 jmp	 SHORT $L56975
$L56973:

; 359  :                 {
; 360  :                     hr = E_FAIL;

  000b1	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L56975:
  000b8	5f		 pop	 edi
$e_Exit$56533:

; 381  :         }
; 382  :     }
; 383  : 
; 384  : e_Exit:
; 385  :     return hr;

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx

; 386  : }

  000be	c9		 leave
  000bf	c2 04 00	 ret	 4
?Parse@CParseOptionalArgs@GXU@@QAEJPAD@Z ENDP		; GXU::CParseOptionalArgs::Parse
_TEXT	ENDS
PUBLIC	?BCompareArg@CParseOptionalArgs@GXU@@QAE_NIPBD@Z ; GXU::CParseOptionalArgs::BCompareArg
EXTRN	_strncmp:NEAR
; Function compile flags: /Ogs
;	COMDAT ?BCompareArg@CParseOptionalArgs@GXU@@QAE_NIPBD@Z
_TEXT	SEGMENT
_iOptionalArg$ = 8					; size = 4
_szPossibleArg$ = 12					; size = 4
?BCompareArg@CParseOptionalArgs@GXU@@QAE_NIPBD@Z PROC NEAR ; GXU::CParseOptionalArgs::BCompareArg, COMDAT
; _this$ = ecx

; 393  : }

  00000	8b ff		 npad	 2

; 390  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 391  :     GXASSERT(iOptionalArg < m_cOptionalArgs);
; 392  :     return strncmp(szPossibleArg, m_rgszArgs[iOptionalArg], m_rgcchArgs[iOptionalArg]) == 0;

  00005	8b 45 08	 mov	 eax, DWORD PTR _iOptionalArg$[ebp]
  00008	ff 74 81 10	 push	 DWORD PTR [ecx+eax*4+16]
  0000c	ff 34 81	 push	 DWORD PTR [ecx+eax*4]
  0000f	ff 75 0c	 push	 DWORD PTR _szPossibleArg$[ebp]
  00012	e8 00 00 00 00	 call	 _strncmp
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001a	f7 d8		 neg	 eax
  0001c	1b c0		 sbb	 eax, eax
  0001e	40		 inc	 eax

; 393  : }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?BCompareArg@CParseOptionalArgs@GXU@@QAE_NIPBD@Z ENDP	; GXU::CParseOptionalArgs::BCompareArg
_TEXT	ENDS
PUBLIC	?GetDWORD@CParseOptionalArgs@GXU@@QAEJIPAK@Z	; GXU::CParseOptionalArgs::GetDWORD
EXTRN	_atoi:NEAR
; Function compile flags: /Ogs
;	COMDAT ?GetDWORD@CParseOptionalArgs@GXU@@QAEJIPAK@Z
_TEXT	SEGMENT
_iOptionalArg$ = 8					; size = 4
_piArg$ = 12						; size = 4
?GetDWORD@CParseOptionalArgs@GXU@@QAEJIPAK@Z PROC NEAR	; GXU::CParseOptionalArgs::GetDWORD, COMDAT
; _this$ = ecx

; 403  : }

  00000	8b ff		 npad	 2

; 397  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 398  :     GXASSERT(iOptionalArg < m_cOptionalArgs);
; 399  : 
; 400  :     *piArg = atoi(m_rgszValues[iOptionalArg]);

  00005	8b 45 08	 mov	 eax, DWORD PTR _iOptionalArg$[ebp]
  00008	ff 74 81 20	 push	 DWORD PTR [ecx+eax*4+32]
  0000c	e8 00 00 00 00	 call	 _atoi
  00011	59		 pop	 ecx
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _piArg$[ebp]
  00015	89 01		 mov	 DWORD PTR [ecx], eax

; 401  : 
; 402  :     return S_OK;

  00017	33 c0		 xor	 eax, eax

; 403  : }

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?GetDWORD@CParseOptionalArgs@GXU@@QAEJIPAK@Z ENDP	; GXU::CParseOptionalArgs::GetDWORD
_TEXT	ENDS
PUBLIC	?GetColorRGB@CParseOptionalArgs@GXU@@QAEJIPAUD3DXCOLOR@@@Z ; GXU::CParseOptionalArgs::GetColorRGB
EXTRN	_strtod:NEAR
; Function compile flags: /Ogs
;	COMDAT ?GetColorRGB@CParseOptionalArgs@GXU@@QAEJIPAUD3DXCOLOR@@@Z
_TEXT	SEGMENT
_szCur$ = 8						; size = 4
_iOptionalArg$ = 8					; size = 4
_pcolor$ = 12						; size = 4
?GetColorRGB@CParseOptionalArgs@GXU@@QAEJIPAUD3DXCOLOR@@@Z PROC NEAR ; GXU::CParseOptionalArgs::GetColorRGB, COMDAT
; _this$ = ecx

; 425  : }

  00000	8b ff		 npad	 2

; 407  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 408  :     GXASSERT(iOptionalArg < m_cOptionalArgs);
; 409  : 
; 410  :     HRESULT hr = S_OK;
; 411  :     char *szCur;
; 412  : 
; 413  :     szCur = m_rgszValues[iOptionalArg];
; 414  : 
; 415  :     GXASSERT(*szCur == '(');
; 416  :     szCur++;

  00005	8b 45 08	 mov	 eax, DWORD PTR _iOptionalArg$[ebp]
  00008	8b 44 81 20	 mov	 eax, DWORD PTR [ecx+eax*4+32]
  0000c	56		 push	 esi

; 417  : 
; 418  :     // convert the three numbers into a color
; 419  :     pcolor->r = (float)strtod(szCur, &szCur);

  0000d	8d 4d 08	 lea	 ecx, DWORD PTR _szCur$[ebp]
  00010	40		 inc	 eax
  00011	51		 push	 ecx
  00012	50		 push	 eax
  00013	89 45 08	 mov	 DWORD PTR _szCur$[ebp], eax
  00016	e8 00 00 00 00	 call	 _strtod
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _pcolor$[ebp]

; 420  :     pcolor->g = (float)strtod(szCur, &szCur);

  0001e	8d 45 08	 lea	 eax, DWORD PTR _szCur$[ebp]
  00021	d9 1e		 fstp	 DWORD PTR [esi]
  00023	50		 push	 eax
  00024	ff 75 08	 push	 DWORD PTR _szCur$[ebp]
  00027	e8 00 00 00 00	 call	 _strtod
  0002c	d9 5e 04	 fstp	 DWORD PTR [esi+4]

; 421  :     pcolor->b = (float)strtod(szCur, &szCur);

  0002f	8d 45 08	 lea	 eax, DWORD PTR _szCur$[ebp]
  00032	50		 push	 eax
  00033	ff 75 08	 push	 DWORD PTR _szCur$[ebp]
  00036	e8 00 00 00 00	 call	 _strtod
  0003b	d9 5e 08	 fstp	 DWORD PTR [esi+8]

; 422  :     pcolor->a = 0.0f;

  0003e	d9 ee		 fldz
  00040	83 c4 18	 add	 esp, 24			; 00000018H
  00043	d9 5e 0c	 fstp	 DWORD PTR [esi+12]

; 423  : 
; 424  :     return hr;

  00046	33 c0		 xor	 eax, eax
  00048	5e		 pop	 esi

; 425  : }

  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
?GetColorRGB@CParseOptionalArgs@GXU@@QAEJIPAUD3DXCOLOR@@@Z ENDP ; GXU::CParseOptionalArgs::GetColorRGB
_TEXT	ENDS
PUBLIC	?GetPoint2@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR2@@@Z ; GXU::CParseOptionalArgs::GetPoint2
; Function compile flags: /Ogs
;	COMDAT ?GetPoint2@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR2@@@Z
_TEXT	SEGMENT
_szCur$ = 8						; size = 4
_iOptionalArg$ = 8					; size = 4
_puvPoint$ = 12						; size = 4
?GetPoint2@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR2@@@Z PROC NEAR ; GXU::CParseOptionalArgs::GetPoint2, COMDAT
; _this$ = ecx

; 445  : }

  00000	8b ff		 npad	 2

; 429  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 430  :     GXASSERT(iOptionalArg < m_cOptionalArgs);
; 431  : 
; 432  :     HRESULT hr = S_OK;
; 433  :     char *szCur;
; 434  : 
; 435  :     szCur = m_rgszValues[iOptionalArg];
; 436  : 
; 437  :     GXASSERT(*szCur == '(');
; 438  :     szCur++;

  00005	8b 45 08	 mov	 eax, DWORD PTR _iOptionalArg$[ebp]
  00008	8b 44 81 20	 mov	 eax, DWORD PTR [ecx+eax*4+32]
  0000c	56		 push	 esi

; 439  : 
; 440  :     // find and convert the first number
; 441  :     puvPoint->x = (float)strtod(szCur, &szCur);

  0000d	8d 4d 08	 lea	 ecx, DWORD PTR _szCur$[ebp]
  00010	40		 inc	 eax
  00011	51		 push	 ecx
  00012	50		 push	 eax
  00013	89 45 08	 mov	 DWORD PTR _szCur$[ebp], eax
  00016	e8 00 00 00 00	 call	 _strtod
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _puvPoint$[ebp]

; 442  :     puvPoint->y = (float)strtod(szCur, &szCur);

  0001e	8d 45 08	 lea	 eax, DWORD PTR _szCur$[ebp]
  00021	d9 1e		 fstp	 DWORD PTR [esi]
  00023	50		 push	 eax
  00024	ff 75 08	 push	 DWORD PTR _szCur$[ebp]
  00027	e8 00 00 00 00	 call	 _strtod
  0002c	d9 5e 04	 fstp	 DWORD PTR [esi+4]
  0002f	83 c4 10	 add	 esp, 16			; 00000010H

; 443  : 
; 444  :     return hr;

  00032	33 c0		 xor	 eax, eax
  00034	5e		 pop	 esi

; 445  : }

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?GetPoint2@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR2@@@Z ENDP ; GXU::CParseOptionalArgs::GetPoint2
_TEXT	ENDS
PUBLIC	?GetVector3@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR3@@@Z ; GXU::CParseOptionalArgs::GetVector3
; Function compile flags: /Ogs
;	COMDAT ?GetVector3@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_szCur$ = 8						; size = 4
_iOptionalArg$ = 8					; size = 4
_pvVector$ = 12						; size = 4
?GetVector3@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR3@@@Z PROC NEAR ; GXU::CParseOptionalArgs::GetVector3, COMDAT
; _this$ = ecx

; 466  : }

  00000	8b ff		 npad	 2

; 449  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 450  :     GXASSERT(iOptionalArg < m_cOptionalArgs);
; 451  : 
; 452  :     HRESULT hr = S_OK;
; 453  :     char *szCur;
; 454  : 
; 455  :     szCur = m_rgszValues[iOptionalArg];
; 456  : 
; 457  :     GXASSERT(*szCur == '(');
; 458  :     szCur++;

  00005	8b 45 08	 mov	 eax, DWORD PTR _iOptionalArg$[ebp]
  00008	8b 44 81 20	 mov	 eax, DWORD PTR [ecx+eax*4+32]
  0000c	56		 push	 esi

; 459  : 
; 460  :     // find and convert the first number
; 461  :     pvVector->x = (float)strtod(szCur, &szCur);

  0000d	8d 4d 08	 lea	 ecx, DWORD PTR _szCur$[ebp]
  00010	40		 inc	 eax
  00011	51		 push	 ecx
  00012	50		 push	 eax
  00013	89 45 08	 mov	 DWORD PTR _szCur$[ebp], eax
  00016	e8 00 00 00 00	 call	 _strtod
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _pvVector$[ebp]

; 462  :     pvVector->y = (float)strtod(szCur, &szCur);

  0001e	8d 45 08	 lea	 eax, DWORD PTR _szCur$[ebp]
  00021	d9 1e		 fstp	 DWORD PTR [esi]
  00023	50		 push	 eax
  00024	ff 75 08	 push	 DWORD PTR _szCur$[ebp]
  00027	e8 00 00 00 00	 call	 _strtod
  0002c	d9 5e 04	 fstp	 DWORD PTR [esi+4]

; 463  :     pvVector->z = (float)strtod(szCur, &szCur);

  0002f	8d 45 08	 lea	 eax, DWORD PTR _szCur$[ebp]
  00032	50		 push	 eax
  00033	ff 75 08	 push	 DWORD PTR _szCur$[ebp]
  00036	e8 00 00 00 00	 call	 _strtod
  0003b	d9 5e 08	 fstp	 DWORD PTR [esi+8]
  0003e	83 c4 18	 add	 esp, 24			; 00000018H

; 464  : 
; 465  :     return hr;

  00041	33 c0		 xor	 eax, eax
  00043	5e		 pop	 esi

; 466  : }

  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
?GetVector3@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR3@@@Z ENDP ; GXU::CParseOptionalArgs::GetVector3
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 165  :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??0D3DXCOLOR@@QAE@XZ				; D3DXCOLOR::D3DXCOLOR
; Function compile flags: /Ogs
;	COMDAT ??0D3DXCOLOR@@QAE@XZ
_TEXT	SEGMENT
??0D3DXCOLOR@@QAE@XZ PROC NEAR				; D3DXCOLOR::D3DXCOLOR, COMDAT
; _this$ = ecx

; 516  :     D3DXCOLOR() {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXCOLOR@@QAE@XZ ENDP				; D3DXCOLOR::D3DXCOLOR
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 308  : }

  00000	8b ff		 npad	 2

; 304  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx

; 305  :     x = fx;

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _fx$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 306  :     y = fy;

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _fy$[ebp]
  0000f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 307  :     z = fz;

  00012	8b 4d 10	 mov	 ecx, DWORD PTR _fz$[ebp]
  00015	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 308  : }

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??0D3DXCOLOR@@QAE@MMMM@Z			; D3DXCOLOR::D3DXCOLOR
; Function compile flags: /Ogs
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT
_fr$ = 8						; size = 4
_fg$ = 12						; size = 4
_fb$ = 16						; size = 4
_fa$ = 20						; size = 4
??0D3DXCOLOR@@QAE@MMMM@Z PROC NEAR			; D3DXCOLOR::D3DXCOLOR, COMDAT
; _this$ = ecx

; 1395 : }

  00000	8b ff		 npad	 2

; 1390 : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx

; 1391 :     r = fr;

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _fr$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1392 :     g = fg;

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _fg$[ebp]
  0000f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1393 :     b = fb;

  00012	8b 4d 10	 mov	 ecx, DWORD PTR _fb$[ebp]
  00015	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1394 :     a = fa;

  00018	8b 4d 14	 mov	 ecx, DWORD PTR _fa$[ebp]
  0001b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 1395 : }

  0001e	5d		 pop	 ebp
  0001f	c2 10 00	 ret	 16			; 00000010H
??0D3DXCOLOR@@QAE@MMMM@Z ENDP				; D3DXCOLOR::D3DXCOLOR
_TEXT	ENDS
PUBLIC	??0SLoadedFace@GXU@@QAE@KKK@Z			; GXU::SLoadedFace::SLoadedFace
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\loadutil.h
;	COMDAT ??0SLoadedFace@GXU@@QAE@KKK@Z
_TEXT	SEGMENT
_w0$ = 8						; size = 4
_w1$ = 12						; size = 4
_w2$ = 16						; size = 4
??0SLoadedFace@GXU@@QAE@KKK@Z PROC NEAR			; GXU::SLoadedFace::SLoadedFace, COMDAT
; _this$ = ecx

; 48   :     }

  00000	8b ff		 npad	 2

; 45   :     SLoadedFace( DWORD w0, DWORD w1, DWORD w2 )

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx

; 46   :     {
; 47   :         Init(w0, w1, w2);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _w0$[ebp]
  0000a	80 60 0c f0	 and	 BYTE PTR [eax+12], -16	; fffffff0H
  0000e	89 08		 mov	 DWORD PTR [eax], ecx
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _w1$[ebp]
  00013	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00016	8b 4d 10	 mov	 ecx, DWORD PTR _w2$[ebp]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 48   :     }

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
??0SLoadedFace@GXU@@QAE@KKK@Z ENDP			; GXU::SLoadedFace::SLoadedFace
; Function compile flags: /Ogs
_TEXT	ENDS
;	COMDAT ?GetChar@CFileContext@GXU@@AAEJPADAA_N@Z
_TEXT	SEGMENT
_szBuffer$ = 8						; size = 4
_bEOF$ = 12						; size = 4
?GetChar@CFileContext@GXU@@AAEJPADAA_N@Z PROC NEAR	; GXU::CFileContext::GetChar, COMDAT
; _this$ = ecx

; 154  :         }
; 155  : 
; 156  :     }

  00000	8b ff		 npad	 2

; 142  :     {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 143  :         bEOF = false;

  00006	8b 75 0c	 mov	 esi, DWORD PTR _bEOF$[ebp]
  00009	c6 06 00	 mov	 BYTE PTR [esi], 0

; 144  : 
; 145  :         if (m_ichBuffer < m_cchBuffer)

  0000c	8d 81 04 01 00
	00		 lea	 eax, DWORD PTR [ecx+260]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	3b 91 08 01 00
	00		 cmp	 edx, DWORD PTR [ecx+264]
  0001a	73 0f		 jae	 SHORT $L56374

; 146  :         {
; 147  :             *szBuffer = m_szBuffer[m_ichBuffer];

  0001c	8a 4c 0a 04	 mov	 cl, BYTE PTR [edx+ecx+4]
  00020	8b 55 08	 mov	 edx, DWORD PTR _szBuffer$[ebp]
  00023	88 0a		 mov	 BYTE PTR [edx], cl

; 148  :             m_ichBuffer += 1;

  00025	ff 00		 inc	 DWORD PTR [eax]

; 149  :             return S_OK;

  00027	33 c0		 xor	 eax, eax
  00029	eb 09		 jmp	 SHORT $L56376
$L56374:

; 150  :         }
; 151  :         else
; 152  :         {
; 153  :             return GetCharHelper(szBuffer, bEOF);

  0002b	56		 push	 esi
  0002c	ff 75 08	 push	 DWORD PTR _szBuffer$[ebp]
  0002f	e8 00 00 00 00	 call	 ?GetCharHelper@CFileContext@GXU@@AAEJPADAA_N@Z ; GXU::CFileContext::GetCharHelper
$L56376:
  00034	5e		 pop	 esi

; 154  :         }
; 155  : 
; 156  :     }

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?GetChar@CFileContext@GXU@@AAEJPADAA_N@Z ENDP		; GXU::CFileContext::GetChar
_TEXT	ENDS
PUBLIC	?GetLine@CFileContext@GXU@@QAEJPADHAA_N@Z	; GXU::CFileContext::GetLine
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\loadmesh.cpp
;	COMDAT ?GetLine@CFileContext@GXU@@QAEJPADHAA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_szBuffer$ = 8						; size = 4
_chTemp$ = 11						; size = 1
_cchBuffer$ = 12					; size = 4
_bEOF$ = 16						; size = 4
_bTemp$ = 19						; size = 1
?GetLine@CFileContext@GXU@@QAEJPADHAA_N@Z PROC NEAR	; GXU::CFileContext::GetLine, COMDAT
; _this$ = ecx

; 229  :     return hr;;
; 230  : }

  00000	8b ff		 npad	 2

; 181  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	53		 push	 ebx

; 182  :     int ichBuffer;
; 183  :     HRESULT hr = S_OK;
; 184  :     bool bTemp;
; 185  :     char chTemp;
; 186  : 
; 187  :     ichBuffer = 0;
; 188  :     bEOF = false;

  00007	8b 5d 10	 mov	 ebx, DWORD PTR _bEOF$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 189  : 
; 190  :     hr = GetChar(&szBuffer[ichBuffer], bEOF);

  0000c	8b 7d 08	 mov	 edi, DWORD PTR _szBuffer$[ebp]
  0000f	53		 push	 ebx
  00010	57		 push	 edi
  00011	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00014	33 f6		 xor	 esi, esi
  00016	c6 03 00	 mov	 BYTE PTR [ebx], 0
  00019	e8 00 00 00 00	 call	 ?GetChar@CFileContext@GXU@@AAEJPADAA_N@Z ; GXU::CFileContext::GetChar

; 191  :         if (FAILED(hr) || bEOF)

  0001e	85 c0		 test	 eax, eax
  00020	7c 71		 jl	 SHORT $e_Exit$56443
  00022	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00025	75 6c		 jne	 SHORT $e_Exit$56443

; 192  :     {
; 193  :         // this is both an acceptable EOF case, and an error case, but no way to tell the user
; 194  :         goto e_Exit;
; 195  :     }
; 196  : 
; 197  :     while ((szBuffer[ichBuffer] != '\n') && (ichBuffer < cchBuffer - 2))

  00027	80 3f 0a	 cmp	 BYTE PTR [edi], 10	; 0000000aH
  0002a	74 31		 je	 SHORT $L57003
$L56446:
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _cchBuffer$[ebp]
  0002f	83 c1 fe	 add	 ecx, -2			; fffffffeH
  00032	3b f1		 cmp	 esi, ecx
  00034	7d 27		 jge	 SHORT $L57003

; 198  :     {
; 199  :         ichBuffer += 1;
; 200  : 
; 201  :         hr = GetChar(&szBuffer[ichBuffer], bTemp);

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8d 45 13	 lea	 eax, DWORD PTR _bTemp$[ebp]
  0003c	46		 inc	 esi
  0003d	50		 push	 eax
  0003e	8d 1c 3e	 lea	 ebx, DWORD PTR [esi+edi]
  00041	53		 push	 ebx
  00042	e8 00 00 00 00	 call	 ?GetChar@CFileContext@GXU@@AAEJPADAA_N@Z ; GXU::CFileContext::GetChar

; 202  :             if (FAILED(hr) || bTemp)

  00047	85 c0		 test	 eax, eax
  00049	7c 4f		 jl	 SHORT $L56999
  0004b	80 7d 13 00	 cmp	 BYTE PTR _bTemp$[ebp], 0
  0004f	75 49		 jne	 SHORT $L56999

; 205  :             goto e_Exit;
; 206  :         }
; 207  : 
; 208  :         if (szBuffer[ichBuffer] == '\r')

  00051	80 3b 0d	 cmp	 BYTE PTR [ebx], 13	; 0000000dH
  00054	75 01		 jne	 SHORT $L56452

; 209  :             ichBuffer -= 1;

  00056	4e		 dec	 esi
$L56452:

; 192  :     {
; 193  :         // this is both an acceptable EOF case, and an error case, but no way to tell the user
; 194  :         goto e_Exit;
; 195  :     }
; 196  : 
; 197  :     while ((szBuffer[ichBuffer] != '\n') && (ichBuffer < cchBuffer - 2))

  00057	80 3c 3e 0a	 cmp	 BYTE PTR [esi+edi], 10	; 0000000aH
  0005b	75 cf		 jne	 SHORT $L56446
$L57003:

; 210  :     }
; 211  : 
; 212  : 
; 213  :     szBuffer[ichBuffer+1] = '\0';
; 214  : 
; 215  :     // if we hit the limit of the string without hitting the end of the line
; 216  :     //    then skip the rest of the line
; 217  :     if ((ichBuffer == cchBuffer - 2) && (szBuffer[ichBuffer] != '\n'))

  0005d	8b 55 0c	 mov	 edx, DWORD PTR _cchBuffer$[ebp]
  00060	83 c2 fe	 add	 edx, -2			; fffffffeH
  00063	3b f2		 cmp	 esi, edx
  00065	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00068	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0
  0006c	75 25		 jne	 SHORT $e_Exit$56443
  0006e	80 39 0a	 cmp	 BYTE PTR [ecx], 10	; 0000000aH
  00071	74 20		 je	 SHORT $e_Exit$56443
$L56454:

; 218  :     {
; 219  :         do
; 220  :         {
; 221  :             hr = GetChar(&chTemp, bTemp);

  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8d 45 13	 lea	 eax, DWORD PTR _bTemp$[ebp]
  00079	50		 push	 eax
  0007a	8d 45 0b	 lea	 eax, DWORD PTR _chTemp$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?GetChar@CFileContext@GXU@@AAEJPADAA_N@Z ; GXU::CFileContext::GetChar

; 222  :             if (FAILED(hr) || bTemp)

  00083	85 c0		 test	 eax, eax
  00085	7c 0c		 jl	 SHORT $e_Exit$56443
  00087	80 7d 13 00	 cmp	 BYTE PTR _bTemp$[ebp], 0
  0008b	75 06		 jne	 SHORT $e_Exit$56443

; 223  :                 goto e_Exit;
; 224  :         }
; 225  :         while (chTemp != '\n');

  0008d	80 7d 0b 0a	 cmp	 BYTE PTR _chTemp$[ebp], 10 ; 0000000aH
  00091	75 e0		 jne	 SHORT $L56454
$e_Exit$56443:
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx

; 229  :     return hr;;
; 230  : }

  00096	c9		 leave
  00097	c2 0c 00	 ret	 12			; 0000000cH
$L56999:

; 203  :         {
; 204  :             szBuffer[ichBuffer+1] = '\0';

  0009a	c6 44 3e 01 00	 mov	 BYTE PTR [esi+edi+1], 0

; 226  :     }
; 227  : 
; 228  : e_Exit:

  0009f	eb f2		 jmp	 SHORT $e_Exit$56443
?GetLine@CFileContext@GXU@@QAEJPADHAA_N@Z ENDP		; GXU::CFileContext::GetLine
_TEXT	ENDS
PUBLIC	?GetCoVector3@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR3@@@Z ; GXU::CParseOptionalArgs::GetCoVector3
; Function compile flags: /Ogs
;	COMDAT ?GetCoVector3@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_vTemp$ = -12						; size = 12
_iOptionalArg$ = 8					; size = 4
_pvVector$ = 12						; size = 4
?GetCoVector3@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR3@@@Z PROC NEAR ; GXU::CParseOptionalArgs::GetCoVector3, COMDAT
; _this$ = ecx

; 481  : }

  00000	8b ff		 npad	 2

; 470  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 471  :     HRESULT hr;
; 472  : 
; 473  :     D3DXVECTOR3 vTemp;
; 474  :     hr = GetVector3(iOptionalArg, &vTemp);

  00008	8d 45 f4	 lea	 eax, DWORD PTR _vTemp$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _iOptionalArg$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetVector3@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR3@@@Z ; GXU::CParseOptionalArgs::GetVector3

; 475  :     if (FAILED(hr))

  00014	85 c0		 test	 eax, eax

; 476  :         return hr;

  00016	7c 0f		 jl	 SHORT $L56607
  00018	56		 push	 esi
  00019	57		 push	 edi

; 477  : 
; 478  :     *pvVector = vTemp;

  0001a	8b 7d 0c	 mov	 edi, DWORD PTR _pvVector$[ebp]
  0001d	8d 75 f4	 lea	 esi, DWORD PTR _vTemp$[ebp]
  00020	a5		 movsd
  00021	a5		 movsd
  00022	a5		 movsd
  00023	5f		 pop	 edi

; 479  : 
; 480  :     return S_OK;

  00024	33 c0		 xor	 eax, eax
  00026	5e		 pop	 esi
$L56607:

; 481  : }

  00027	c9		 leave
  00028	c2 08 00	 ret	 8
?GetCoVector3@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR3@@@Z ENDP ; GXU::CParseOptionalArgs::GetCoVector3
_TEXT	ENDS
PUBLIC	?LoadCounts@GXU@@YAJPAVCFileContext@1@PAI11@Z	; GXU::LoadCounts
EXTRN	_strtok:NEAR
EXTRN	_atol:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Ogs
;	COMDAT ?LoadCounts@GXU@@YAJPAVCFileContext@1@PAI11@Z
_TEXT	SEGMENT
$T57012 = -52						; size = 4
$T57013 = -48						; size = 4
$T57010 = -44						; size = 4
_cVertices$ = -40					; size = 4
_cFaces$ = -36						; size = 4
_cCorners$ = -32					; size = 4
_bEOF$ = -25						; size = 1
_rgchBuf$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pfc$ = 8						; size = 4
_pcVertices$ = 12					; size = 4
_pcFaces$ = 16						; size = 4
_pcCorners$ = 20					; size = 4
?LoadCounts@GXU@@YAJPAVCFileContext@1@PAI11@Z PROC NEAR	; GXU::LoadCounts, COMDAT

; 573  :     return hr;
; 574  : }

  00000	8b ff		 npad	 2

; 486  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 34	 sub	 esp, 52			; 00000034H
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pfc$[ebp]
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _pcVertices$[ebp]

; 487  :     HRESULT hr = S_OK;
; 488  :     char rgchBuf[20];
; 489  :     char *szHeader;
; 490  :     UINT cFaces;
; 491  :     UINT cVertices;
; 492  :     UINT cCorners;
; 493  :     char *szValue;
; 494  :     UINT cNewValue;
; 495  :     bool bEOF;
; 496  : 
; 497  :     GXASSERT((pcVertices != NULL) && (pcFaces != NULL) && (pcCorners != NULL));
; 498  : 
; 499  :     // initialize the counters
; 500  :     *pcVertices = UINT_MAX;

  00014	83 0b ff	 or	 DWORD PTR [ebx], -1
  00017	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 501  :     *pcFaces = UINT_MAX;
; 502  :     *pcCorners = UINT_MAX;
; 503  : 
; 504  : 
; 505  :     cFaces = 0;

  0001a	33 c0		 xor	 eax, eax
  0001c	56		 push	 esi
  0001d	8b 75 10	 mov	 esi, DWORD PTR _pcFaces$[ebp]
  00020	83 0e ff	 or	 DWORD PTR [esi], -1
  00023	57		 push	 edi
  00024	8b 7d 14	 mov	 edi, DWORD PTR _pcCorners$[ebp]
  00027	83 0f ff	 or	 DWORD PTR [edi], -1
  0002a	89 45 dc	 mov	 DWORD PTR _cFaces$[ebp], eax

; 506  :     cVertices = 0;

  0002d	89 45 d8	 mov	 DWORD PTR _cVertices$[ebp], eax

; 507  :     cCorners = 0;

  00030	89 45 e0	 mov	 DWORD PTR _cCorners$[ebp], eax

; 508  : 
; 509  :     // get the counts of the faces, vertices, etc
; 510  :     while ( 1 )
; 511  :     {
; 512  :         hr = pfc->GetLine(rgchBuf, sizeof(rgchBuf), bEOF);

  00033	8d 45 e7	 lea	 eax, DWORD PTR _bEOF$[ebp]
  00036	50		 push	 eax
  00037	6a 14		 push	 20			; 00000014H
  00039	8d 45 e8	 lea	 eax, DWORD PTR _rgchBuf$[ebp]
  0003c	50		 push	 eax
  0003d	89 4d d4	 mov	 DWORD PTR $T57010[ebp], ecx
  00040	89 75 cc	 mov	 DWORD PTR $T57012[ebp], esi
  00043	89 7d d0	 mov	 DWORD PTR $T57013[ebp], edi
  00046	e8 00 00 00 00	 call	 ?GetLine@CFileContext@GXU@@QAEJPADHAA_N@Z ; GXU::CFileContext::GetLine

; 513  :         if (FAILED(hr))

  0004b	85 c0		 test	 eax, eax
  0004d	0f 8c 52 01 00
	00		 jl	 $e_Exit$56635
  00053	eb 06		 jmp	 SHORT $L56631
$L57033:
  00055	8b 7d d0	 mov	 edi, DWORD PTR $T57013[ebp]
  00058	8b 75 cc	 mov	 esi, DWORD PTR $T57012[ebp]
$L56631:

; 516  :         }
; 517  : 
; 518  :         if (bEOF)

  0005b	80 7d e7 00	 cmp	 BYTE PTR _bEOF$[ebp], 0
  0005f	0f 85 22 01 00
	00		 jne	 $L57017

; 519  :         {
; 520  :             break;  // EOF, break out of loop
; 521  :         }
; 522  : 
; 523  :         szHeader = strtok( rgchBuf, x_szSeparators );

  00065	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  0006b	8d 45 e8	 lea	 eax, DWORD PTR _rgchBuf$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _strtok
  00074	8b f0		 mov	 esi, eax

; 524  : 
; 525  :         // if the token is NULL, go onto the next line
; 526  :         if (szHeader != NULL)

  00076	85 f6		 test	 esi, esi
  00078	59		 pop	 ecx
  00079	59		 pop	 ecx
  0007a	0f 84 eb 00 00
	00		 je	 $L57032

; 527  :         {
; 528  :             // add the line to the proper count if it fits the profile
; 529  :             if (strcmp(szHeader, x_szVertex) == 0)

  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?x_szVertex@GXU@@3PBDB ; GXU::x_szVertex
  00086	8b fe		 mov	 edi, esi
$L57020:
  00088	8a 07		 mov	 al, BYTE PTR [edi]
  0008a	8a d0		 mov	 dl, al
  0008c	3a 01		 cmp	 al, BYTE PTR [ecx]
  0008e	75 1a		 jne	 SHORT $L57021
  00090	84 d2		 test	 dl, dl
  00092	74 12		 je	 SHORT $L57022
  00094	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00097	8a d0		 mov	 dl, al
  00099	3a 41 01	 cmp	 al, BYTE PTR [ecx+1]
  0009c	75 0c		 jne	 SHORT $L57021
  0009e	47		 inc	 edi
  0009f	47		 inc	 edi
  000a0	41		 inc	 ecx
  000a1	41		 inc	 ecx
  000a2	84 d2		 test	 dl, dl
  000a4	75 e2		 jne	 SHORT $L57020
$L57022:
  000a6	33 c9		 xor	 ecx, ecx
  000a8	eb 05		 jmp	 SHORT $L57023
$L57021:
  000aa	1b c9		 sbb	 ecx, ecx
  000ac	83 d9 ff	 sbb	 ecx, -1
$L57023:
  000af	85 c9		 test	 ecx, ecx
  000b1	75 2e		 jne	 SHORT $L56639

; 530  :             {
; 531  :                 szValue = strtok( NULL, x_szSeparators );

  000b3	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  000b9	51		 push	 ecx
  000ba	e8 00 00 00 00	 call	 _strtok

; 532  :                 if (szValue == NULL)

  000bf	85 c0		 test	 eax, eax
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
  000c3	0f 84 d7 00 00
	00		 je	 $L57019

; 533  :                 {
; 534  :                     hr = E_FAIL;
; 535  :                     goto e_Exit;
; 536  :                 }
; 537  : 
; 538  :                 cNewValue = atol(szValue);

  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _atol

; 539  :                 if (cVertices < cNewValue)

  000cf	39 45 d8	 cmp	 DWORD PTR _cVertices$[ebp], eax
  000d2	59		 pop	 ecx
  000d3	0f 83 92 00 00
	00		 jae	 $L57032

; 540  :                     cVertices = cNewValue;

  000d9	89 45 d8	 mov	 DWORD PTR _cVertices$[ebp], eax

; 541  :             }
; 542  :             else if (strcmp(szHeader, x_szFace) == 0)

  000dc	e9 8a 00 00 00	 jmp	 $L57032
$L56639:
  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?x_szFace@GXU@@3PBDB ; GXU::x_szFace
  000e7	8b fe		 mov	 edi, esi
$L57024:
  000e9	8a 07		 mov	 al, BYTE PTR [edi]
  000eb	8a d0		 mov	 dl, al
  000ed	3a 01		 cmp	 al, BYTE PTR [ecx]
  000ef	75 1a		 jne	 SHORT $L57025
  000f1	84 d2		 test	 dl, dl
  000f3	74 12		 je	 SHORT $L57026
  000f5	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  000f8	8a d0		 mov	 dl, al
  000fa	3a 41 01	 cmp	 al, BYTE PTR [ecx+1]
  000fd	75 0c		 jne	 SHORT $L57025
  000ff	47		 inc	 edi
  00100	47		 inc	 edi
  00101	41		 inc	 ecx
  00102	41		 inc	 ecx
  00103	84 d2		 test	 dl, dl
  00105	75 e2		 jne	 SHORT $L57024
$L57026:
  00107	33 c9		 xor	 ecx, ecx
  00109	eb 05		 jmp	 SHORT $L57027
$L57025:
  0010b	1b c9		 sbb	 ecx, ecx
  0010d	83 d9 ff	 sbb	 ecx, -1
$L57027:
  00110	85 c9		 test	 ecx, ecx
  00112	75 23		 jne	 SHORT $L56645

; 543  :             {
; 544  :                 szValue = strtok( NULL, x_szSeparators );

  00114	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  0011a	51		 push	 ecx
  0011b	e8 00 00 00 00	 call	 _strtok

; 545  :                 if (szValue == NULL)

  00120	85 c0		 test	 eax, eax
  00122	59		 pop	 ecx
  00123	59		 pop	 ecx
  00124	74 7a		 je	 SHORT $L57019

; 548  :                     goto e_Exit;
; 549  :                 }
; 550  : 
; 551  :                 cNewValue = atol(szValue);

  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 _atol

; 552  :                 if (cFaces < cNewValue)

  0012c	39 45 dc	 cmp	 DWORD PTR _cFaces$[ebp], eax
  0012f	59		 pop	 ecx
  00130	73 39		 jae	 SHORT $L57032

; 553  :                     cFaces = cNewValue;

  00132	89 45 dc	 mov	 DWORD PTR _cFaces$[ebp], eax

; 554  :             }
; 555  :             else if (strcmp(szHeader, x_szCorner) == 0)

  00135	eb 34		 jmp	 SHORT $L57032
$L56645:
  00137	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?x_szCorner@GXU@@3PBDB ; GXU::x_szCorner
$L57028:
  0013d	8a 16		 mov	 dl, BYTE PTR [esi]
  0013f	8a c2		 mov	 al, dl
  00141	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00143	75 1a		 jne	 SHORT $L57029
  00145	84 c0		 test	 al, al
  00147	74 12		 je	 SHORT $L57030
  00149	8a 56 01	 mov	 dl, BYTE PTR [esi+1]
  0014c	8a c2		 mov	 al, dl
  0014e	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00151	75 0c		 jne	 SHORT $L57029
  00153	46		 inc	 esi
  00154	46		 inc	 esi
  00155	41		 inc	 ecx
  00156	41		 inc	 ecx
  00157	84 c0		 test	 al, al
  00159	75 e2		 jne	 SHORT $L57028
$L57030:
  0015b	33 c0		 xor	 eax, eax
  0015d	eb 05		 jmp	 SHORT $L57031
$L57029:
  0015f	1b c0		 sbb	 eax, eax
  00161	83 d8 ff	 sbb	 eax, -1
$L57031:
  00164	85 c0		 test	 eax, eax
  00166	75 03		 jne	 SHORT $L57032

; 556  :             {
; 557  :                 cCorners += 1;

  00168	ff 45 e0	 inc	 DWORD PTR _cCorners$[ebp]
$L57032:

; 508  : 
; 509  :     // get the counts of the faces, vertices, etc
; 510  :     while ( 1 )
; 511  :     {
; 512  :         hr = pfc->GetLine(rgchBuf, sizeof(rgchBuf), bEOF);

  0016b	8b 4d d4	 mov	 ecx, DWORD PTR $T57010[ebp]
  0016e	8d 45 e7	 lea	 eax, DWORD PTR _bEOF$[ebp]
  00171	50		 push	 eax
  00172	6a 14		 push	 20			; 00000014H
  00174	8d 45 e8	 lea	 eax, DWORD PTR _rgchBuf$[ebp]
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 ?GetLine@CFileContext@GXU@@QAEJPADHAA_N@Z ; GXU::CFileContext::GetLine

; 513  :         if (FAILED(hr))

  0017d	85 c0		 test	 eax, eax
  0017f	0f 8d d0 fe ff
	ff		 jge	 $L57033

; 514  :         {
; 515  :             goto e_Exit;

  00185	eb 1e		 jmp	 SHORT $e_Exit$56635
$L57017:

; 558  :             }
; 559  : 
; 560  :         }
; 561  :     }
; 562  : 
; 563  :     *pcFaces = cFaces;

  00187	8b 45 dc	 mov	 eax, DWORD PTR _cFaces$[ebp]

; 564  :     *pcVertices = cVertices;
; 565  :     *pcCorners = cCorners;
; 566  : 
; 567  :     // rewind
; 568  :     hr = pfc->Rewind();

  0018a	8b 4d d4	 mov	 ecx, DWORD PTR $T57010[ebp]
  0018d	89 06		 mov	 DWORD PTR [esi], eax
  0018f	8b 45 d8	 mov	 eax, DWORD PTR _cVertices$[ebp]
  00192	89 03		 mov	 DWORD PTR [ebx], eax
  00194	8b 45 e0	 mov	 eax, DWORD PTR _cCorners$[ebp]
  00197	89 07		 mov	 DWORD PTR [edi], eax
  00199	e8 00 00 00 00	 call	 ?Rewind@CFileContext@GXU@@QAEJXZ ; GXU::CFileContext::Rewind

; 569  :     if (FAILED(hr))
; 570  :         goto e_Exit;
; 571  : 
; 572  : e_Exit:

  0019e	eb 05		 jmp	 SHORT $e_Exit$56635
$L57019:

; 546  :                 {
; 547  :                     hr = E_FAIL;

  001a0	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$e_Exit$56635:

; 573  :     return hr;
; 574  : }

  001a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a8	5f		 pop	 edi
  001a9	5e		 pop	 esi
  001aa	5b		 pop	 ebx
  001ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b0	c9		 leave
  001b1	c3		 ret	 0
?LoadCounts@GXU@@YAJPAVCFileContext@1@PAI11@Z ENDP	; GXU::LoadCounts
_TEXT	ENDS
PUBLIC	?LoadVertex@GXU@@YAJPADPAUSLoadVertex@1@IAA_N@Z	; GXU::LoadVertex
EXTRN	_atof:NEAR
; Function compile flags: /Ogs
;	COMDAT ?LoadVertex@GXU@@YAJPADPAUSLoadVertex@1@IAA_N@Z
_TEXT	SEGMENT
_ParseArgs$56694 = -96					; size = 68
$T57038 = -28						; size = 12
$T57042 = -16						; size = 4
_szPointX$ = -12					; size = 4
$T57043 = -8						; size = 4
_szPointY$ = -8						; size = 4
_hr$ = -4						; size = 4
_szLineBuf$ = 8						; size = 4
_rglvVertices$ = 12					; size = 4
_cVertices$ = 16					; size = 4
_bNormalFound$ = 20					; size = 4
?LoadVertex@GXU@@YAJPADPAUSLoadVertex@1@IAA_N@Z PROC NEAR ; GXU::LoadVertex, COMDAT

; 673  : }

  00000	8b ff		 npad	 2

; 579  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 60	 sub	 esp, 96			; 00000060H
  00008	56		 push	 esi
  00009	57		 push	 edi

; 580  :     HRESULT hr = S_OK;
; 581  :     char *szToken;
; 582  :     char *szPointId;
; 583  :     char *szPointX;
; 584  :     char *szPointY;
; 585  :     char *szPointZ;
; 586  :     char *szHeader;
; 587  :     UINT ulPointId;
; 588  :     UINT iOptionalArg;
; 589  : 
; 590  : 
; 591  :     // the header should always be present, checked before calling this function
; 592  :     szHeader = strtok( szLineBuf, x_szSeparators );

  0000a	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  00010	33 ff		 xor	 edi, edi
  00012	ff 75 08	 push	 DWORD PTR _szLineBuf$[ebp]
  00015	89 7d fc	 mov	 DWORD PTR _hr$[ebp], edi
  00018	e8 00 00 00 00	 call	 _strtok

; 593  :     GXASSERT((szHeader != NULL) && strcmp(szHeader, x_szVertex) == 0);
; 594  : 
; 595  :     // get the number for the count
; 596  :     szPointId = strtok( NULL, x_szSeparators );

  0001d	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  00023	57		 push	 edi
  00024	e8 00 00 00 00	 call	 _strtok
  00029	8b f0		 mov	 esi, eax
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 597  :     if (szPointId == NULL)

  0002e	3b f7		 cmp	 esi, edi
  00030	75 0c		 jne	 SHORT $L56672
$L57059:

; 598  :     {
; 599  :         hr = E_FAIL;

  00032	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 600  :         goto e_Exit;

  00039	e9 33 01 00 00	 jmp	 $e_Exit$56674
$L56672:

; 601  :     }
; 602  : 
; 603  :     // load the various parts of the vertex from the strings
; 604  :     szPointX = strtok( NULL, x_szSeparators );

  0003e	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  00044	57		 push	 edi
  00045	e8 00 00 00 00	 call	 _strtok

; 605  :     if (szPointX == NULL)

  0004a	3b c7		 cmp	 eax, edi
  0004c	59		 pop	 ecx
  0004d	59		 pop	 ecx
  0004e	89 45 f4	 mov	 DWORD PTR _szPointX$[ebp], eax

; 666  :                     goto e_Exit;
; 667  :             }
; 668  :         }
; 669  :     }
; 670  : 
; 671  : e_Exit:

  00051	74 df		 je	 SHORT $L57059
  00053	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  00059	57		 push	 edi
  0005a	e8 00 00 00 00	 call	 _strtok
  0005f	3b c7		 cmp	 eax, edi
  00061	59		 pop	 ecx
  00062	59		 pop	 ecx
  00063	89 45 f8	 mov	 DWORD PTR _szPointY$[ebp], eax
  00066	74 ca		 je	 SHORT $L57059
  00068	53		 push	 ebx
  00069	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  0006f	57		 push	 edi
  00070	e8 00 00 00 00	 call	 _strtok
  00075	8b d8		 mov	 ebx, eax
  00077	3b df		 cmp	 ebx, edi
  00079	59		 pop	 ecx
  0007a	59		 pop	 ecx
  0007b	0f 84 e8 00 00
	00		 je	 $L56686
  00081	56		 push	 esi
  00082	e8 00 00 00 00	 call	 _atoi
  00087	8b f0		 mov	 esi, eax
  00089	3b f7		 cmp	 esi, edi
  0008b	59		 pop	 ecx
  0008c	0f 84 d7 00 00
	00		 je	 $L56686

; 606  :     {
; 607  :         hr = E_FAIL;
; 608  :         goto e_Exit;
; 609  :     }
; 610  : 
; 611  :     szPointY = strtok( NULL, x_szSeparators );
; 612  :     if (szPointY == NULL)
; 613  :     {
; 614  :         hr = E_FAIL;
; 615  :         goto e_Exit;
; 616  :     }
; 617  : 
; 618  :     szPointZ = strtok( NULL, x_szSeparators );
; 619  :     if (szPointZ == NULL)
; 620  :     {
; 621  :         hr = E_FAIL;
; 622  :         goto e_Exit;
; 623  :     }
; 624  : 
; 625  :     ulPointId = atoi(szPointId);
; 626  :     if ((ulPointId == 0) || (ulPointId > cVertices))

  00092	3b 75 10	 cmp	 esi, DWORD PTR _cVertices$[ebp]
  00095	0f 87 ce 00 00
	00		 ja	 $L56686

; 629  :         goto e_Exit;
; 630  :     }
; 631  : 
; 632  :     // convert from one based to zero based
; 633  :     ulPointId -= 1;
; 634  : 
; 635  :     // UNDONE - handle errors by not using atof
; 636  :     rglvVertices[ulPointId].m_vPos = D3DXVECTOR3((float)atof(szPointX), (float)atof(szPointY), (float)atof(szPointZ));

  0009b	53		 push	 ebx
  0009c	4e		 dec	 esi
  0009d	e8 00 00 00 00	 call	 _atof
  000a2	d9 5d f0	 fstp	 DWORD PTR $T57042[ebp]
  000a5	ff 75 f8	 push	 DWORD PTR _szPointY$[ebp]
  000a8	e8 00 00 00 00	 call	 _atof
  000ad	d9 5d f8	 fstp	 DWORD PTR $T57043[ebp]
  000b0	ff 75 f4	 push	 DWORD PTR _szPointX$[ebp]
  000b3	e8 00 00 00 00	 call	 _atof
  000b8	6b f6 44	 imul	 esi, 68			; 00000044H
  000bb	d9 5d e4	 fstp	 DWORD PTR $T57038[ebp]
  000be	8b 45 f8	 mov	 eax, DWORD PTR $T57043[ebp]
  000c1	89 45 e8	 mov	 DWORD PTR $T57038[ebp+4], eax
  000c4	8b 45 f0	 mov	 eax, DWORD PTR $T57042[ebp]
  000c7	89 45 ec	 mov	 DWORD PTR $T57038[ebp+8], eax
  000ca	8b 45 0c	 mov	 eax, DWORD PTR _rglvVertices$[ebp]
  000cd	8d 1c 06	 lea	 ebx, DWORD PTR [esi+eax]
  000d0	8d 75 e4	 lea	 esi, DWORD PTR $T57038[ebp]
  000d3	8b fb		 mov	 edi, ebx
  000d5	a5		 movsd
  000d6	a5		 movsd
  000d7	a5		 movsd

; 637  : 
; 638  :     // look optional information
; 639  :     szToken = strtok( NULL, "}" );

  000d8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01CELHOKLL@?$HN?$AA@
  000dd	33 ff		 xor	 edi, edi
  000df	57		 push	 edi
  000e0	e8 00 00 00 00	 call	 _strtok
  000e5	83 c4 14	 add	 esp, 20			; 00000014H

; 640  :     if (szToken != NULL)

  000e8	3b c7		 cmp	 eax, edi
  000ea	0f 84 80 00 00
	00		 je	 $L57058

; 641  :     {
; 642  :         CParseOptionalArgs ParseArgs;
; 643  : 
; 644  :         // parse the optional information, into an wonder of all wonders, a readable form
; 645  :         hr = ParseArgs.Parse(szToken);

  000f0	50		 push	 eax
  000f1	8d 4d a0	 lea	 ecx, DWORD PTR _ParseArgs$56694[ebp]
  000f4	89 7d e0	 mov	 DWORD PTR _ParseArgs$56694[ebp+64], edi
  000f7	e8 00 00 00 00	 call	 ?Parse@CParseOptionalArgs@GXU@@QAEJPAD@Z ; GXU::CParseOptionalArgs::Parse

; 646  :         if (FAILED(hr))

  000fc	3b c7		 cmp	 eax, edi
  000fe	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00101	7c 6d		 jl	 SHORT $L57058

; 647  :         {
; 648  :             goto e_Exit;
; 649  :         }
; 650  : 
; 651  :         // loop over all the args, getting the info for the understood items
; 652  :         for (iOptionalArg = 0; iOptionalArg < ParseArgs.COptionalArgs(); iOptionalArg++)

  00103	39 7d e0	 cmp	 DWORD PTR _ParseArgs$56694[ebp+64], edi
  00106	76 68		 jbe	 SHORT $L57058
$L57057:

; 653  :         {
; 654  :             if (ParseArgs.BCompareArg(iOptionalArg, x_szNormal))

  00108	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szNormal@GXU@@3PBDB ; GXU::x_szNormal
  0010e	8d 4d a0	 lea	 ecx, DWORD PTR _ParseArgs$56694[ebp]
  00111	57		 push	 edi
  00112	e8 00 00 00 00	 call	 ?BCompareArg@CParseOptionalArgs@GXU@@QAE_NIPBD@Z ; GXU::CParseOptionalArgs::BCompareArg
  00117	84 c0		 test	 al, al

; 655  :             {
; 656  :                 hr = ParseArgs.GetCoVector3(iOptionalArg, &rglvVertices[ulPointId].m_vNormal);

  00119	8d 4d a0	 lea	 ecx, DWORD PTR _ParseArgs$56694[ebp]
  0011c	74 1f		 je	 SHORT $L56701
  0011e	8d 73 24	 lea	 esi, DWORD PTR [ebx+36]
  00121	56		 push	 esi
  00122	57		 push	 edi
  00123	e8 00 00 00 00	 call	 ?GetCoVector3@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR3@@@Z ; GXU::CParseOptionalArgs::GetCoVector3

; 657  :                 if (FAILED(hr))

  00128	85 c0		 test	 eax, eax
  0012a	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  0012d	7c 41		 jl	 SHORT $L57058

; 658  :                     goto e_Exit;
; 659  : 
; 660  :                 bNormalFound = NotZero(rglvVertices[ulPointId].m_vNormal);

  0012f	56		 push	 esi
  00130	e8 00 00 00 00	 call	 ?NotZero@GXU@@YA_NAAUD3DXVECTOR3@@@Z ; GXU::NotZero
  00135	59		 pop	 ecx
  00136	8b 4d 14	 mov	 ecx, DWORD PTR _bNormalFound$[ebp]
  00139	88 01		 mov	 BYTE PTR [ecx], al

; 661  :             }
; 662  :             else if (ParseArgs.BCompareArg(iOptionalArg, x_szUv))

  0013b	eb 24		 jmp	 SHORT $L56699
$L56701:
  0013d	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szUv@GXU@@3PBDB ; GXU::x_szUv
  00143	57		 push	 edi
  00144	e8 00 00 00 00	 call	 ?BCompareArg@CParseOptionalArgs@GXU@@QAE_NIPBD@Z ; GXU::CParseOptionalArgs::BCompareArg
  00149	84 c0		 test	 al, al
  0014b	74 14		 je	 SHORT $L56699

; 663  :             {
; 664  :                 hr = ParseArgs.GetPoint2(iOptionalArg, &rglvVertices[ulPointId].m_uvTex1);

  0014d	8d 43 1c	 lea	 eax, DWORD PTR [ebx+28]
  00150	50		 push	 eax
  00151	57		 push	 edi
  00152	8d 4d a0	 lea	 ecx, DWORD PTR _ParseArgs$56694[ebp]
  00155	e8 00 00 00 00	 call	 ?GetPoint2@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR2@@@Z ; GXU::CParseOptionalArgs::GetPoint2

; 665  :                 if (FAILED(hr))

  0015a	85 c0		 test	 eax, eax
  0015c	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  0015f	7c 0f		 jl	 SHORT $L57058
$L56699:

; 647  :         {
; 648  :             goto e_Exit;
; 649  :         }
; 650  : 
; 651  :         // loop over all the args, getting the info for the understood items
; 652  :         for (iOptionalArg = 0; iOptionalArg < ParseArgs.COptionalArgs(); iOptionalArg++)

  00161	47		 inc	 edi
  00162	3b 7d e0	 cmp	 edi, DWORD PTR _ParseArgs$56694[ebp+64]
  00165	72 a1		 jb	 SHORT $L57057

; 665  :                 if (FAILED(hr))

  00167	eb 07		 jmp	 SHORT $L57058
$L56686:

; 627  :     {
; 628  :         hr = E_FAIL;

  00169	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L57058:
  00170	5b		 pop	 ebx
$e_Exit$56674:

; 672  :     return hr;

  00171	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00174	5f		 pop	 edi
  00175	5e		 pop	 esi

; 673  : }

  00176	c9		 leave
  00177	c3		 ret	 0
?LoadVertex@GXU@@YAJPADPAUSLoadVertex@1@IAA_N@Z ENDP	; GXU::LoadVertex
_TEXT	ENDS
PUBLIC	?LoadFace@GXU@@YAJPADIPAUSLoadedFace@1@@Z	; GXU::LoadFace
PUBLIC	??_C@_02KGHIDFGE@?$HN?6?$AA@			; `string'
;	COMDAT ??_C@_02KGHIDFGE@?$HN?6?$AA@
CONST	SEGMENT
??_C@_02KGHIDFGE@?$HN?6?$AA@ DB '}', 0aH, 00H		; `string'
; Function compile flags: /Ogs
CONST	ENDS
;	COMDAT ?LoadFace@GXU@@YAJPADIPAUSLoadedFace@1@@Z
_TEXT	SEGMENT
_ParseArgs$56746 = -76					; size = 68
$T57061 = -52						; size = 44
_szPoint1$ = -8						; size = 4
_hr$ = -4						; size = 4
_szLineBuf$ = 8						; size = 4
_cFacesMax$ = 12					; size = 4
_rgFaces$ = 16						; size = 4
?LoadFace@GXU@@YAJPADIPAUSLoadedFace@1@@Z PROC NEAR	; GXU::LoadFace, COMDAT

; 775  : }

  00000	8b ff		 npad	 2

; 677  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00008	56		 push	 esi
  00009	57		 push	 edi

; 678  :     HRESULT hr = S_OK;
; 679  :     char *szToken;
; 680  :     char *szFaceId;
; 681  :     char *szPoint1;
; 682  :     char *szPoint2;
; 683  :     char *szPoint3;
; 684  :     char *szHeader;
; 685  :     UINT ulFaceId;
; 686  :     UINT iOptionalArg;
; 687  : 
; 688  :     szHeader = strtok( szLineBuf, x_szSeparators );

  0000a	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  00010	33 f6		 xor	 esi, esi
  00012	ff 75 08	 push	 DWORD PTR _szLineBuf$[ebp]
  00015	89 75 fc	 mov	 DWORD PTR _hr$[ebp], esi
  00018	e8 00 00 00 00	 call	 _strtok

; 689  :     GXASSERT((szHeader != NULL) && strcmp(szHeader, x_szFace) == 0);
; 690  : 
; 691  : 
; 692  :     // get the number for the count
; 693  :     szFaceId = strtok( NULL, x_szSeparators );

  0001d	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 _strtok
  00029	83 c4 10	 add	 esp, 16			; 00000010H

; 694  :     if (szFaceId == NULL)

  0002c	3b c6		 cmp	 eax, esi
  0002e	75 0c		 jne	 SHORT $L56726

; 695  :     {
; 696  :         hr = E_FAIL;

  00030	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 697  :         goto e_Exit;

  00037	e9 29 01 00 00	 jmp	 $e_Exit$56728
$L56726:
  0003c	53		 push	 ebx

; 698  :     }
; 699  : 
; 700  :     ulFaceId = atoi(szFaceId) - 1;

  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _atoi
  00043	48		 dec	 eax

; 701  : 
; 702  :     // if the face id is too high, and/or the face is already in use (specified twice in file)
; 703  :     if ((ulFaceId >= cFacesMax) || (rgFaces[ulFaceId].m_wIndices[0] != UNUSED32))

  00044	3b 45 0c	 cmp	 eax, DWORD PTR _cFacesMax$[ebp]
  00047	59		 pop	 ecx
  00048	0f 83 0f 01 00
	00		 jae	 $L56731
  0004e	8b 4d 10	 mov	 ecx, DWORD PTR _rgFaces$[ebp]
  00051	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00054	8d 1c 08	 lea	 ebx, DWORD PTR [eax+ecx]
  00057	83 3b ff	 cmp	 DWORD PTR [ebx], -1
  0005a	0f 85 fd 00 00
	00		 jne	 $L56731

; 706  :         goto e_Exit;
; 707  :     }
; 708  : 
; 709  :     // load the various parts of the vertex from the strings
; 710  :     szPoint1 = strtok( NULL, x_szSeparators );

  00060	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 _strtok

; 711  :     if (szPoint1 == NULL)

  0006c	3b c6		 cmp	 eax, esi
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx
  00070	89 45 f8	 mov	 DWORD PTR _szPoint1$[ebp], eax
  00073	75 0c		 jne	 SHORT $L56734
$L57092:

; 712  :     {
; 713  :         hr = E_FAIL;

  00075	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 767  :                     goto e_Exit;
; 768  :             }
; 769  :         }
; 770  :     }
; 771  : 
; 772  : e_Exit:

  0007c	e9 e3 00 00 00	 jmp	 $L57090
$L56734:

; 714  :         goto e_Exit;
; 715  :     }
; 716  : 
; 717  :     szPoint2 = strtok( NULL, x_szSeparators );

  00081	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 _strtok
  0008d	8b f8		 mov	 edi, eax

; 718  :     if (szPoint2 == NULL)

  0008f	3b fe		 cmp	 edi, esi
  00091	59		 pop	 ecx
  00092	59		 pop	 ecx

; 767  :                     goto e_Exit;
; 768  :             }
; 769  :         }
; 770  :     }
; 771  : 
; 772  : e_Exit:

  00093	74 e0		 je	 SHORT $L57092
  00095	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  0009b	56		 push	 esi
  0009c	e8 00 00 00 00	 call	 _strtok
  000a1	3b c6		 cmp	 eax, esi
  000a3	59		 pop	 ecx
  000a4	59		 pop	 ecx
  000a5	74 ce		 je	 SHORT $L57092
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _atoi
  000ad	8b f0		 mov	 esi, eax
  000af	57		 push	 edi
  000b0	4e		 dec	 esi
  000b1	e8 00 00 00 00	 call	 _atoi
  000b6	ff 75 f8	 push	 DWORD PTR _szPoint1$[ebp]
  000b9	80 65 d8 f0	 and	 BYTE PTR $T57061[ebp+12], -16 ; fffffff0H
  000bd	8b f8		 mov	 edi, eax
  000bf	4f		 dec	 edi
  000c0	e8 00 00 00 00	 call	 _atoi
  000c5	6a 0b		 push	 11			; 0000000bH
  000c7	89 7d d0	 mov	 DWORD PTR $T57061[ebp+4], edi
  000ca	48		 dec	 eax
  000cb	89 75 d4	 mov	 DWORD PTR $T57061[ebp+8], esi
  000ce	59		 pop	 ecx
  000cf	89 45 cc	 mov	 DWORD PTR $T57061[ebp], eax
  000d2	8d 75 cc	 lea	 esi, DWORD PTR $T57061[ebp]
  000d5	8b fb		 mov	 edi, ebx
  000d7	f3 a5		 rep movsd
  000d9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02KGHIDFGE@?$HN?6?$AA@
  000de	33 ff		 xor	 edi, edi
  000e0	57		 push	 edi
  000e1	e8 00 00 00 00	 call	 _strtok
  000e6	83 c4 14	 add	 esp, 20			; 00000014H
  000e9	3b c7		 cmp	 eax, edi
  000eb	74 77		 je	 SHORT $L57090
  000ed	50		 push	 eax
  000ee	8d 4d b4	 lea	 ecx, DWORD PTR _ParseArgs$56746[ebp]
  000f1	89 7d f4	 mov	 DWORD PTR _ParseArgs$56746[ebp+64], edi
  000f4	e8 00 00 00 00	 call	 ?Parse@CParseOptionalArgs@GXU@@QAEJPAD@Z ; GXU::CParseOptionalArgs::Parse
  000f9	3b c7		 cmp	 eax, edi
  000fb	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  000fe	7c 64		 jl	 SHORT $L57090
  00100	33 f6		 xor	 esi, esi
  00102	39 7d f4	 cmp	 DWORD PTR _ParseArgs$56746[ebp+64], edi
  00105	76 5d		 jbe	 SHORT $L57090
$L56750:

; 752  :         {
; 753  :             if (ParseArgs.BCompareArg(iOptionalArg, x_szMatId))

  00107	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szMatId@GXU@@3PBDB ; GXU::x_szMatId
  0010d	8d 4d b4	 lea	 ecx, DWORD PTR _ParseArgs$56746[ebp]
  00110	56		 push	 esi
  00111	e8 00 00 00 00	 call	 ?BCompareArg@CParseOptionalArgs@GXU@@QAE_NIPBD@Z ; GXU::CParseOptionalArgs::BCompareArg
  00116	84 c0		 test	 al, al

; 754  :             {
; 755  :                 rgFaces[ulFaceId].m_bMaterialSpecified = true;
; 756  : 
; 757  :                 hr = ParseArgs.GetDWORD(iOptionalArg, &rgFaces[ulFaceId].m_matid);

  00118	8d 4d b4	 lea	 ecx, DWORD PTR _ParseArgs$56746[ebp]
  0011b	74 10		 je	 SHORT $L56753
  0011d	80 4b 0c 02	 or	 BYTE PTR [ebx+12], 2
  00121	8d 43 20	 lea	 eax, DWORD PTR [ebx+32]
  00124	50		 push	 eax
  00125	56		 push	 esi
  00126	e8 00 00 00 00	 call	 ?GetDWORD@CParseOptionalArgs@GXU@@QAEJIPAK@Z ; GXU::CParseOptionalArgs::GetDWORD

; 758  :                 if (FAILED(hr))
; 759  :                     goto e_Exit;
; 760  :             }
; 761  :             else if (ParseArgs.BCompareArg(iOptionalArg, x_szRGB))

  0012b	eb 21		 jmp	 SHORT $L57091
$L56753:
  0012d	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szRGB@GXU@@3PBDB ; GXU::x_szRGB
  00133	56		 push	 esi
  00134	e8 00 00 00 00	 call	 ?BCompareArg@CParseOptionalArgs@GXU@@QAE_NIPBD@Z ; GXU::CParseOptionalArgs::BCompareArg
  00139	84 c0		 test	 al, al
  0013b	74 18		 je	 SHORT $L56751

; 762  :             {
; 763  :                 rgFaces[ulFaceId].m_bColorSpecified = true;

  0013d	80 4b 0c 01	 or	 BYTE PTR [ebx+12], 1

; 764  : 
; 765  :                 hr = ParseArgs.GetColorRGB(iOptionalArg, &rgFaces[ulFaceId].m_colorFace);

  00141	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  00144	50		 push	 eax
  00145	56		 push	 esi
  00146	8d 4d b4	 lea	 ecx, DWORD PTR _ParseArgs$56746[ebp]
  00149	e8 00 00 00 00	 call	 ?GetColorRGB@CParseOptionalArgs@GXU@@QAEJIPAUD3DXCOLOR@@@Z ; GXU::CParseOptionalArgs::GetColorRGB
$L57091:

; 766  :                 if (FAILED(hr))

  0014e	3b c7		 cmp	 eax, edi
  00150	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00153	7c 0f		 jl	 SHORT $L57090
$L56751:

; 719  :     {
; 720  :         hr = E_FAIL;
; 721  :         goto e_Exit;
; 722  :     }
; 723  : 
; 724  :     szPoint3 = strtok( NULL, x_szSeparators );
; 725  :     if (szPoint3 == NULL)
; 726  :     {
; 727  :         hr = E_FAIL;
; 728  :         goto e_Exit;
; 729  :     }
; 730  : 
; 731  :     // UNDONE - handle errors by not using atoi
; 732  :     // NOTE: reverse the ordering of the indices... otherwise CCW ordering becomes CW ordering
; 733  :     //          when -z applied to change from right hand to left hand coordinate system
; 734  :     rgFaces[ulFaceId] = SLoadedFace(atoi(szPoint1)-1, atoi(szPoint2)-1, atoi(szPoint3)-1);
; 735  : 
; 736  : 
; 737  :     // look optional information
; 738  :     szToken = strtok( NULL, "}\n" );
; 739  :     if (szToken != NULL)
; 740  :     {
; 741  :         CParseOptionalArgs ParseArgs;
; 742  : 
; 743  :         // parse the optional information, into an wonder of all wonders, a readable form
; 744  :         hr = ParseArgs.Parse(szToken);
; 745  :         if (FAILED(hr))
; 746  :         {
; 747  :             goto e_Exit;
; 748  :         }
; 749  : 
; 750  :         // loop over all the args, getting the info for the understood items
; 751  :         for (iOptionalArg = 0; iOptionalArg < ParseArgs.COptionalArgs(); iOptionalArg++)

  00155	46		 inc	 esi
  00156	3b 75 f4	 cmp	 esi, DWORD PTR _ParseArgs$56746[ebp+64]
  00159	72 ac		 jb	 SHORT $L56750

; 766  :                 if (FAILED(hr))

  0015b	eb 07		 jmp	 SHORT $L57090
$L56731:

; 704  :     {
; 705  :         hr = E_INVALIDARG;

  0015d	c7 45 fc 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H
$L57090:
  00164	5b		 pop	 ebx
$e_Exit$56728:

; 773  : 
; 774  :     return hr;

  00165	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00168	5f		 pop	 edi
  00169	5e		 pop	 esi

; 775  : }

  0016a	c9		 leave
  0016b	c3		 ret	 0
?LoadFace@GXU@@YAJPADIPAUSLoadedFace@1@@Z ENDP		; GXU::LoadFace
_TEXT	ENDS
PUBLIC	?LoadCorner@GXU@@YAJPADIIIPAUSCorner@1@AA_N@Z	; GXU::LoadCorner
; Function compile flags: /Ogs
;	COMDAT ?LoadCorner@GXU@@YAJPADIIIPAUSCorner@1@AA_N@Z
_TEXT	SEGMENT
_ParseArgs$56792 = -72					; size = 68
_hr$ = -4						; size = 4
_szLineBuf$ = 8						; size = 4
_iCorner$ = 12						; size = 4
_cVertices$ = 16					; size = 4
_cFaces$ = 20						; size = 4
_rgCorners$ = 24					; size = 4
_bNormalFound$ = 28					; size = 4
?LoadCorner@GXU@@YAJPADIIIPAUSCorner@1@AA_N@Z PROC NEAR	; GXU::LoadCorner, COMDAT

; 862  : }

  00000	8b ff		 npad	 2

; 779  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 48	 sub	 esp, 72			; 00000048H
  00008	53		 push	 ebx
  00009	56		 push	 esi

; 780  :     HRESULT hr = S_OK;
; 781  :     char *szToken;
; 782  :     char *szFaceId;
; 783  :     char *szPointId;
; 784  :     char *szHeader;
; 785  :     UINT ulFaceId;
; 786  :     UINT ulPointId;
; 787  :     UINT iOptionalArg;
; 788  : 
; 789  :     szHeader = strtok( szLineBuf, x_szSeparators );

  0000a	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  00010	33 db		 xor	 ebx, ebx
  00012	ff 75 08	 push	 DWORD PTR _szLineBuf$[ebp]
  00015	89 5d fc	 mov	 DWORD PTR _hr$[ebp], ebx
  00018	e8 00 00 00 00	 call	 _strtok

; 790  :     GXASSERT((szHeader != NULL) && strcmp(szHeader, x_szCorner) == 0);
; 791  : 
; 792  : 
; 793  :     // get the number for the count
; 794  :     szPointId = strtok( NULL, x_szSeparators );

  0001d	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  00023	53		 push	 ebx
  00024	e8 00 00 00 00	 call	 _strtok
  00029	8b f0		 mov	 esi, eax
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 795  :     if (szPointId == NULL)

  0002e	3b f3		 cmp	 esi, ebx
  00030	75 0c		 jne	 SHORT $L56780
$L57108:

; 796  :     {
; 797  :         hr = E_FAIL;

  00032	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 798  :         goto e_Exit;

  00039	e9 e7 00 00 00	 jmp	 $e_Exit$56782
$L56780:

; 799  :     }
; 800  : 
; 801  :     szFaceId = strtok( NULL, x_szSeparators );

  0003e	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szSeparators@GXU@@3PBDB ; GXU::x_szSeparators
  00044	53		 push	 ebx
  00045	e8 00 00 00 00	 call	 _strtok

; 802  :     if (szFaceId == NULL)

  0004a	3b c3		 cmp	 eax, ebx
  0004c	59		 pop	 ecx
  0004d	59		 pop	 ecx

; 854  :                     goto e_Exit;
; 855  :             }
; 856  :         }
; 857  :     }
; 858  : 
; 859  : e_Exit:

  0004e	74 e2		 je	 SHORT $L57108
  00050	57		 push	 edi
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _atoi
  00057	8b f8		 mov	 edi, eax
  00059	56		 push	 esi
  0005a	4f		 dec	 edi
  0005b	e8 00 00 00 00	 call	 _atoi
  00060	59		 pop	 ecx
  00061	48		 dec	 eax
  00062	3b 7d 14	 cmp	 edi, DWORD PTR _cFaces$[ebp]
  00065	59		 pop	 ecx
  00066	0f 83 b1 00 00
	00		 jae	 $L56788

; 803  :     {
; 804  :         hr = E_FAIL;
; 805  :         goto e_Exit;
; 806  :     }
; 807  : 
; 808  :     ulFaceId = atoi(szFaceId) - 1;
; 809  :     ulPointId = atoi(szPointId) - 1;
; 810  : 
; 811  :     if ((ulFaceId >= cFaces) || (ulPointId > cVertices))

  0006c	3b 45 10	 cmp	 eax, DWORD PTR _cVertices$[ebp]
  0006f	0f 87 a8 00 00
	00		 ja	 $L56788

; 814  :         goto e_Exit;
; 815  :     }
; 816  : 
; 817  :     rgCorners[iCorner].m_wFace = ulFaceId;

  00075	8b 4d 0c	 mov	 ecx, DWORD PTR _iCorner$[ebp]
  00078	8b 55 18	 mov	 edx, DWORD PTR _rgCorners$[ebp]
  0007b	c1 e1 05	 shl	 ecx, 5
  0007e	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]

; 818  :     rgCorners[iCorner].m_wPoint = ulPointId;
; 819  : 
; 820  : 
; 821  :     // look optional information
; 822  :     szToken = strtok( NULL, "}\n" );

  00081	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02KGHIDFGE@?$HN?6?$AA@
  00086	53		 push	 ebx
  00087	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0008a	89 06		 mov	 DWORD PTR [esi], eax
  0008c	e8 00 00 00 00	 call	 _strtok

; 823  :     if (szToken != NULL)

  00091	3b c3		 cmp	 eax, ebx
  00093	59		 pop	 ecx
  00094	59		 pop	 ecx
  00095	0f 84 89 00 00
	00		 je	 $L57107

; 824  :     {
; 825  :         CParseOptionalArgs ParseArgs;
; 826  : 
; 827  :         // parse the optional information, into an wonder of all wonders, a readable form
; 828  :         hr = ParseArgs.Parse(szToken);

  0009b	50		 push	 eax
  0009c	8d 4d b8	 lea	 ecx, DWORD PTR _ParseArgs$56792[ebp]
  0009f	89 5d f8	 mov	 DWORD PTR _ParseArgs$56792[ebp+64], ebx
  000a2	e8 00 00 00 00	 call	 ?Parse@CParseOptionalArgs@GXU@@QAEJPAD@Z ; GXU::CParseOptionalArgs::Parse

; 829  :         if (FAILED(hr))

  000a7	3b c3		 cmp	 eax, ebx
  000a9	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  000ac	7c 76		 jl	 SHORT $L57107

; 830  :         {
; 831  :             goto e_Exit;
; 832  :         }
; 833  : 
; 834  :         // loop over all the args, getting the info for the understood items
; 835  :         for (iOptionalArg = 0; iOptionalArg < ParseArgs.COptionalArgs(); iOptionalArg++)

  000ae	83 7d f8 00	 cmp	 DWORD PTR _ParseArgs$56792[ebp+64], 0
  000b2	76 70		 jbe	 SHORT $L57107
$L57106:

; 836  :         {
; 837  : 
; 838  :             if (ParseArgs.BCompareArg(iOptionalArg, x_szNormal))

  000b4	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szNormal@GXU@@3PBDB ; GXU::x_szNormal
  000ba	8d 4d b8	 lea	 ecx, DWORD PTR _ParseArgs$56792[ebp]
  000bd	53		 push	 ebx
  000be	e8 00 00 00 00	 call	 ?BCompareArg@CParseOptionalArgs@GXU@@QAE_NIPBD@Z ; GXU::CParseOptionalArgs::BCompareArg
  000c3	84 c0		 test	 al, al

; 839  :             {
; 840  :                 rgCorners[iCorner].m_bNormalSpecified = true;
; 841  : 
; 842  :                 hr = ParseArgs.GetCoVector3(iOptionalArg, &rgCorners[iCorner].m_vNormal);

  000c5	8d 4d b8	 lea	 ecx, DWORD PTR _ParseArgs$56792[ebp]
  000c8	74 23		 je	 SHORT $L56799
  000ca	80 4e 08 01	 or	 BYTE PTR [esi+8], 1
  000ce	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]
  000d1	57		 push	 edi
  000d2	53		 push	 ebx
  000d3	e8 00 00 00 00	 call	 ?GetCoVector3@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR3@@@Z ; GXU::CParseOptionalArgs::GetCoVector3

; 843  :                 if (FAILED(hr))

  000d8	85 c0		 test	 eax, eax
  000da	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  000dd	7c 45		 jl	 SHORT $L57107

; 844  :                     goto e_Exit;
; 845  : 
; 846  :                 bNormalFound = NotZero(rgCorners[iCorner].m_vNormal);

  000df	57		 push	 edi
  000e0	e8 00 00 00 00	 call	 ?NotZero@GXU@@YA_NAAUD3DXVECTOR3@@@Z ; GXU::NotZero
  000e5	59		 pop	 ecx
  000e6	8b 4d 1c	 mov	 ecx, DWORD PTR _bNormalFound$[ebp]
  000e9	88 01		 mov	 BYTE PTR [ecx], al

; 847  :             }
; 848  :             else if (ParseArgs.BCompareArg(iOptionalArg, x_szUv))

  000eb	eb 28		 jmp	 SHORT $L56797
$L56799:
  000ed	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szUv@GXU@@3PBDB ; GXU::x_szUv
  000f3	53		 push	 ebx
  000f4	e8 00 00 00 00	 call	 ?BCompareArg@CParseOptionalArgs@GXU@@QAE_NIPBD@Z ; GXU::CParseOptionalArgs::BCompareArg
  000f9	84 c0		 test	 al, al
  000fb	74 18		 je	 SHORT $L56797

; 849  :             {
; 850  :                 rgCorners[iCorner].m_bUvSpecified = true;

  000fd	80 4e 08 02	 or	 BYTE PTR [esi+8], 2

; 851  : 
; 852  :                 hr = ParseArgs.GetPoint2(iOptionalArg, &rgCorners[iCorner].m_uvTex1);

  00101	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00104	50		 push	 eax
  00105	53		 push	 ebx
  00106	8d 4d b8	 lea	 ecx, DWORD PTR _ParseArgs$56792[ebp]
  00109	e8 00 00 00 00	 call	 ?GetPoint2@CParseOptionalArgs@GXU@@QAEJIPAUD3DXVECTOR2@@@Z ; GXU::CParseOptionalArgs::GetPoint2

; 853  :                 if (FAILED(hr))

  0010e	85 c0		 test	 eax, eax
  00110	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00113	7c 0f		 jl	 SHORT $L57107
$L56797:

; 830  :         {
; 831  :             goto e_Exit;
; 832  :         }
; 833  : 
; 834  :         // loop over all the args, getting the info for the understood items
; 835  :         for (iOptionalArg = 0; iOptionalArg < ParseArgs.COptionalArgs(); iOptionalArg++)

  00115	43		 inc	 ebx
  00116	3b 5d f8	 cmp	 ebx, DWORD PTR _ParseArgs$56792[ebp+64]
  00119	72 99		 jb	 SHORT $L57106

; 853  :                 if (FAILED(hr))

  0011b	eb 07		 jmp	 SHORT $L57107
$L56788:

; 812  :     {
; 813  :         hr = E_INVALIDARG;

  0011d	c7 45 fc 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H
$L57107:
  00124	5f		 pop	 edi
$e_Exit$56782:

; 860  : 
; 861  :     return hr;

  00125	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx

; 862  : }

  0012a	c9		 leave
  0012b	c3		 ret	 0
?LoadCorner@GXU@@YAJPADIIIPAUSCorner@1@AA_N@Z ENDP	; GXU::LoadCorner
_TEXT	ENDS
PUBLIC	?LoadMeshFromM@GXU@@YGJPAUIStream@@KKPAUIDirect3DDevice9@@PAPAUID3DXMesh@@PAPAUID3DXBuffer@@@Z ; GXU::LoadMeshFromM
EXTRN	?SetMesh@GXU@@YAJAAPAUSLoadedFace@1@KAAPAUSLoadVertex@1@KPAUSCorner@1@KPAUSFVFData@1@HPAKKKPAUIDirect3DDevice9@@PAPAUID3DXMesh@@PAPAUID3DXBuffer@@@Z:NEAR ; GXU::SetMesh
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	?InitVertices@GXU@@YAJAAPAUSLoadVertex@1@K@Z:NEAR ; GXU::InitVertices
EXTRN	?InitCorners@GXU@@YAJAAPAUSCorner@1@K@Z:NEAR	; GXU::InitCorners
EXTRN	?InitFaces@GXU@@YAJAAPAUSLoadedFace@1@K@Z:NEAR	; GXU::InitFaces
; Function compile flags: /Ogs
;	COMDAT ?LoadMeshFromM@GXU@@YGJPAUIStream@@KKPAUIDirect3DDevice9@@PAPAUID3DXMesh@@PAPAUID3DXBuffer@@@Z
_TEXT	SEGMENT
$T57111 = -592						; size = 16
$T57121 = -576						; size = 4
$T57120 = -572						; size = 4
$T57119 = -568						; size = 4
_cCorners$ = -564					; size = 4
_iCorner$ = -560					; size = 4
_rgCorners$ = -556					; size = 4
_cVertices$ = -552					; size = 4
_rglvLoaded$ = -548					; size = 4
_rglfFaces$ = -544					; size = 4
_cFaces$ = -540						; size = 4
_bEOF$ = -534						; size = 1
_bNormalFound$ = -533					; size = 1
_fc$ = -532						; size = 272
_rgchBuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pstream$ = 8						; size = 4
_options$ = 12						; size = 4
_fvf$ = 16						; size = 4
_pD3DDevice$ = 20					; size = 4
_ppMesh$ = 24						; size = 4
_ppbufAdjacency$ = 28					; size = 4
?LoadMeshFromM@GXU@@YGJPAUIStream@@KKPAUIDirect3DDevice9@@PAPAUID3DXMesh@@PAPAUID3DXBuffer@@@Z PROC NEAR ; GXU::LoadMeshFromM, COMDAT

; 1057 : 
; 1058 :     return hr;
; 1059 : }

  00000	8b ff		 npad	 2

; 868  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 50 02 00
	00		 sub	 esp, 592		; 00000250H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	53		 push	 ebx
  00011	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 869  :     HRESULT hr = S_OK;
; 870  :     UINT cVertices;
; 871  :     UINT cCorners;
; 872  :     UINT cFaces;
; 873  :     UINT iVert;
; 874  :     bool bNormalFound = false;
; 875  :     UINT iFace;
; 876  : 
; 877  :     SLoadedFace        *rglfFaces = NULL;
; 878  :     SLoadVertex *rglvLoaded = NULL;
; 879  :     SCorner *rgCorners = NULL;
; 880  : 
; 881  :     bool bEOF;
; 882  :     UINT iCorner = 0;

  00014	8b 45 14	 mov	 eax, DWORD PTR _pD3DDevice$[ebp]
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _pstream$[ebp]
  0001b	33 db		 xor	 ebx, ebx
  0001d	57		 push	 edi
  0001e	8b 7d 18	 mov	 edi, DWORD PTR _ppMesh$[ebp]
  00021	89 85 c8 fd ff
	ff		 mov	 DWORD PTR $T57119[ebp], eax
  00027	8b 45 1c	 mov	 eax, DWORD PTR _ppbufAdjacency$[ebp]

; 883  :     CFileContext fc(pstream);

  0002a	56		 push	 esi
  0002b	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _fc$[ebp]
  00031	89 bd c4 fd ff
	ff		 mov	 DWORD PTR $T57120[ebp], edi
  00037	89 85 c0 fd ff
	ff		 mov	 DWORD PTR $T57121[ebp], eax
  0003d	88 9d eb fd ff
	ff		 mov	 BYTE PTR _bNormalFound$[ebp], bl
  00043	89 9d e0 fd ff
	ff		 mov	 DWORD PTR _rglfFaces$[ebp], ebx
  00049	89 9d dc fd ff
	ff		 mov	 DWORD PTR _rglvLoaded$[ebp], ebx
  0004f	89 9d d4 fd ff
	ff		 mov	 DWORD PTR _rgCorners$[ebp], ebx
  00055	89 9d d0 fd ff
	ff		 mov	 DWORD PTR _iCorner$[ebp], ebx
  0005b	e8 00 00 00 00	 call	 ??0CFileContext@GXU@@QAE@PAUIStream@@@Z ; GXU::CFileContext::CFileContext

; 884  : 
; 885  :     char rgchBuf[256];
; 886  : 
; 887  : #if 0 // color attribute bundle testing
; 888  :     //IGXAttributeBundle *pattrColor;
; 889  :     //IGXAttributeBundle **rgBundles = NULL;
; 890  :     UINT cBundles = 0;
; 891  :     UINT cBundlesMax = 0;
; 892  :     D3DXCOLOR *rgColors = NULL;
; 893  :     UINT cColors = 0;
; 894  :     UINT cColorsMax = 0;
; 895  :     UINT iColor;
; 896  :     const D3DXCOLOR colorGrey(0.5f, 0.5f, 0.5f, 0.0f);
; 897  : #endif
; 898  : 
; 899  :     if ((ppMesh == NULL) || (pstream == NULL))

  00060	3b fb		 cmp	 edi, ebx
  00062	0f 84 88 02 00
	00		 je	 $L56832
  00068	3b f3		 cmp	 esi, ebx
  0006a	0f 84 80 02 00
	00		 je	 $L56832

; 902  :         goto e_Exit;
; 903  :     }
; 904  : 
; 905  :     hr = LoadCounts(&fc, &cVertices, &cFaces, &cCorners);

  00070	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _cCorners$[ebp]
  00076	50		 push	 eax
  00077	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _cFaces$[ebp]
  0007d	50		 push	 eax
  0007e	8d 85 d8 fd ff
	ff		 lea	 eax, DWORD PTR _cVertices$[ebp]
  00084	50		 push	 eax
  00085	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _fc$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ?LoadCounts@GXU@@YAJPAVCFileContext@1@PAI11@Z ; GXU::LoadCounts
  00091	8b f0		 mov	 esi, eax
  00093	83 c4 10	 add	 esp, 16			; 00000010H

; 906  :     if (FAILED(hr))

  00096	3b f3		 cmp	 esi, ebx
  00098	0f 8c 57 02 00
	00		 jl	 $e_Exit$56834

; 907  :         goto e_Exit;
; 908  : 
; 909  :     if ((cVertices == 0) || (cFaces == 0))

  0009e	8b bd d8 fd ff
	ff		 mov	 edi, DWORD PTR _cVertices$[ebp]
  000a4	3b fb		 cmp	 edi, ebx
  000a6	0f 84 44 02 00
	00		 je	 $L56832
  000ac	39 9d e4 fd ff
	ff		 cmp	 DWORD PTR _cFaces$[ebp], ebx
  000b2	0f 84 38 02 00
	00		 je	 $L56832

; 910  :     {
; 911  :         hr = E_INVALIDARG;
; 912  :         goto e_Exit;
; 913  :     }
; 914  : 
; 915  :     // allocate memory to load data into
; 916  : 
; 917  :     hr = InitVertices(rglvLoaded, cVertices);

  000b8	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _rglvLoaded$[ebp]
  000be	57		 push	 edi
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ?InitVertices@GXU@@YAJAAPAUSLoadVertex@1@K@Z ; GXU::InitVertices
  000c5	8b f0		 mov	 esi, eax

; 918  :     if (FAILED(hr))

  000c7	3b f3		 cmp	 esi, ebx
  000c9	59		 pop	 ecx
  000ca	59		 pop	 ecx
  000cb	0f 8c 24 02 00
	00		 jl	 $e_Exit$56834

; 919  :         goto e_Exit;
; 920  : 
; 921  :     hr = InitFaces(rglfFaces, cFaces);

  000d1	ff b5 e4 fd ff
	ff		 push	 DWORD PTR _cFaces$[ebp]
  000d7	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _rglfFaces$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 ?InitFaces@GXU@@YAJAAPAUSLoadedFace@1@K@Z ; GXU::InitFaces
  000e3	8b f0		 mov	 esi, eax

; 922  :     if (FAILED(hr))

  000e5	3b f3		 cmp	 esi, ebx
  000e7	59		 pop	 ecx
  000e8	59		 pop	 ecx
  000e9	0f 8c 06 02 00
	00		 jl	 $e_Exit$56834

; 923  :         goto e_Exit;
; 924  : 
; 925  :     hr = InitCorners(rgCorners, cCorners);

  000ef	ff b5 cc fd ff
	ff		 push	 DWORD PTR _cCorners$[ebp]
  000f5	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _rgCorners$[ebp]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 ?InitCorners@GXU@@YAJAAPAUSCorner@1@K@Z ; GXU::InitCorners
  00101	8b f0		 mov	 esi, eax

; 926  :     if (FAILED(hr))

  00103	3b f3		 cmp	 esi, ebx
  00105	59		 pop	 ecx
  00106	59		 pop	 ecx
  00107	0f 8c e8 01 00
	00		 jl	 $e_Exit$56834

; 927  :         goto e_Exit;
; 928  : 
; 929  :     // initialize the colors of the vertices to a reasonable default
; 930  :     for (iVert = 0; iVert < cVertices; iVert++)

  0010d	3b fb		 cmp	 edi, ebx
  0010f	76 44		 jbe	 SHORT $L57123

; 931  :     {
; 932  :         rglvLoaded[iVert].m_color = D3DXCOLOR(0.9f, 0.6f, 0.4f, 0.0f);

  00111	d9 ee		 fldz
  00113	c7 85 b0 fd ff
	ff 66 66 66 3f	 mov	 DWORD PTR $T57111[ebp], 1063675494 ; 3f666666H
  0011d	d9 9d bc fd ff
	ff		 fstp	 DWORD PTR $T57111[ebp+12]
  00123	c7 85 b4 fd ff
	ff 9a 99 19 3f	 mov	 DWORD PTR $T57111[ebp+4], 1058642330 ; 3f19999aH
  0012d	c7 85 b8 fd ff
	ff cd cc cc 3e	 mov	 DWORD PTR $T57111[ebp+8], 1053609165 ; 3ecccccdH
  00137	33 c0		 xor	 eax, eax
  00139	8b cf		 mov	 ecx, edi
$L56852:
  0013b	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _rglvLoaded$[ebp]
  00141	8d 7c 10 0c	 lea	 edi, DWORD PTR [eax+edx+12]
  00145	8d b5 b0 fd ff
	ff		 lea	 esi, DWORD PTR $T57111[ebp]
  0014b	a5		 movsd
  0014c	a5		 movsd
  0014d	a5		 movsd
  0014e	83 c0 44	 add	 eax, 68			; 00000044H
  00151	49		 dec	 ecx
  00152	a5		 movsd
  00153	75 e6		 jne	 SHORT $L56852
$L57123:

; 933  :     }
; 934  : 
; 935  :     while ( 1 )
; 936  :     {
; 937  :         hr = fc.GetLine(rgchBuf, sizeof(rgchBuf), bEOF);

  00155	bf 00 01 00 00	 mov	 edi, 256		; 00000100H
  0015a	e9 e3 00 00 00	 jmp	 $L56873
$L56857:

; 939  :         {
; 940  :             goto e_Exit;
; 941  :         }
; 942  : 
; 943  :         if (bEOF)

  0015f	38 9d ea fd ff
	ff		 cmp	 BYTE PTR _bEOF$[ebp], bl
  00165	0f 85 00 01 00
	00		 jne	 $L57126

; 944  :         {
; 945  :             break;  // EOF, break out of loop
; 946  :         }
; 947  : 
; 948  :         // load the various face and vertices, ignore unrecognized lines
; 949  : 
; 950  :         if (strncmp(rgchBuf, x_szVertex, x_cchVertex) == 0)

  0016b	6a 06		 push	 6
  0016d	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szVertex@GXU@@3PBDB ; GXU::x_szVertex
  00173	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _rgchBuf$[ebp]
  00179	50		 push	 eax
  0017a	e8 00 00 00 00	 call	 _strncmp
  0017f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00182	85 c0		 test	 eax, eax
  00184	75 31		 jne	 SHORT $L56863

; 951  :         {
; 952  :             hr = LoadVertex(rgchBuf, rglvLoaded, cVertices, bNormalFound);

  00186	8d 85 eb fd ff
	ff		 lea	 eax, DWORD PTR _bNormalFound$[ebp]
  0018c	50		 push	 eax
  0018d	ff b5 d8 fd ff
	ff		 push	 DWORD PTR _cVertices$[ebp]
  00193	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _rgchBuf$[ebp]
  00199	ff b5 dc fd ff
	ff		 push	 DWORD PTR _rglvLoaded$[ebp]
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 ?LoadVertex@GXU@@YAJPADPAUSLoadVertex@1@IAA_N@Z ; GXU::LoadVertex
  001a5	83 c4 10	 add	 esp, 16			; 00000010H
$L57142:
  001a8	8b f0		 mov	 esi, eax

; 953  :             if (FAILED(hr))

  001aa	3b f3		 cmp	 esi, ebx
  001ac	0f 8c 43 01 00
	00		 jl	 $e_Exit$56834

; 954  :                 goto e_Exit;
; 955  :         }
; 956  :         else if (strncmp(rgchBuf, x_szFace, x_cchFace) == 0)

  001b2	e9 8b 00 00 00	 jmp	 $L56873
$L56863:
  001b7	6a 04		 push	 4
  001b9	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szFace@GXU@@3PBDB ; GXU::x_szFace
  001bf	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _rgchBuf$[ebp]
  001c5	50		 push	 eax
  001c6	e8 00 00 00 00	 call	 _strncmp
  001cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ce	85 c0		 test	 eax, eax

; 957  :         {
; 958  :             hr = LoadFace(rgchBuf, cFaces, rglfFaces);

  001d0	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _rgchBuf$[ebp]
  001d6	75 17		 jne	 SHORT $L56868
  001d8	ff b5 e0 fd ff
	ff		 push	 DWORD PTR _rglfFaces$[ebp]
  001de	ff b5 e4 fd ff
	ff		 push	 DWORD PTR _cFaces$[ebp]
  001e4	50		 push	 eax
  001e5	e8 00 00 00 00	 call	 ?LoadFace@GXU@@YAJPADIPAUSLoadedFace@1@@Z ; GXU::LoadFace
  001ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 959  :             if (FAILED(hr))
; 960  :                 goto e_Exit;
; 961  :         }
; 962  :         else if (strncmp(rgchBuf, x_szCorner, x_cchCorner) == 0)

  001ed	eb b9		 jmp	 SHORT $L57142
$L56868:
  001ef	6a 06		 push	 6
  001f1	ff 35 00 00 00
	00		 push	 DWORD PTR ?x_szCorner@GXU@@3PBDB ; GXU::x_szCorner
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 _strncmp
  001fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00200	85 c0		 test	 eax, eax
  00202	75 3e		 jne	 SHORT $L56873

; 963  :         {
; 964  :             hr = LoadCorner(rgchBuf, iCorner, cVertices, cFaces, rgCorners, bNormalFound);

  00204	8d 85 eb fd ff
	ff		 lea	 eax, DWORD PTR _bNormalFound$[ebp]
  0020a	50		 push	 eax
  0020b	ff b5 d4 fd ff
	ff		 push	 DWORD PTR _rgCorners$[ebp]
  00211	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _rgchBuf$[ebp]
  00217	ff b5 e4 fd ff
	ff		 push	 DWORD PTR _cFaces$[ebp]
  0021d	ff b5 d8 fd ff
	ff		 push	 DWORD PTR _cVertices$[ebp]
  00223	ff b5 d0 fd ff
	ff		 push	 DWORD PTR _iCorner$[ebp]
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 ?LoadCorner@GXU@@YAJPADIIIPAUSCorner@1@AA_N@Z ; GXU::LoadCorner
  0022f	8b f0		 mov	 esi, eax
  00231	83 c4 18	 add	 esp, 24			; 00000018H

; 965  :             if (FAILED(hr))

  00234	3b f3		 cmp	 esi, ebx
  00236	0f 8c b9 00 00
	00		 jl	 $e_Exit$56834

; 966  :                 goto e_Exit;
; 967  : 
; 968  :             iCorner++;

  0023c	ff 85 d0 fd ff
	ff		 inc	 DWORD PTR _iCorner$[ebp]
$L56873:

; 933  :     }
; 934  : 
; 935  :     while ( 1 )
; 936  :     {
; 937  :         hr = fc.GetLine(rgchBuf, sizeof(rgchBuf), bEOF);

  00242	8d 85 ea fd ff
	ff		 lea	 eax, DWORD PTR _bEOF$[ebp]
  00248	50		 push	 eax
  00249	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _rgchBuf$[ebp]
  0024f	57		 push	 edi
  00250	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _fc$[ebp]
  00256	50		 push	 eax
  00257	e8 00 00 00 00	 call	 ?GetLine@CFileContext@GXU@@QAEJPADHAA_N@Z ; GXU::CFileContext::GetLine
  0025c	8b f0		 mov	 esi, eax

; 938  :         if (FAILED(hr))

  0025e	3b f3		 cmp	 esi, ebx
  00260	0f 8d f9 fe ff
	ff		 jge	 $L56857

; 1049 :     if (FAILED(hr))
; 1050 :         goto e_Exit;
; 1051 : 
; 1052 : e_Exit:

  00266	e9 8a 00 00 00	 jmp	 $e_Exit$56834
$L57126:

; 969  :         }
; 970  :     }
; 971  : 
; 972  :     GXASSERT(iCorner == cCorners);
; 973  : 
; 974  :     if (!bNormalFound)

  0026b	38 9d eb fd ff
	ff		 cmp	 BYTE PTR _bNormalFound$[ebp], bl
  00271	75 30		 jne	 SHORT $L57139

; 975  :     {
; 976  :         for (iFace = 0; iFace < cFaces; iFace++)

  00273	8b 95 e4 fd ff
	ff		 mov	 edx, DWORD PTR _cFaces$[ebp]
  00279	3b d3		 cmp	 edx, ebx
  0027b	76 26		 jbe	 SHORT $L57139
  0027d	33 c9		 xor	 ecx, ecx
$L56879:

; 977  :         {
; 978  :             if (rglfFaces[iFace].m_wIndices[0] != UNUSED32)

  0027f	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _rglfFaces$[ebp]
  00285	03 c1		 add	 eax, ecx
  00287	83 38 ff	 cmp	 DWORD PTR [eax], -1
  0028a	74 11		 je	 SHORT $L56880

; 979  :             {
; 980  :                 rglfFaces[iFace].m_bSmoothingGroupSpecified = true;

  0028c	80 48 0c 08	 or	 BYTE PTR [eax+12], 8

; 981  :                 rglfFaces[iFace].m_iSmoothingGroup = 1;

  00290	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _rglfFaces$[ebp]
  00296	66 c7 44 01 28
	01 00		 mov	 WORD PTR [ecx+eax+40], 1
$L56880:
  0029d	83 c1 2c	 add	 ecx, 44			; 0000002cH
  002a0	4a		 dec	 edx
  002a1	75 dc		 jne	 SHORT $L56879
$L57139:

; 982  :             }
; 983  :         }
; 984  :     }
; 985  : 
; 986  :     // test materials by generating materials for colors
; 987  : 
; 988  : #if 0
; 989  :     for (iFace = 0; iFace < cFaces; iFace++)
; 990  :     {
; 991  :         if (rglfFaces[iFace].m_bColorSpecified)
; 992  :         {
; 993  :             for (iColor = 0; iColor < cColors; iColor++)
; 994  :             {
; 995  :                 if (rgColors[iColor] == rglfFaces[iFace].m_colorFace)
; 996  :                     break;
; 997  :             }
; 998  : 
; 999  :             if (iColor == cColors)
; 1000 :             {
; 1001 :                 if ( ! AddToDynamicArray( &rgColors, rglfFaces[iFace].m_colorFace, &cColors, &cColorsMax ) )
; 1002 :                 {
; 1003 :                     hr = E_OUTOFMEMORY;
; 1004 :                     goto e_Exit;
; 1005 :                 }
; 1006 :             }
; 1007 : 
; 1008 : #if 0
; 1009 :             if (iColor < cColors)
; 1010 :             {
; 1011 :                 pattrColor = rgBundles[iColor];
; 1012 :             }
; 1013 :             else
; 1014 :             {
; 1015 :                 if ( ! AddToDynamicArray( &rgColors, rglfFaces[iFace].m_colorFace, &cColors, &cColorsMax ) )
; 1016 :                 {
; 1017 :                     hr = E_OUTOFMEMORY;
; 1018 :                     goto e_Exit;
; 1019 :                 }
; 1020 : 
; 1021 :                 pattrColor = new GXColorAttributeBundle(rglfFaces[iFace].m_colorFace);
; 1022 :                 if (pattrColor == NULL)
; 1023 :                 {
; 1024 :                     hr = E_OUTOFMEMORY;
; 1025 :                     goto e_Exit;
; 1026 :                 }
; 1027 : 
; 1028 :                 if ( ! AddToDynamicArray( &rgBundles, pattrColor, &cBundles, &cBundlesMax ) )
; 1029 :                 {
; 1030 :                     hr = E_OUTOFMEMORY;
; 1031 :                     goto e_Exit;
; 1032 :                 }
; 1033 :             }
; 1034 : #endif
; 1035 : 
; 1036 :             //rglfFaces[iFace].m_pattr = pattrColor;
; 1037 :             rglfFaces[iFace].m_attr = iColor;
; 1038 :             rglfFaces[iFace].m_bAttributeSpecified = true;
; 1039 : 
; 1040 :             rglfFaces[iFace].m_colorFace = colorGrey;
; 1041 :             //rglfFaces[iFace].m_bColorSpecified = false;
; 1042 :         }
; 1043 :     }
; 1044 : #endif
; 1045 : 
; 1046 : 
; 1047 :     hr = SetMesh(rglfFaces, cFaces, rglvLoaded, cVertices, rgCorners, cCorners, NULL, FALSE, NULL,
; 1048 :                         options, fvf, pD3DDevice, ppMesh, ppbufAdjacency);

  002a3	ff b5 c0 fd ff
	ff		 push	 DWORD PTR $T57121[ebp]
  002a9	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _rglvLoaded$[ebp]
  002af	ff b5 c4 fd ff
	ff		 push	 DWORD PTR $T57120[ebp]
  002b5	ff b5 c8 fd ff
	ff		 push	 DWORD PTR $T57119[ebp]
  002bb	ff 75 10	 push	 DWORD PTR _fvf$[ebp]
  002be	ff 75 0c	 push	 DWORD PTR _options$[ebp]
  002c1	53		 push	 ebx
  002c2	53		 push	 ebx
  002c3	53		 push	 ebx
  002c4	ff b5 cc fd ff
	ff		 push	 DWORD PTR _cCorners$[ebp]
  002ca	ff b5 d4 fd ff
	ff		 push	 DWORD PTR _rgCorners$[ebp]
  002d0	ff b5 d8 fd ff
	ff		 push	 DWORD PTR _cVertices$[ebp]
  002d6	50		 push	 eax
  002d7	ff b5 e4 fd ff
	ff		 push	 DWORD PTR _cFaces$[ebp]
  002dd	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _rglfFaces$[ebp]
  002e3	50		 push	 eax
  002e4	e8 00 00 00 00	 call	 ?SetMesh@GXU@@YAJAAPAUSLoadedFace@1@KAAPAUSLoadVertex@1@KPAUSCorner@1@KPAUSFVFData@1@HPAKKKPAUIDirect3DDevice9@@PAPAUID3DXMesh@@PAPAUID3DXBuffer@@@Z ; GXU::SetMesh
  002e9	83 c4 38	 add	 esp, 56			; 00000038H
  002ec	8b f0		 mov	 esi, eax

; 1049 :     if (FAILED(hr))
; 1050 :         goto e_Exit;
; 1051 : 
; 1052 : e_Exit:

  002ee	eb 05		 jmp	 SHORT $e_Exit$56834
$L56832:

; 900  :     {
; 901  :         hr = E_INVALIDARG;

  002f0	be 57 00 07 80	 mov	 esi, -2147024809	; 80070057H
$e_Exit$56834:

; 1053 : 
; 1054 :     delete []rglfFaces;

  002f5	ff b5 e0 fd ff
	ff		 push	 DWORD PTR _rglfFaces$[ebp]
  002fb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1055 :     delete []rglvLoaded;

  00300	ff b5 dc fd ff
	ff		 push	 DWORD PTR _rglvLoaded$[ebp]
  00306	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1056 :     delete []rgCorners;

  0030b	ff b5 d4 fd ff
	ff		 push	 DWORD PTR _rgCorners$[ebp]
  00311	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1057 : 
; 1058 :     return hr;
; 1059 : }

  00316	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00319	83 c4 0c	 add	 esp, 12			; 0000000cH
  0031c	5f		 pop	 edi
  0031d	8b c6		 mov	 eax, esi
  0031f	5e		 pop	 esi
  00320	5b		 pop	 ebx
  00321	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00326	c9		 leave
  00327	c2 18 00	 ret	 24			; 00000018H
?LoadMeshFromM@GXU@@YGJPAUIStream@@KKPAUIDirect3DDevice9@@PAPAUID3DXMesh@@PAPAUID3DXBuffer@@@Z ENDP ; GXU::LoadMeshFromM
_TEXT	ENDS
END
