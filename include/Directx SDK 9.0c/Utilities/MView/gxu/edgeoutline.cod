; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.4035 

	TITLE	.\edgeoutline.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??0CEdgeOutline@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CEdgeOutline@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindNeighbor@@YAKPBKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CEdgeOutline@@QAEJPAUID3DXBaseMesh@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@CEdgeOutline@@QAEJPAUID3DXBaseMesh@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateEmptyOutline@CEdgeOutline@@AAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$BCrease@G@@YAHKKPAKPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$BCrease@I@@YAHKKPAKPAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	??0CEdgeOutline@@QAE@XZ				; CEdgeOutline::CEdgeOutline
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\edgeoutline.cpp
;	COMDAT ??0CEdgeOutline@@QAE@XZ
_TEXT	SEGMENT
??0CEdgeOutline@@QAE@XZ PROC NEAR			; CEdgeOutline::CEdgeOutline, COMDAT
; _this$ = ecx

; 31   : {

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000c	89 88 18 02 00
	00		 mov	 DWORD PTR [eax+536], ecx
  00012	89 88 1c 02 00
	00		 mov	 DWORD PTR [eax+540], ecx
  00018	89 88 20 02 00
	00		 mov	 DWORD PTR [eax+544], ecx

; 32   : }

  0001e	c3		 ret	 0
??0CEdgeOutline@@QAE@XZ ENDP				; CEdgeOutline::CEdgeOutline
_TEXT	ENDS
PUBLIC	??1CEdgeOutline@@QAE@XZ				; CEdgeOutline::~CEdgeOutline
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogs
;	COMDAT ??1CEdgeOutline@@QAE@XZ
_TEXT	SEGMENT
??1CEdgeOutline@@QAE@XZ PROC NEAR			; CEdgeOutline::~CEdgeOutline, COMDAT
; _this$ = ecx

; 41   : }

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 35   : {

  00003	8b f1		 mov	 esi, ecx

; 36   :     GXRELEASE(m_pIndexBuffer);

  00005	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00008	85 c0		 test	 eax, eax
  0000a	74 0a		 je	 SHORT $L56241
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	50		 push	 eax
  0000f	ff 51 08	 call	 DWORD PTR [ecx+8]
  00012	83 66 04 00	 and	 DWORD PTR [esi+4], 0
$L56241:

; 37   :     GXRELEASE(m_pDevice);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	85 c0		 test	 eax, eax
  0001a	74 09		 je	 SHORT $L56245
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	50		 push	 eax
  0001f	ff 51 08	 call	 DWORD PTR [ecx+8]
  00022	83 26 00	 and	 DWORD PTR [esi], 0
$L56245:

; 38   :     GXRELEASE(m_pDeclObj);

  00025	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00028	85 c0		 test	 eax, eax
  0002a	74 0a		 je	 SHORT $L56249
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	50		 push	 eax
  0002f	ff 51 08	 call	 DWORD PTR [ecx+8]
  00032	83 66 08 00	 and	 DWORD PTR [esi+8], 0
$L56249:

; 39   : 
; 40   :     delete []m_rgaeAttributeTable;

  00036	ff b6 18 02 00
	00		 push	 DWORD PTR [esi+536]
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00041	59		 pop	 ecx
  00042	5e		 pop	 esi

; 41   : }

  00043	c3		 ret	 0
??1CEdgeOutline@@QAE@XZ ENDP				; CEdgeOutline::~CEdgeOutline
; Function compile flags: /Ogs
_TEXT	ENDS
;	COMDAT ?FindNeighbor@@YAKPBKK@Z
_TEXT	SEGMENT
?FindNeighbor@@YAKPBKK@Z PROC NEAR			; FindNeighbor, COMDAT
; _pdwAdjacency$ = ecx
; _iFace$ = eax

; 49   :     if (pdwAdjacency[0] == iFace)

  00000	39 01		 cmp	 DWORD PTR [ecx], eax
  00002	75 03		 jne	 SHORT $L56257

; 50   :         return 0;

  00004	33 c0		 xor	 eax, eax

; 52   :         return 1;
; 53   :     else 
; 54   :         return 2;
; 55   : }

  00006	c3		 ret	 0
$L56257:

; 51   :     else if (pdwAdjacency[1] == iFace)

  00007	33 d2		 xor	 edx, edx
  00009	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  0000c	0f 95 c2	 setne	 dl
  0000f	42		 inc	 edx
  00010	8b c2		 mov	 eax, edx

; 52   :         return 1;
; 53   :     else 
; 54   :         return 2;
; 55   : }

  00012	c3		 ret	 0
?FindNeighbor@@YAKPBKK@Z ENDP				; FindNeighbor
_TEXT	ENDS
PUBLIC	?Draw@CEdgeOutline@@QAEJPAUID3DXBaseMesh@@K@Z	; CEdgeOutline::Draw
EXTRN	__alloca_probe:NEAR
; Function compile flags: /Ogs
;	COMDAT ?Draw@CEdgeOutline@@QAEJPAUID3DXBaseMesh@@K@Z
_TEXT	SEGMENT
_iLineEnd$ = -20					; size = 4
_pbPoints$ = -16					; size = 4
_pdwLineIndices$ = -12					; size = 4
_pVertexBuffer$ = -8					; size = 4
_pbLine$ = -4						; size = 4
_ptmDrawMesh$ = 8					; size = 4
_iLine$ = 12						; size = 4
_iAttrib$ = 12						; size = 4
?Draw@CEdgeOutline@@QAEJPAUID3DXBaseMesh@@K@Z PROC NEAR	; CEdgeOutline::Draw, COMDAT
; _this$ = ecx

; 364  : }

  00000	8b ff		 npad	 2

; 284  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H
  00008	53		 push	 ebx
  00009	8b d9		 mov	 ebx, ecx

; 285  :     HRESULT hr;
; 286  :     LPDIRECT3DVERTEXBUFFER9 pVertexBuffer;
; 287  :     DWORD iSubset;
; 288  : 
; 289  :     DWORD *pdwLineIndices;
; 290  :     PBYTE pbLine;
; 291  :     PBYTE pbPoints;
; 292  :     DWORD iLine;
; 293  :     DWORD iLineStart;
; 294  :     DWORD iLineEnd;
; 295  : 
; 296  :     if ((iAttrib < m_caeAttributeTable) && (m_rgaeAttributeTable[iAttrib].AttribId == iAttrib))

  0000b	8b 93 1c 02 00
	00		 mov	 edx, DWORD PTR [ebx+540]
  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _iAttrib$[ebp]
  00014	3b ca		 cmp	 ecx, edx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	73 14		 jae	 SHORT $L56390
  0001a	8b b3 18 02 00
	00		 mov	 esi, DWORD PTR [ebx+536]
  00020	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00023	39 0c 86	 cmp	 DWORD PTR [esi+eax*4], ecx
  00026	75 06		 jne	 SHORT $L56390

; 297  :     {
; 298  :         iSubset = iAttrib;

  00028	8b c1		 mov	 eax, ecx

; 299  :     }
; 300  :     else

  0002a	33 ff		 xor	 edi, edi
  0002c	eb 1a		 jmp	 SHORT $L56478
$L56390:

; 301  :     {
; 302  :         // look for the correct attribute table entry to draw
; 303  :         for (iSubset = 0; iSubset < m_caeAttributeTable; iSubset++)

  0002e	33 ff		 xor	 edi, edi
  00030	33 c0		 xor	 eax, eax
  00032	3b d7		 cmp	 edx, edi
  00034	76 12		 jbe	 SHORT $L56478
  00036	8b b3 18 02 00
	00		 mov	 esi, DWORD PTR [ebx+536]
$L56392:

; 304  :         {
; 305  :             if (m_rgaeAttributeTable[iSubset].AttribId == iAttrib)

  0003c	39 0e		 cmp	 DWORD PTR [esi], ecx
  0003e	74 08		 je	 SHORT $L56478
  00040	40		 inc	 eax
  00041	83 c6 14	 add	 esi, 20			; 00000014H
  00044	3b c2		 cmp	 eax, edx
  00046	72 f4		 jb	 SHORT $L56392
$L56478:

; 306  :             {
; 307  :                 break;
; 308  :             }
; 309  :         }
; 310  :     }
; 311  : 
; 312  :     if (iSubset < m_caeAttributeTable)

  00048	3b c2		 cmp	 eax, edx
  0004a	0f 83 8d 01 00
	00		 jae	 $L56405

; 313  :     {
; 314  :         if (m_rgaeAttributeTable[iSubset].FaceCount > 0)

  00050	8d 34 80	 lea	 esi, DWORD PTR [eax+eax*4]
  00053	8b 83 18 02 00
	00		 mov	 eax, DWORD PTR [ebx+536]
  00059	c1 e6 02	 shl	 esi, 2
  0005c	39 7c 06 08	 cmp	 DWORD PTR [esi+eax+8], edi
  00060	0f 86 77 01 00
	00		 jbe	 $L56405

; 315  :         {
; 316  :             if (!m_bEmulate32BitIndex)

  00066	39 bb 20 02 00
	00		 cmp	 DWORD PTR [ebx+544], edi

; 317  :             {
; 318  :                 ptmDrawMesh->GetVertexBuffer(&pVertexBuffer);

  0006c	8b 45 08	 mov	 eax, DWORD PTR _ptmDrawMesh$[ebp]
  0006f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00071	75 7f		 jne	 SHORT $L56398
  00073	8d 55 f8	 lea	 edx, DWORD PTR _pVertexBuffer$[ebp]
  00076	52		 push	 edx
  00077	50		 push	 eax
  00078	ff 51 34	 call	 DWORD PTR [ecx+52]

; 319  :                 m_pDevice->SetVertexDeclaration(m_pDeclObj);

  0007b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0007d	ff 73 08	 push	 DWORD PTR [ebx+8]
  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	50		 push	 eax
  00083	ff 91 5c 01 00
	00		 call	 DWORD PTR [ecx+348]

; 320  :                 m_pDevice->SetStreamSource(0, pVertexBuffer, 0, m_cBytesPerVertex);

  00089	ff b3 14 02 00
	00		 push	 DWORD PTR [ebx+532]
  0008f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00091	8b 08		 mov	 ecx, DWORD PTR [eax]
  00093	57		 push	 edi
  00094	ff 75 f8	 push	 DWORD PTR _pVertexBuffer$[ebp]
  00097	57		 push	 edi
  00098	50		 push	 eax
  00099	ff 91 90 01 00
	00		 call	 DWORD PTR [ecx+400]

; 321  :                 m_pDevice->SetIndices(m_pIndexBuffer);

  0009f	8b 03		 mov	 eax, DWORD PTR [ebx]
  000a1	ff 73 04	 push	 DWORD PTR [ebx+4]
  000a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a6	50		 push	 eax
  000a7	ff 91 a0 01 00
	00		 call	 DWORD PTR [ecx+416]

; 322  : 
; 323  :                 hr = m_pDevice->DrawIndexedPrimitive(D3DPT_LINELIST, 
; 324  :                                              0, 0, m_rgaeAttributeTable[iSubset].VertexStart + m_rgaeAttributeTable[iSubset].VertexCount,
; 325  :                                              m_rgaeAttributeTable[iSubset].FaceStart * 2, 
; 326  :                                              m_rgaeAttributeTable[iSubset].FaceCount);

  000ad	8b 83 18 02 00
	00		 mov	 eax, DWORD PTR [ebx+536]
  000b3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000b5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b7	03 c6		 add	 eax, esi
  000b9	ff 70 08	 push	 DWORD PTR [eax+8]
  000bc	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000bf	d1 e6		 shl	 esi, 1
  000c1	56		 push	 esi
  000c2	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  000c5	03 70 0c	 add	 esi, DWORD PTR [eax+12]
  000c8	56		 push	 esi
  000c9	57		 push	 edi
  000ca	57		 push	 edi
  000cb	6a 02		 push	 2
  000cd	51		 push	 ecx
  000ce	ff 92 48 01 00
	00		 call	 DWORD PTR [edx+328]

; 327  :                 if (FAILED(hr))

  000d4	3b c7		 cmp	 eax, edi

; 328  :                     return hr;

  000d6	0f 8c 03 01 00
	00		 jl	 $L56380

; 329  : 
; 330  :                 GXRELEASE(pVertexBuffer);

  000dc	8b 45 f8	 mov	 eax, DWORD PTR _pVertexBuffer$[ebp]
  000df	3b c7		 cmp	 eax, edi
  000e1	0f 84 f6 00 00
	00		 je	 $L56405
  000e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e9	50		 push	 eax
  000ea	ff 51 08	 call	 DWORD PTR [ecx+8]

; 331  :             }
; 332  :             else

  000ed	e9 eb 00 00 00	 jmp	 $L56405
$L56398:

; 333  :             {
; 334  :                 GXASSERT(ptmDrawMesh->GetOptions() & D3DXMESH_32BIT);
; 335  : 
; 336  :                 hr = ptmDrawMesh->LockVertexBuffer(D3DLOCK_READONLY, (PVOID*)&pbPoints);

  000f2	8d 55 f0	 lea	 edx, DWORD PTR _pbPoints$[ebp]
  000f5	52		 push	 edx
  000f6	6a 10		 push	 16			; 00000010H
  000f8	50		 push	 eax
  000f9	ff 51 3c	 call	 DWORD PTR [ecx+60]

; 337  :                 if (FAILED(hr))

  000fc	3b c7		 cmp	 eax, edi

; 338  :                     return hr;

  000fe	0f 8c db 00 00
	00		 jl	 $L56380

; 339  : 
; 340  :                 hr = m_pIndexBuffer->Lock(0, 0, (PVOID*)&pdwLineIndices, D3DLOCK_NOSYSLOCK|D3DLOCK_READONLY);

  00104	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00107	8b 08		 mov	 ecx, DWORD PTR [eax]
  00109	68 10 08 00 00	 push	 2064			; 00000810H
  0010e	8d 55 f4	 lea	 edx, DWORD PTR _pdwLineIndices$[ebp]
  00111	52		 push	 edx
  00112	57		 push	 edi
  00113	57		 push	 edi
  00114	50		 push	 eax
  00115	ff 51 2c	 call	 DWORD PTR [ecx+44]

; 341  :                 if (FAILED(hr))

  00118	3b c7		 cmp	 eax, edi

; 342  :                     return hr;

  0011a	0f 8c bf 00 00
	00		 jl	 $L56380

; 343  : 
; 344  :                 pbLine = (PBYTE)_alloca(m_cBytesPerVertex * 2);

  00120	8b 83 14 02 00
	00		 mov	 eax, DWORD PTR [ebx+532]
  00126	d1 e0		 shl	 eax, 1
  00128	83 c0 03	 add	 eax, 3
  0012b	83 e0 fc	 and	 eax, -4			; fffffffcH
  0012e	e8 00 00 00 00	 call	 __alloca_probe

; 345  : 
; 346  :                 iLineStart = m_rgaeAttributeTable[iSubset].FaceStart * 2;

  00133	8b 83 18 02 00
	00		 mov	 eax, DWORD PTR [ebx+536]
  00139	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0013c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 347  :                 iLineEnd = iLineStart + m_rgaeAttributeTable[iSubset].FaceCount * 2;

  0013f	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00142	d1 e0		 shl	 eax, 1
  00144	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]

; 348  :                 for (iLine = iLineStart; iLine < iLineEnd; iLine+=2)

  00147	3b c1		 cmp	 eax, ecx
  00149	89 65 fc	 mov	 DWORD PTR _pbLine$[ebp], esp
  0014c	89 4d ec	 mov	 DWORD PTR _iLineEnd$[ebp], ecx
  0014f	89 45 0c	 mov	 DWORD PTR _iLine$[ebp], eax
  00152	73 77		 jae	 SHORT $L56416
$L56414:

; 349  :                 {
; 350  :                     memcpy(pbLine, pbPoints + pdwLineIndices[iLine]*m_cBytesPerVertex, m_cBytesPerVertex);

  00154	8b 55 f4	 mov	 edx, DWORD PTR _pdwLineIndices$[ebp]
  00157	8b 8b 14 02 00
	00		 mov	 ecx, DWORD PTR [ebx+532]
  0015d	8b 45 0c	 mov	 eax, DWORD PTR _iLine$[ebp]
  00160	8b 7d fc	 mov	 edi, DWORD PTR _pbLine$[ebp]
  00163	c1 e0 02	 shl	 eax, 2
  00166	8b 34 10	 mov	 esi, DWORD PTR [eax+edx]
  00169	0f af f1	 imul	 esi, ecx
  0016c	03 75 f0	 add	 esi, DWORD PTR _pbPoints$[ebp]
  0016f	8b d1		 mov	 edx, ecx
  00171	c1 e9 02	 shr	 ecx, 2
  00174	f3 a5		 rep movsd
  00176	8b ca		 mov	 ecx, edx
  00178	83 e1 03	 and	 ecx, 3
  0017b	f3 a4		 rep movsb

; 351  :                     memcpy(pbLine + m_cBytesPerVertex, pbPoints + pdwLineIndices[iLine+1]*m_cBytesPerVertex, m_cBytesPerVertex);

  0017d	8b 8b 14 02 00
	00		 mov	 ecx, DWORD PTR [ebx+532]
  00183	8b 55 f4	 mov	 edx, DWORD PTR _pdwLineIndices$[ebp]
  00186	8b 74 10 04	 mov	 esi, DWORD PTR [eax+edx+4]
  0018a	0f af f1	 imul	 esi, ecx
  0018d	03 75 f0	 add	 esi, DWORD PTR _pbPoints$[ebp]
  00190	8b f9		 mov	 edi, ecx
  00192	03 7d fc	 add	 edi, DWORD PTR _pbLine$[ebp]
  00195	8b c1		 mov	 eax, ecx
  00197	c1 e9 02	 shr	 ecx, 2
  0019a	f3 a5		 rep movsd
  0019c	8b c8		 mov	 ecx, eax
  0019e	83 e1 03	 and	 ecx, 3
  001a1	f3 a4		 rep movsb

; 352  : 
; 353  :                     hr = m_pDevice->DrawPrimitiveUP(D3DPT_LINELIST, 1, pbLine, m_cBytesPerVertex);

  001a3	ff b3 14 02 00
	00		 push	 DWORD PTR [ebx+532]
  001a9	8b 03		 mov	 eax, DWORD PTR [ebx]
  001ab	ff 75 fc	 push	 DWORD PTR _pbLine$[ebp]
  001ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b0	6a 01		 push	 1
  001b2	6a 02		 push	 2
  001b4	50		 push	 eax
  001b5	ff 91 4c 01 00
	00		 call	 DWORD PTR [ecx+332]

; 354  :                     if (FAILED(hr))

  001bb	85 c0		 test	 eax, eax
  001bd	7c 20		 jl	 SHORT $L56380
  001bf	83 45 0c 02	 add	 DWORD PTR _iLine$[ebp], 2
  001c3	8b 45 0c	 mov	 eax, DWORD PTR _iLine$[ebp]
  001c6	3b 45 ec	 cmp	 eax, DWORD PTR _iLineEnd$[ebp]
  001c9	72 89		 jb	 SHORT $L56414
$L56416:

; 355  :                         return hr;
; 356  :                 }
; 357  : 
; 358  :                 ptmDrawMesh->UnlockVertexBuffer();

  001cb	8b 45 08	 mov	 eax, DWORD PTR _ptmDrawMesh$[ebp]
  001ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d0	50		 push	 eax
  001d1	ff 51 40	 call	 DWORD PTR [ecx+64]

; 359  :                 m_pIndexBuffer->Unlock();

  001d4	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  001d7	8b 03		 mov	 eax, DWORD PTR [ebx]
  001d9	53		 push	 ebx
  001da	ff 50 30	 call	 DWORD PTR [eax+48]
$L56405:

; 360  :             }
; 361  :         }
; 362  :     }
; 363  :     return S_OK;

  001dd	33 c0		 xor	 eax, eax
$L56380:

; 364  : }

  001df	8d 65 e0	 lea	 esp, DWORD PTR [ebp-32]
  001e2	5f		 pop	 edi
  001e3	5e		 pop	 esi
  001e4	5b		 pop	 ebx
  001e5	c9		 leave
  001e6	c2 08 00	 ret	 8
?Draw@CEdgeOutline@@QAEJPAUID3DXBaseMesh@@K@Z ENDP	; CEdgeOutline::Draw
_TEXT	ENDS
PUBLIC	?CreateEmptyOutline@CEdgeOutline@@AAEJXZ	; CEdgeOutline::CreateEmptyOutline
; Function compile flags: /Ogs
;	COMDAT ?CreateEmptyOutline@CEdgeOutline@@AAEJXZ
_TEXT	SEGMENT
?CreateEmptyOutline@CEdgeOutline@@AAEJXZ PROC NEAR	; CEdgeOutline::CreateEmptyOutline, COMDAT
; _this$ = ecx

; 377  : }

  00000	8b ff		 npad	 2
  00002	53		 push	 ebx
  00003	56		 push	 esi

; 368  : {

  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 369  :     delete []m_rgaeAttributeTable;

  00007	8d be 18 02 00
	00		 lea	 edi, DWORD PTR [esi+536]
  0000d	ff 37		 push	 DWORD PTR [edi]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 370  :     m_rgaeAttributeTable = NULL;
; 371  :     m_caeAttributeTable = 0;
; 372  :     GXRELEASE(m_pIndexBuffer);

  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00017	33 db		 xor	 ebx, ebx
  00019	3b c3		 cmp	 eax, ebx
  0001b	59		 pop	 ecx
  0001c	89 1f		 mov	 DWORD PTR [edi], ebx
  0001e	89 9e 1c 02 00
	00		 mov	 DWORD PTR [esi+540], ebx
  00024	74 09		 je	 SHORT $L56425
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	50		 push	 eax
  00029	ff 51 08	 call	 DWORD PTR [ecx+8]
  0002c	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
$L56425:

; 373  :     GXRELEASE(m_pDevice);

  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	3b c3		 cmp	 eax, ebx
  00033	74 08		 je	 SHORT $L56429
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	50		 push	 eax
  00038	ff 51 08	 call	 DWORD PTR [ecx+8]
  0003b	89 1e		 mov	 DWORD PTR [esi], ebx
$L56429:

; 374  :     GXRELEASE(m_pDeclObj);

  0003d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00040	3b c3		 cmp	 eax, ebx
  00042	74 09		 je	 SHORT $L56433
  00044	8b 08		 mov	 ecx, DWORD PTR [eax]
  00046	50		 push	 eax
  00047	ff 51 08	 call	 DWORD PTR [ecx+8]
  0004a	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
$L56433:
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi

; 375  : 
; 376  :     return S_OK;

  0004f	33 c0		 xor	 eax, eax
  00051	5b		 pop	 ebx

; 377  : }

  00052	c3		 ret	 0
?CreateEmptyOutline@CEdgeOutline@@AAEJXZ ENDP		; CEdgeOutline::CreateEmptyOutline
_TEXT	ENDS
PUBLIC	??$BCrease@G@@YAHKKPAKPAG@Z			; BCrease<unsigned short>
; Function compile flags: /Ogs
;	COMDAT ??$BCrease@G@@YAHKKPAKPAG@Z
_TEXT	SEGMENT
tv192 = 8						; size = 4
_iFace$ = 8						; size = 4
_iPoint$ = 12						; size = 4
_rgdwAdjacency$ = 16					; size = 4
_pwFaceIndices$ = 20					; size = 4
??$BCrease@G@@YAHKKPAKPAG@Z PROC NEAR			; BCrease<unsigned short>, COMDAT

; 81   :     }
; 82   : }

  00000	8b ff		 npad	 2

; 59   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 60   :     DWORD iNeighbor;
; 61   :     DWORD iEdge;
; 62   : 
; 63   :     GXASSERT(iPoint < 3);
; 64   : 
; 65   :     iNeighbor = rgdwAdjacency[(iFace * 3) + iPoint];

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _iFace$[ebp]
  00008	8b 45 0c	 mov	 eax, DWORD PTR _iPoint$[ebp]
  0000b	8b 55 10	 mov	 edx, DWORD PTR _rgdwAdjacency$[ebp]
  0000e	53		 push	 ebx
  0000f	8d 1c 49	 lea	 ebx, DWORD PTR [ecx+ecx*2]
  00012	89 5d 08	 mov	 DWORD PTR tv192[ebp], ebx
  00015	03 d8		 add	 ebx, eax
  00017	8b 04 9a	 mov	 eax, DWORD PTR [edx+ebx*4]

; 66   :     if (iNeighbor == UNUSED32)

  0001a	83 f8 ff	 cmp	 eax, -1
  0001d	75 05		 jne	 SHORT $L56441

; 67   :         return TRUE;

  0001f	33 c0		 xor	 eax, eax
  00021	40		 inc	 eax
  00022	eb 5b		 jmp	 SHORT $L56444
$L56441:
  00024	56		 push	 esi

; 68   : 
; 69   :     GXASSERT(rgdwAdjacency[(iFace * 3) + iPoint] != UNUSED32);
; 70   : 
; 71   :     iEdge = FindNeighbor(&rgdwAdjacency[iNeighbor * 3], iFace);

  00025	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  00028	8d 34 b2	 lea	 esi, DWORD PTR [edx+esi*4]
  0002b	39 0e		 cmp	 DWORD PTR [esi], ecx
  0002d	57		 push	 edi
  0002e	75 04		 jne	 SHORT $L56491
  00030	33 ff		 xor	 edi, edi
  00032	eb 0b		 jmp	 SHORT $L56493
$L56491:
  00034	33 d2		 xor	 edx, edx
  00036	39 4e 04	 cmp	 DWORD PTR [esi+4], ecx
  00039	0f 95 c2	 setne	 dl
  0003c	42		 inc	 edx
  0003d	8b fa		 mov	 edi, edx
$L56493:

; 72   : 
; 73   :     if ((pwFaceIndices[iNeighbor * 3 + iEdge] == pwFaceIndices[iFace * 3 + ((iPoint+1)%3)])
; 74   :         && (pwFaceIndices[iNeighbor * 3 +((iEdge+1)%3)] == pwFaceIndices[iFace * 3 + iPoint]))

  0003f	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  00042	8b 45 0c	 mov	 eax, DWORD PTR _iPoint$[ebp]
  00045	40		 inc	 eax
  00046	33 d2		 xor	 edx, edx
  00048	6a 03		 push	 3
  0004a	59		 pop	 ecx
  0004b	f7 f1		 div	 ecx
  0004d	8b 4d 14	 mov	 ecx, DWORD PTR _pwFaceIndices$[ebp]
  00050	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00053	66 8b 04 41	 mov	 ax, WORD PTR [ecx+eax*2]
  00057	03 55 08	 add	 edx, DWORD PTR tv192[ebp]
  0005a	66 3b 04 51	 cmp	 ax, WORD PTR [ecx+edx*2]
  0005e	75 1a		 jne	 SHORT $L56443
  00060	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00063	33 d2		 xor	 edx, edx
  00065	6a 03		 push	 3
  00067	5f		 pop	 edi
  00068	f7 f7		 div	 edi
  0006a	03 d6		 add	 edx, esi
  0006c	66 8b 04 51	 mov	 ax, WORD PTR [ecx+edx*2]
  00070	66 3b 04 59	 cmp	 ax, WORD PTR [ecx+ebx*2]
  00074	75 04		 jne	 SHORT $L56443

; 75   :     {
; 76   :         return FALSE;

  00076	33 c0		 xor	 eax, eax
  00078	eb 03		 jmp	 SHORT $L56496
$L56443:

; 77   :     }
; 78   :     else 
; 79   :     {
; 80   :         return TRUE;

  0007a	33 c0		 xor	 eax, eax
  0007c	40		 inc	 eax
$L56496:
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
$L56444:
  0007f	5b		 pop	 ebx

; 81   :     }
; 82   : }

  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
??$BCrease@G@@YAHKKPAKPAG@Z ENDP			; BCrease<unsigned short>
_TEXT	ENDS
PUBLIC	??$BCrease@I@@YAHKKPAKPAI@Z			; BCrease<unsigned int>
; Function compile flags: /Ogs
;	COMDAT ??$BCrease@I@@YAHKKPAKPAI@Z
_TEXT	SEGMENT
tv192 = 8						; size = 4
_iFace$ = 8						; size = 4
_iPoint$ = 12						; size = 4
_rgdwAdjacency$ = 16					; size = 4
_pwFaceIndices$ = 20					; size = 4
??$BCrease@I@@YAHKKPAKPAI@Z PROC NEAR			; BCrease<unsigned int>, COMDAT

; 81   :     }
; 82   : }

  00000	8b ff		 npad	 2

; 59   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 60   :     DWORD iNeighbor;
; 61   :     DWORD iEdge;
; 62   : 
; 63   :     GXASSERT(iPoint < 3);
; 64   : 
; 65   :     iNeighbor = rgdwAdjacency[(iFace * 3) + iPoint];

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _iFace$[ebp]
  00008	8b 55 0c	 mov	 edx, DWORD PTR _iPoint$[ebp]
  0000b	56		 push	 esi
  0000c	8d 34 49	 lea	 esi, DWORD PTR [ecx+ecx*2]
  0000f	89 75 08	 mov	 DWORD PTR tv192[ebp], esi
  00012	03 f2		 add	 esi, edx
  00014	57		 push	 edi
  00015	8b 7d 10	 mov	 edi, DWORD PTR _rgdwAdjacency$[ebp]
  00018	c1 e6 02	 shl	 esi, 2
  0001b	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]

; 66   :     if (iNeighbor == UNUSED32)

  0001e	83 f8 ff	 cmp	 eax, -1
  00021	75 05		 jne	 SHORT $L56449

; 67   :         return TRUE;

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	eb 4e		 jmp	 SHORT $L56452
$L56449:
  00028	53		 push	 ebx

; 68   : 
; 69   :     GXASSERT(rgdwAdjacency[(iFace * 3) + iPoint] != UNUSED32);
; 70   : 
; 71   :     iEdge = FindNeighbor(&rgdwAdjacency[iNeighbor * 3], iFace);

  00029	8d 1c 40	 lea	 ebx, DWORD PTR [eax+eax*2]
  0002c	8d 3c 9f	 lea	 edi, DWORD PTR [edi+ebx*4]
  0002f	33 db		 xor	 ebx, ebx
  00031	39 0f		 cmp	 DWORD PTR [edi], ecx
  00033	74 07		 je	 SHORT $L56504
  00035	39 4f 04	 cmp	 DWORD PTR [edi+4], ecx
  00038	0f 95 c3	 setne	 bl
  0003b	43		 inc	 ebx
$L56504:

; 72   : 
; 73   :     if ((pwFaceIndices[iNeighbor * 3 + iEdge] == pwFaceIndices[iFace * 3 + ((iPoint+1)%3)])
; 74   :         && (pwFaceIndices[iNeighbor * 3 +((iEdge+1)%3)] == pwFaceIndices[iFace * 3 + iPoint]))

  0003c	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  0003f	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00042	33 d2		 xor	 edx, edx
  00044	6a 03		 push	 3
  00046	59		 pop	 ecx
  00047	f7 f1		 div	 ecx
  00049	8b 4d 14	 mov	 ecx, DWORD PTR _pwFaceIndices$[ebp]
  0004c	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  0004f	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00052	03 55 08	 add	 edx, DWORD PTR tv192[ebp]
  00055	3b 04 91	 cmp	 eax, DWORD PTR [ecx+edx*4]
  00058	75 18		 jne	 SHORT $L56451
  0005a	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0005d	33 d2		 xor	 edx, edx
  0005f	6a 03		 push	 3
  00061	5b		 pop	 ebx
  00062	f7 f3		 div	 ebx
  00064	03 d7		 add	 edx, edi
  00066	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00069	3b 04 0e	 cmp	 eax, DWORD PTR [esi+ecx]
  0006c	75 04		 jne	 SHORT $L56451

; 75   :     {
; 76   :         return FALSE;

  0006e	33 c0		 xor	 eax, eax
  00070	eb 03		 jmp	 SHORT $L56507
$L56451:

; 77   :     }
; 78   :     else 
; 79   :     {
; 80   :         return TRUE;

  00072	33 c0		 xor	 eax, eax
  00074	40		 inc	 eax
$L56507:
  00075	5b		 pop	 ebx
$L56452:
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi

; 81   :     }
; 82   : }

  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
??$BCrease@I@@YAHKKPAKPAI@Z ENDP			; BCrease<unsigned int>
_TEXT	ENDS
PUBLIC	?Init@CEdgeOutline@@QAEJPAUID3DXBaseMesh@@PAK@Z	; CEdgeOutline::Init
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_D3DXGetDeclVertexSize@8:NEAR
; Function compile flags: /Ogs
;	COMDAT ?Init@CEdgeOutline@@QAEJPAUID3DXBaseMesh@@PAK@Z
_TEXT	SEGMENT
_Caps$ = -380						; size = 304
tv551 = -76						; size = 4
tv973 = -72						; size = 4
_pbDest$ = -68						; size = 4
_iFace$ = -64						; size = 4
_pbLineIndices$ = -60					; size = 4
tv939 = -56						; size = 4
tv903 = -52						; size = 4
tv955 = -48						; size = 4
tv1026 = -44						; size = 4
_b16BitIndex$ = -40					; size = 4
_cBytesPerIndex$ = -36					; size = 4
_iFaceEnd$ = -32					; size = 4
_hr$ = -28						; size = 4
_rgaeAttributeTableMesh$ = -24				; size = 4
tv840 = -20						; size = 4
_iAttr$ = -16						; size = 4
_pbFaceIndices$ = -12					; size = 4
tv917 = -8						; size = 4
tv758 = -8						; size = 4
_iPoint$ = -4						; size = 4
_ptmMesh$ = 8						; size = 4
_rgdwAdjacency$ = 12					; size = 4
?Init@CEdgeOutline@@QAEJPAUID3DXBaseMesh@@PAK@Z PROC NEAR ; CEdgeOutline::Init, COMDAT
; _this$ = ecx

; 280  : }

  00000	8b ff		 npad	 2

; 87   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 7c 01 00
	00		 sub	 esp, 380		; 0000017cH
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 88   :     HRESULT hr = S_OK;
; 89   :     BOOL b16BitIndex;
; 90   :     DWORD cBytesPerIndex;
; 91   :     DWORD iPoint;
; 92   :     DWORD iFace;
; 93   :     D3DXATTRIBUTERANGE *rgaeAttributeTableMesh = NULL;
; 94   :     PBYTE pbFaceIndices = NULL;
; 95   :     PBYTE pbLineIndices = NULL;
; 96   :     PBYTE pbSrc;
; 97   :     PBYTE pbDest;
; 98   :     DWORD iLineOffset;
; 99   :     DWORD iAttr;
; 100  :     DWORD dwNeighbor;
; 101  :     DWORD iFaceEnd;
; 102  :     BOOL bCrease;
; 103  :     DWORD cFacesCur;
; 104  :     D3DCAPS9 Caps;
; 105  : 
; 106  :     // is the mesh 16 bit?
; 107  :     b16BitIndex = !(ptmMesh->GetOptions() & D3DXMESH_32BIT);

  0000e	8b 7d 08	 mov	 edi, DWORD PTR _ptmMesh$[ebp]
  00011	8b 07		 mov	 eax, DWORD PTR [edi]
  00013	33 f6		 xor	 esi, esi
  00015	57		 push	 edi
  00016	8b d9		 mov	 ebx, ecx
  00018	89 75 e8	 mov	 DWORD PTR _rgaeAttributeTableMesh$[ebp], esi
  0001b	89 75 f4	 mov	 DWORD PTR _pbFaceIndices$[ebp], esi
  0001e	89 75 c4	 mov	 DWORD PTR _pbLineIndices$[ebp], esi
  00021	ff 50 24	 call	 DWORD PTR [eax+36]
  00024	f7 d0		 not	 eax
  00026	83 e0 01	 and	 eax, 1
  00029	89 45 d8	 mov	 DWORD PTR _b16BitIndex$[ebp], eax

; 108  :     cBytesPerIndex = (b16BitIndex ? 2:4);

  0002c	56		 push	 esi
  0002d	58		 pop	 eax
  0002e	0f 94 c0	 sete	 al

; 109  : 
; 110  :     hr = CreateEmptyOutline();

  00031	8b cb		 mov	 ecx, ebx
  00033	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00037	89 45 dc	 mov	 DWORD PTR _cBytesPerIndex$[ebp], eax
  0003a	e8 00 00 00 00	 call	 ?CreateEmptyOutline@CEdgeOutline@@AAEJXZ ; CEdgeOutline::CreateEmptyOutline

; 111  :     if (FAILED(hr))

  0003f	3b c6		 cmp	 eax, esi
  00041	89 45 e4	 mov	 DWORD PTR _hr$[ebp], eax
  00044	0f 8c c1 03 00
	00		 jl	 $e_Exit$56291

; 112  :         goto e_Exit;
; 113  : 
; 114  :     ptmMesh->GetDeclaration(m_pDecl);

  0004a	8b 07		 mov	 eax, DWORD PTR [edi]
  0004c	8d 73 0c	 lea	 esi, DWORD PTR [ebx+12]
  0004f	56		 push	 esi
  00050	57		 push	 edi
  00051	ff 50 1c	 call	 DWORD PTR [eax+28]

; 115  :     m_cBytesPerVertex = D3DXGetDeclVertexSize(m_pDecl, 0);

  00054	6a 00		 push	 0
  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 _D3DXGetDeclVertexSize@8

; 116  : 
; 117  :     ptmMesh->GetDevice(&m_pDevice);

  0005c	53		 push	 ebx
  0005d	89 83 14 02 00
	00		 mov	 DWORD PTR [ebx+532], eax
  00063	8b 07		 mov	 eax, DWORD PTR [edi]
  00065	57		 push	 edi
  00066	ff 50 28	 call	 DWORD PTR [eax+40]

; 118  : 
; 119  :     hr = m_pDevice->CreateVertexDeclaration(m_pDecl, &m_pDeclObj);

  00069	8b 03		 mov	 eax, DWORD PTR [ebx]
  0006b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006d	8d 53 08	 lea	 edx, DWORD PTR [ebx+8]
  00070	52		 push	 edx
  00071	56		 push	 esi
  00072	50		 push	 eax
  00073	ff 91 58 01 00
	00		 call	 DWORD PTR [ecx+344]

; 120  :     if (FAILED(hr))

  00079	85 c0		 test	 eax, eax
  0007b	89 45 e4	 mov	 DWORD PTR _hr$[ebp], eax
  0007e	0f 8c 87 03 00
	00		 jl	 $e_Exit$56291

; 121  :         goto e_Exit;
; 122  : 
; 123  :     hr = ptmMesh->GetAttributeTable(NULL, &m_caeAttributeTable);

  00084	8b 07		 mov	 eax, DWORD PTR [edi]
  00086	8d b3 1c 02 00
	00		 lea	 esi, DWORD PTR [ebx+540]
  0008c	56		 push	 esi
  0008d	6a 00		 push	 0
  0008f	57		 push	 edi
  00090	ff 50 4c	 call	 DWORD PTR [eax+76]

; 124  :     if (FAILED(hr))

  00093	85 c0		 test	 eax, eax
  00095	89 45 e4	 mov	 DWORD PTR _hr$[ebp], eax
  00098	0f 8c 6d 03 00
	00		 jl	 $e_Exit$56291

; 125  :         goto e_Exit;
; 126  : 
; 127  :     // check for no attribute table and/or no adjacency
; 128  :     if ((m_caeAttributeTable == 0) || (rgdwAdjacency == NULL))

  0009e	8b 06		 mov	 eax, DWORD PTR [esi]
  000a0	85 c0		 test	 eax, eax
  000a2	0f 84 63 03 00
	00		 je	 $e_Exit$56291
  000a8	83 7d 0c 00	 cmp	 DWORD PTR _rgdwAdjacency$[ebp], 0
  000ac	0f 84 59 03 00
	00		 je	 $e_Exit$56291

; 129  :     {
; 130  :         // not attribute sorted!  just return for now
; 131  :         goto e_Exit;
; 132  :     }
; 133  : 
; 134  :     rgaeAttributeTableMesh = new D3DXATTRIBUTERANGE[m_caeAttributeTable];

  000b2	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000b5	c1 e0 02	 shl	 eax, 2
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000be	89 45 e8	 mov	 DWORD PTR _rgaeAttributeTableMesh$[ebp], eax

; 135  :     m_rgaeAttributeTable = new D3DXATTRIBUTERANGE[m_caeAttributeTable];

  000c1	8b 06		 mov	 eax, DWORD PTR [esi]
  000c3	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000c6	c1 e0 02	 shl	 eax, 2
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 136  :     if ((rgaeAttributeTableMesh == NULL) || (rgaeAttributeTableMesh == NULL))

  000cf	83 7d e8 00	 cmp	 DWORD PTR _rgaeAttributeTableMesh$[ebp], 0
  000d3	59		 pop	 ecx
  000d4	59		 pop	 ecx
  000d5	89 83 18 02 00
	00		 mov	 DWORD PTR [ebx+536], eax
  000db	0f 84 58 03 00
	00		 je	 $L56307

; 139  :         goto e_Exit;
; 140  :     }
; 141  : 
; 142  :     hr = ptmMesh->GetAttributeTable(rgaeAttributeTableMesh, NULL);

  000e1	8b 07		 mov	 eax, DWORD PTR [edi]
  000e3	6a 00		 push	 0
  000e5	ff 75 e8	 push	 DWORD PTR _rgaeAttributeTableMesh$[ebp]
  000e8	57		 push	 edi
  000e9	ff 50 4c	 call	 DWORD PTR [eax+76]

; 143  :     if (FAILED(hr))

  000ec	33 d2		 xor	 edx, edx
  000ee	3b c2		 cmp	 eax, edx
  000f0	89 45 e4	 mov	 DWORD PTR _hr$[ebp], eax
  000f3	0f 8c 12 03 00
	00		 jl	 $e_Exit$56291

; 144  :         goto e_Exit;
; 145  : 
; 146  :     // now initialize the edge attribute table
; 147  :     for (iAttr = 0; iAttr < m_caeAttributeTable; iAttr++)

  000f9	39 16		 cmp	 DWORD PTR [esi], edx
  000fb	76 3a		 jbe	 SHORT $L56315
  000fd	33 c0		 xor	 eax, eax
$L56313:

; 148  :     {
; 149  :         m_rgaeAttributeTable[iAttr] = rgaeAttributeTableMesh[iAttr];

  000ff	8b bb 18 02 00
	00		 mov	 edi, DWORD PTR [ebx+536]
  00105	8b 4d e8	 mov	 ecx, DWORD PTR _rgaeAttributeTableMesh$[ebp]
  00108	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  0010b	03 f8		 add	 edi, eax
  0010d	6a 05		 push	 5
  0010f	59		 pop	 ecx
  00110	f3 a5		 rep movsd

; 150  :         m_rgaeAttributeTable[iAttr].FaceStart = 0;

  00112	8b 8b 18 02 00
	00		 mov	 ecx, DWORD PTR [ebx+536]
  00118	83 64 01 04 00	 and	 DWORD PTR [ecx+eax+4], 0

; 151  :         m_rgaeAttributeTable[iAttr].FaceCount = 0;

  0011d	8b 8b 18 02 00
	00		 mov	 ecx, DWORD PTR [ebx+536]
  00123	83 64 01 08 00	 and	 DWORD PTR [ecx+eax+8], 0
  00128	42		 inc	 edx
  00129	83 c0 14	 add	 eax, 20			; 00000014H
  0012c	3b 93 1c 02 00
	00		 cmp	 edx, DWORD PTR [ebx+540]
  00132	72 cb		 jb	 SHORT $L56313

; 144  :         goto e_Exit;
; 145  : 
; 146  :     // now initialize the edge attribute table
; 147  :     for (iAttr = 0; iAttr < m_caeAttributeTable; iAttr++)

  00134	8b 7d 08	 mov	 edi, DWORD PTR _ptmMesh$[ebp]
$L56315:

; 152  :     }
; 153  : 
; 154  :     ptmMesh->LockIndexBuffer(D3DLOCK_READONLY, (LPVOID*)&pbFaceIndices);

  00137	8b 07		 mov	 eax, DWORD PTR [edi]
  00139	8d 4d f4	 lea	 ecx, DWORD PTR _pbFaceIndices$[ebp]
  0013c	51		 push	 ecx
  0013d	6a 10		 push	 16			; 00000010H
  0013f	57		 push	 edi
  00140	ff 50 44	 call	 DWORD PTR [eax+68]

; 155  : 
; 156  :     for (iAttr = 0; iAttr < m_caeAttributeTable; iAttr++)

  00143	83 65 f0 00	 and	 DWORD PTR _iAttr$[ebp], 0
  00147	8d bb 1c 02 00
	00		 lea	 edi, DWORD PTR [ebx+540]
  0014d	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00150	0f 86 98 00 00
	00		 jbe	 $L56319
  00156	8b 45 e8	 mov	 eax, DWORD PTR _rgaeAttributeTableMesh$[ebp]
  00159	c7 45 ec fc ff
	ff ff		 mov	 DWORD PTR tv840[ebp], -4 ; fffffffcH
  00160	29 45 ec	 sub	 DWORD PTR tv840[ebp], eax
  00163	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
$L56317:

; 157  :     {
; 158  :         // first figure out the counts for the number of creases per attribute group
; 159  :         iFaceEnd = rgaeAttributeTableMesh[iAttr].FaceStart + rgaeAttributeTableMesh[iAttr].FaceCount;

  00166	8b 3e		 mov	 edi, DWORD PTR [esi]
  00168	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0016b	03 cf		 add	 ecx, edi

; 160  :         for (iFace = rgaeAttributeTableMesh[iAttr].FaceStart; iFace < iFaceEnd; iFace++)

  0016d	3b f9		 cmp	 edi, ecx
  0016f	89 4d e0	 mov	 DWORD PTR _iFaceEnd$[ebp], ecx
  00172	73 63		 jae	 SHORT $L56318
  00174	8b 55 0c	 mov	 edx, DWORD PTR _rgdwAdjacency$[ebp]
  00177	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  0017a	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
$L56320:

; 161  :         {
; 162  :             for (iPoint = 0; iPoint < 3; iPoint++)

  0017d	83 65 fc 00	 and	 DWORD PTR _iPoint$[ebp], 0
  00181	89 45 f8	 mov	 DWORD PTR tv758[ebp], eax
$L56323:

; 163  :             {
; 164  :                 dwNeighbor = rgdwAdjacency[iFace * 3 + iPoint];
; 165  : 
; 166  :                 // if the neigbor is less than the current face, we have already looked at this edge
; 167  :                 //    if unused, just skip... not a crease
; 168  :                 if (dwNeighbor < iFace)

  00184	8b 45 f8	 mov	 eax, DWORD PTR tv758[ebp]
  00187	39 38		 cmp	 DWORD PTR [eax], edi
  00189	72 37		 jb	 SHORT $L56324

; 169  :                     continue;
; 170  : 
; 171  :                 if (b16BitIndex)

  0018b	83 7d d8 00	 cmp	 DWORD PTR _b16BitIndex$[ebp], 0

; 172  :                 {
; 173  :                     bCrease = BCrease<UINT16>(iFace, iPoint, rgdwAdjacency, (UINT16*)pbFaceIndices);

  0018f	ff 75 f4	 push	 DWORD PTR _pbFaceIndices$[ebp]
  00192	ff 75 0c	 push	 DWORD PTR _rgdwAdjacency$[ebp]
  00195	ff 75 fc	 push	 DWORD PTR _iPoint$[ebp]
  00198	57		 push	 edi
  00199	74 07		 je	 SHORT $L56327
  0019b	e8 00 00 00 00	 call	 ??$BCrease@G@@YAHKKPAKPAG@Z ; BCrease<unsigned short>

; 174  :                 }
; 175  :                 else

  001a0	eb 05		 jmp	 SHORT $L56540
$L56327:

; 176  :                 {
; 177  :                     bCrease = BCrease<UINT32>(iFace, iPoint, rgdwAdjacency, (UINT32*)pbFaceIndices);

  001a2	e8 00 00 00 00	 call	 ??$BCrease@I@@YAHKKPAKPAI@Z ; BCrease<unsigned int>
$L56540:
  001a7	83 c4 10	 add	 esp, 16			; 00000010H

; 178  :                 }
; 179  : 
; 180  :                 if (bCrease)

  001aa	85 c0		 test	 eax, eax
  001ac	74 11		 je	 SHORT $L56536

; 181  :                 {
; 182  :                     // add one to the count of creases for this attribute
; 183  :                     m_rgaeAttributeTable[iAttr].FaceCount += 1;

  001ae	8b 45 ec	 mov	 eax, DWORD PTR tv840[ebp]
  001b1	8b 8b 18 02 00
	00		 mov	 ecx, DWORD PTR [ebx+536]
  001b7	03 c6		 add	 eax, esi
  001b9	8d 44 01 08	 lea	 eax, DWORD PTR [ecx+eax+8]
  001bd	ff 00		 inc	 DWORD PTR [eax]
$L56536:
  001bf	8b 4d e0	 mov	 ecx, DWORD PTR _iFaceEnd$[ebp]
$L56324:

; 161  :         {
; 162  :             for (iPoint = 0; iPoint < 3; iPoint++)

  001c2	ff 45 fc	 inc	 DWORD PTR _iPoint$[ebp]
  001c5	83 45 f8 04	 add	 DWORD PTR tv758[ebp], 4
  001c9	83 7d fc 03	 cmp	 DWORD PTR _iPoint$[ebp], 3
  001cd	72 b5		 jb	 SHORT $L56323
  001cf	8b 45 f8	 mov	 eax, DWORD PTR tv758[ebp]
  001d2	47		 inc	 edi
  001d3	3b f9		 cmp	 edi, ecx
  001d5	72 a6		 jb	 SHORT $L56320
$L56318:

; 155  : 
; 156  :     for (iAttr = 0; iAttr < m_caeAttributeTable; iAttr++)

  001d7	ff 45 f0	 inc	 DWORD PTR _iAttr$[ebp]
  001da	8b 45 f0	 mov	 eax, DWORD PTR _iAttr$[ebp]
  001dd	8d bb 1c 02 00
	00		 lea	 edi, DWORD PTR [ebx+540]
  001e3	83 c6 14	 add	 esi, 20			; 00000014H
  001e6	3b 07		 cmp	 eax, DWORD PTR [edi]
  001e8	0f 82 78 ff ff
	ff		 jb	 $L56317
$L56319:

; 184  :                 }
; 185  :             }
; 186  :         }
; 187  :     }
; 188  : 
; 189  :     // now setup the table to have the correct offsets into the index buffer
; 190  :     //   now that we have calculated the FaceCount field (calc the FaceStarts...)
; 191  :     cFacesCur = 0;
; 192  :     for (iAttr = 0; iAttr < m_caeAttributeTable; iAttr++)

  001ee	33 c9		 xor	 ecx, ecx
  001f0	33 f6		 xor	 esi, esi
  001f2	33 d2		 xor	 edx, edx
  001f4	39 0f		 cmp	 DWORD PTR [edi], ecx
  001f6	0f 86 0c 02 00
	00		 jbe	 $L56532
$L56346:

; 193  :     {
; 194  :         m_rgaeAttributeTable[iAttr].FaceStart = cFacesCur;

  001fc	8b 83 18 02 00
	00		 mov	 eax, DWORD PTR [ebx+536]
  00202	89 74 01 04	 mov	 DWORD PTR [ecx+eax+4], esi

; 195  :         cFacesCur += m_rgaeAttributeTable[iAttr].FaceCount;

  00206	8b 83 18 02 00
	00		 mov	 eax, DWORD PTR [ebx+536]
  0020c	8d 44 01 08	 lea	 eax, DWORD PTR [ecx+eax+8]
  00210	03 30		 add	 esi, DWORD PTR [eax]

; 196  : 
; 197  :         // reset the face count, to be used in the second pass as current position in buffer
; 198  :         //   will become the count by the end of the pass
; 199  :         m_rgaeAttributeTable[iAttr].FaceCount = 0;

  00212	83 20 00	 and	 DWORD PTR [eax], 0
  00215	42		 inc	 edx
  00216	83 c1 14	 add	 ecx, 20			; 00000014H
  00219	3b 17		 cmp	 edx, DWORD PTR [edi]
  0021b	72 df		 jb	 SHORT $L56346

; 200  :     }
; 201  : 
; 202  :     // just exit if there are no creases
; 203  :     if (cFacesCur == 0)

  0021d	85 f6		 test	 esi, esi
  0021f	0f 84 e3 01 00
	00		 je	 $L56532

; 204  :         goto e_Exit;
; 205  : 
; 206  :     m_pDevice->GetDeviceCaps(&Caps);

  00225	8b 03		 mov	 eax, DWORD PTR [ebx]
  00227	8b 08		 mov	 ecx, DWORD PTR [eax]
  00229	8d 95 84 fe ff
	ff		 lea	 edx, DWORD PTR _Caps$[ebp]
  0022f	52		 push	 edx
  00230	50		 push	 eax
  00231	ff 51 1c	 call	 DWORD PTR [ecx+28]

; 207  : 
; 208  :     // if there are too many vertices, or the max vertex index is below 16bit (means no 32 bit support)
; 209  :     //    then we need to emulate
; 210  :     if (!b16BitIndex && ((Caps.MaxVertexIndex < ptmMesh->GetNumVertices()) || (Caps.MaxVertexIndex <= 0xffff) || (Caps.MaxPrimitiveCount < cFacesCur)))

  00234	83 7d d8 00	 cmp	 DWORD PTR _b16BitIndex$[ebp], 0
  00238	75 31		 jne	 SHORT $L56533
  0023a	8b 45 08	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  0023d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023f	50		 push	 eax
  00240	ff 51 14	 call	 DWORD PTR [ecx+20]
  00243	39 85 3c ff ff
	ff		 cmp	 DWORD PTR _Caps$[ebp+184], eax
  00249	72 14		 jb	 SHORT $L56352
  0024b	81 bd 3c ff ff
	ff ff ff 00 00	 cmp	 DWORD PTR _Caps$[ebp+184], 65535 ; 0000ffffH
  00255	76 08		 jbe	 SHORT $L56352
  00257	39 b5 38 ff ff
	ff		 cmp	 DWORD PTR _Caps$[ebp+180], esi
  0025d	73 0c		 jae	 SHORT $L56533
$L56352:

; 211  :     {
; 212  :         m_bEmulate32BitIndex = TRUE;

  0025f	c7 83 20 02 00
	00 01 00 00 00	 mov	 DWORD PTR [ebx+544], 1

; 213  :     }
; 214  :     else

  00269	eb 07		 jmp	 SHORT $L56353
$L56533:

; 215  :     {
; 216  :         m_bEmulate32BitIndex = FALSE;

  0026b	83 a3 20 02 00
	00 00		 and	 DWORD PTR [ebx+544], 0
$L56353:

; 217  :     }
; 218  : 
; 219  :     hr = m_pDevice->CreateIndexBuffer(cFacesCur * 2 * cBytesPerIndex, D3DUSAGE_SOFTWAREPROCESSING, 
; 220  :                                         (b16BitIndex ? D3DFMT_INDEX16:D3DFMT_INDEX32),
; 221  :                                         D3DPOOL_MANAGED, &m_pIndexBuffer, NULL);

  00272	8b 03		 mov	 eax, DWORD PTR [ebx]
  00274	8b 10		 mov	 edx, DWORD PTR [eax]
  00276	6a 00		 push	 0
  00278	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  0027b	51		 push	 ecx
  0027c	8b 4d d8	 mov	 ecx, DWORD PTR _b16BitIndex$[ebp]
  0027f	f7 d9		 neg	 ecx
  00281	1b c9		 sbb	 ecx, ecx
  00283	0f af 75 dc	 imul	 esi, DWORD PTR _cBytesPerIndex$[ebp]
  00287	6a 01		 push	 1
  00289	83 c1 66	 add	 ecx, 102		; 00000066H
  0028c	51		 push	 ecx
  0028d	6a 10		 push	 16			; 00000010H
  0028f	d1 e6		 shl	 esi, 1
  00291	56		 push	 esi
  00292	50		 push	 eax
  00293	ff 52 6c	 call	 DWORD PTR [edx+108]

; 222  :     if (FAILED(hr))

  00296	85 c0		 test	 eax, eax
  00298	89 45 e4	 mov	 DWORD PTR _hr$[ebp], eax
  0029b	0f 8c 67 01 00
	00		 jl	 $L56532

; 223  :         goto e_Exit;
; 224  : 
; 225  :     m_pIndexBuffer->Lock(0, 0, (PVOID*)&pbLineIndices, D3DLOCK_NOSYSLOCK);

  002a1	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  002a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a6	68 00 08 00 00	 push	 2048			; 00000800H
  002ab	8d 55 c4	 lea	 edx, DWORD PTR _pbLineIndices$[ebp]
  002ae	52		 push	 edx
  002af	33 f6		 xor	 esi, esi
  002b1	56		 push	 esi
  002b2	56		 push	 esi
  002b3	50		 push	 eax
  002b4	ff 51 2c	 call	 DWORD PTR [ecx+44]

; 226  : 
; 227  : 
; 228  :     // next go through and fill the index buffer
; 229  :     for (iAttr = 0; iAttr < m_caeAttributeTable; iAttr++)

  002b7	39 37		 cmp	 DWORD PTR [edi], esi
  002b9	89 75 f0	 mov	 DWORD PTR _iAttr$[ebp], esi
  002bc	0f 86 46 01 00
	00		 jbe	 $L56532
  002c2	8b 45 e8	 mov	 eax, DWORD PTR _rgaeAttributeTableMesh$[ebp]
  002c5	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  002c8	c7 45 ec fc ff
	ff ff		 mov	 DWORD PTR tv840[ebp], -4 ; fffffffcH
  002cf	29 45 ec	 sub	 DWORD PTR tv840[ebp], eax
  002d2	89 4d d4	 mov	 DWORD PTR tv1026[ebp], ecx
$L56539:

; 230  :     {
; 231  :         // first figure out the counts for the number of creases per attribute group
; 232  :         iFaceEnd = rgaeAttributeTableMesh[iAttr].FaceStart + rgaeAttributeTableMesh[iAttr].FaceCount;

  002d5	8b 31		 mov	 esi, DWORD PTR [ecx]
  002d7	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  002da	03 c6		 add	 eax, esi

; 233  :         for (iFace = rgaeAttributeTableMesh[iAttr].FaceStart; iFace < iFaceEnd; iFace++)

  002dc	3b f0		 cmp	 esi, eax
  002de	89 45 e0	 mov	 DWORD PTR _iFaceEnd$[ebp], eax
  002e1	89 75 c0	 mov	 DWORD PTR _iFace$[ebp], esi
  002e4	0f 83 06 01 00
	00		 jae	 $L56359
  002ea	8b 45 ec	 mov	 eax, DWORD PTR tv840[ebp]
  002ed	8b 7d dc	 mov	 edi, DWORD PTR _cBytesPerIndex$[ebp]
  002f0	03 c1		 add	 eax, ecx
  002f2	8b 55 0c	 mov	 edx, DWORD PTR _rgdwAdjacency$[ebp]
  002f5	89 45 b4	 mov	 DWORD PTR tv551[ebp], eax
  002f8	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  002fb	89 45 c8	 mov	 DWORD PTR tv939[ebp], eax
  002fe	8b c6		 mov	 eax, esi
  00300	0f af c7	 imul	 eax, edi
  00303	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00306	89 45 d0	 mov	 DWORD PTR tv955[ebp], eax
  00309	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  0030c	89 45 b8	 mov	 DWORD PTR tv973[ebp], eax
  0030f	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00312	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
$L56538:

; 234  :         {
; 235  :             for (iPoint = 0; iPoint < 3; iPoint++)

  00315	8b 55 d0	 mov	 edx, DWORD PTR tv955[ebp]
  00318	83 65 fc 00	 and	 DWORD PTR _iPoint$[ebp], 0
  0031c	89 55 cc	 mov	 DWORD PTR tv903[ebp], edx
  0031f	89 45 f8	 mov	 DWORD PTR tv917[ebp], eax
$L56364:

; 236  :             {
; 237  :                 dwNeighbor = rgdwAdjacency[iFace * 3 + iPoint];
; 238  : 
; 239  :                 // if the neigbor is less than the current face, we have already looked at this edge
; 240  :                 //    if unused, just skip... not a crease
; 241  :                 if (dwNeighbor < iFace)

  00322	8b 45 f8	 mov	 eax, DWORD PTR tv917[ebp]
  00325	39 30		 cmp	 DWORD PTR [eax], esi
  00327	0f 82 95 00 00
	00		 jb	 $L56365

; 242  :                     continue;
; 243  : 
; 244  :                 if (b16BitIndex)

  0032d	83 7d d8 00	 cmp	 DWORD PTR _b16BitIndex$[ebp], 0

; 245  :                 {
; 246  :                     bCrease = BCrease<UINT16>(iFace, iPoint, rgdwAdjacency, (UINT16*)pbFaceIndices);

  00331	ff 75 f4	 push	 DWORD PTR _pbFaceIndices$[ebp]
  00334	ff 75 0c	 push	 DWORD PTR _rgdwAdjacency$[ebp]
  00337	ff 75 fc	 push	 DWORD PTR _iPoint$[ebp]
  0033a	56		 push	 esi
  0033b	74 07		 je	 SHORT $L56368
  0033d	e8 00 00 00 00	 call	 ??$BCrease@G@@YAHKKPAKPAG@Z ; BCrease<unsigned short>

; 247  :                 }
; 248  :                 else

  00342	eb 05		 jmp	 SHORT $L56541
$L56368:

; 249  :                 {
; 250  :                     bCrease = BCrease<UINT32>(iFace, iPoint, rgdwAdjacency, (UINT32*)pbFaceIndices);

  00344	e8 00 00 00 00	 call	 ??$BCrease@I@@YAHKKPAKPAI@Z ; BCrease<unsigned int>
$L56541:
  00349	83 c4 10	 add	 esp, 16			; 00000010H

; 251  :                 }
; 252  : 
; 253  :                 if (bCrease)

  0034c	85 c0		 test	 eax, eax
  0034e	74 6f		 je	 SHORT $L56534

; 254  :                 {
; 255  :                     iLineOffset = m_rgaeAttributeTable[iAttr].FaceStart + m_rgaeAttributeTable[iAttr].FaceCount;

  00350	8b 83 18 02 00
	00		 mov	 eax, DWORD PTR [ebx+536]
  00356	8b 4d b4	 mov	 ecx, DWORD PTR tv551[ebp]
  00359	03 c8		 add	 ecx, eax
  0035b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0035e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 256  :                     m_rgaeAttributeTable[iAttr].FaceCount += 1;
; 257  : 
; 258  :                     pbSrc  = pbFaceIndices + ((iFace * 3 + iPoint) * cBytesPerIndex);

  00361	8b 75 cc	 mov	 esi, DWORD PTR tv903[ebp]
  00364	03 c2		 add	 eax, edx

; 259  :                     pbDest = pbLineIndices + iLineOffset * 2 * cBytesPerIndex;

  00366	0f af c7	 imul	 eax, edi
  00369	42		 inc	 edx
  0036a	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0036d	8b 4d c4	 mov	 ecx, DWORD PTR _pbLineIndices$[ebp]
  00370	8b 55 f4	 mov	 edx, DWORD PTR _pbFaceIndices$[ebp]
  00373	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00376	03 f2		 add	 esi, edx

; 260  :                     memcpy(pbDest, pbSrc, cBytesPerIndex);

  00378	8b cf		 mov	 ecx, edi
  0037a	8b f8		 mov	 edi, eax
  0037c	89 45 bc	 mov	 DWORD PTR _pbDest$[ebp], eax
  0037f	8b c1		 mov	 eax, ecx
  00381	c1 e9 02	 shr	 ecx, 2
  00384	f3 a5		 rep movsd
  00386	8b c8		 mov	 ecx, eax

; 261  :                 
; 262  :                     pbSrc  = pbFaceIndices + ((iFace * 3 + ((iPoint+1)%3)) * cBytesPerIndex);

  00388	8b 45 fc	 mov	 eax, DWORD PTR _iPoint$[ebp]
  0038b	83 e1 03	 and	 ecx, 3
  0038e	f3 a4		 rep movsb
  00390	40		 inc	 eax
  00391	6a 03		 push	 3
  00393	33 d2		 xor	 edx, edx
  00395	5e		 pop	 esi
  00396	f7 f6		 div	 esi

; 263  :                     pbDest += cBytesPerIndex;
; 264  :                     memcpy(pbDest, pbSrc, cBytesPerIndex);                

  00398	8b 4d dc	 mov	 ecx, DWORD PTR _cBytesPerIndex$[ebp]
  0039b	8b 45 bc	 mov	 eax, DWORD PTR _pbDest$[ebp]
  0039e	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  003a1	8b f2		 mov	 esi, edx
  003a3	03 75 c8	 add	 esi, DWORD PTR tv939[ebp]
  003a6	0f af f1	 imul	 esi, ecx
  003a9	03 75 f4	 add	 esi, DWORD PTR _pbFaceIndices$[ebp]
  003ac	8b c1		 mov	 eax, ecx
  003ae	c1 e9 02	 shr	 ecx, 2
  003b1	f3 a5		 rep movsd
  003b3	8b c8		 mov	 ecx, eax
  003b5	83 e1 03	 and	 ecx, 3
  003b8	f3 a4		 rep movsb
  003ba	8b 75 c0	 mov	 esi, DWORD PTR _iFace$[ebp]
  003bd	8b f8		 mov	 edi, eax
$L56534:
  003bf	8b 4d d4	 mov	 ecx, DWORD PTR tv1026[ebp]
$L56365:

; 234  :         {
; 235  :             for (iPoint = 0; iPoint < 3; iPoint++)

  003c2	ff 45 fc	 inc	 DWORD PTR _iPoint$[ebp]
  003c5	83 45 f8 04	 add	 DWORD PTR tv917[ebp], 4
  003c9	01 7d cc	 add	 DWORD PTR tv903[ebp], edi
  003cc	83 7d fc 03	 cmp	 DWORD PTR _iPoint$[ebp], 3
  003d0	0f 82 4c ff ff
	ff		 jb	 $L56364
  003d6	8b 45 b8	 mov	 eax, DWORD PTR tv973[ebp]
  003d9	01 45 d0	 add	 DWORD PTR tv955[ebp], eax
  003dc	83 45 c8 03	 add	 DWORD PTR tv939[ebp], 3
  003e0	8b 45 f8	 mov	 eax, DWORD PTR tv917[ebp]
  003e3	46		 inc	 esi
  003e4	3b 75 e0	 cmp	 esi, DWORD PTR _iFaceEnd$[ebp]
  003e7	89 75 c0	 mov	 DWORD PTR _iFace$[ebp], esi
  003ea	0f 82 25 ff ff
	ff		 jb	 $L56538
$L56359:

; 226  : 
; 227  : 
; 228  :     // next go through and fill the index buffer
; 229  :     for (iAttr = 0; iAttr < m_caeAttributeTable; iAttr++)

  003f0	ff 45 f0	 inc	 DWORD PTR _iAttr$[ebp]
  003f3	8b 45 f0	 mov	 eax, DWORD PTR _iAttr$[ebp]
  003f6	83 c1 14	 add	 ecx, 20			; 00000014H
  003f9	3b 83 1c 02 00
	00		 cmp	 eax, DWORD PTR [ebx+540]
  003ff	89 4d d4	 mov	 DWORD PTR tv1026[ebp], ecx
  00402	0f 82 cd fe ff
	ff		 jb	 $L56539
$L56532:

; 265  :                 }
; 266  :             }
; 267  :         }
; 268  :     }

  00408	8b 7d 08	 mov	 edi, DWORD PTR _ptmMesh$[ebp]
$e_Exit$56291:

; 269  : 
; 270  : e_Exit:
; 271  :     delete []rgaeAttributeTableMesh;

  0040b	ff 75 e8	 push	 DWORD PTR _rgaeAttributeTableMesh$[ebp]
  0040e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 272  : 
; 273  :     if (pbFaceIndices != NULL)

  00413	83 7d f4 00	 cmp	 DWORD PTR _pbFaceIndices$[ebp], 0
  00417	59		 pop	 ecx
  00418	74 06		 je	 SHORT $L56374

; 274  :         ptmMesh->UnlockIndexBuffer();

  0041a	8b 07		 mov	 eax, DWORD PTR [edi]
  0041c	57		 push	 edi
  0041d	ff 50 48	 call	 DWORD PTR [eax+72]
$L56374:

; 275  : 
; 276  :     if (pbLineIndices != NULL)

  00420	83 7d c4 00	 cmp	 DWORD PTR _pbLineIndices$[ebp], 0
  00424	74 09		 je	 SHORT $L56375

; 277  :         m_pIndexBuffer->Unlock();

  00426	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00429	8b 03		 mov	 eax, DWORD PTR [ebx]
  0042b	53		 push	 ebx
  0042c	ff 50 30	 call	 DWORD PTR [eax+48]
$L56375:

; 278  : 
; 279  :     return hr;

  0042f	8b 45 e4	 mov	 eax, DWORD PTR _hr$[ebp]
  00432	5f		 pop	 edi
  00433	5e		 pop	 esi
  00434	5b		 pop	 ebx

; 280  : }

  00435	c9		 leave
  00436	c2 08 00	 ret	 8
$L56307:

; 137  :     {
; 138  :         hr = E_OUTOFMEMORY;

  00439	c7 45 e4 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
  00440	eb c9		 jmp	 SHORT $e_Exit$56291
?Init@CEdgeOutline@@QAEJPAUID3DXBaseMesh@@PAK@Z ENDP	; CEdgeOutline::Init
_TEXT	ENDS
END
