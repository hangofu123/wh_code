; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.4035 

	TITLE	.\shownormal.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04IHCGOIEL@mWd1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04KMALLLII@mWd2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LFBAIKMJ@mWd3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04PKFBBMAO@mWd4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04ODEKCNEP@mWd5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04MIGHHOIM@mWd6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04NBHMEPMN@mWd7?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04FGOEFDAC@mWd8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04EPPPGCED@mWd9?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DOMPIIAD@mWd10?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05CHNELJEC@mWd11?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MPJOKIB@mWd12?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05BFOCNLMA@mWd13?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05FKKDENAH@mWd14?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05EDLIHMEG@mWd15?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05GIJFCPIF@mWd16?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HBIOBOME@mWd17?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PGBGACAL@mWd18?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05OPANDDEK@mWd19?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DMIJDGFK@mWd20?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05CFJCAHBL@mWd21?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05OLPFENI@mWd22?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05BHKEGFJJ@mWd23?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05FIOFPDFO@mWd24?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05EBPOMCBP@mWd25?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05GKNDJBNM@mWd26?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HDMIKAJN@mWd27?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PEFALMFC@mWd28?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BEMIBDAE@mTot?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07HHMNENJH@mWorlds?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BFCOOMBD@vScl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04JKCKMDGO@vClr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CShowNormals@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CShowNormals@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CShowNormals@@QAEJPAUID3DXBaseMesh@@KM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@CShowNormals@@QAEJKKPAUID3DXEffect@@0KPAUD3DXMATRIX@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateEmptyOutline@CShowNormals@@AAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??XD3DXVECTOR3@@QAEAAU0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNormal@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PdwGetIndices@CD3DXCrackDecl1@@QAEPAKPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetIndices@DXCrackFVF@@QAEXPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BIndexedWeights@DXCrackFVF@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CWeights@DXCrackFVF@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWeight@DXCrackFVF@@QAEXPAXIM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FGetWeight@CD3DXCrackDecl1@@QAEMPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PvGetNormal@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CWeights@CD3DXCrackDecl1@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BNormal@CD3DXCrackDecl1@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BTexCoord@CD3DXCrackDecl1@@QAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CD3DXCrackDecl1@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DXCrackFVF@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?x_rgszMatrix@@3PAPBDA				; x_rgszMatrix
PUBLIC	??_C@_04IHCGOIEL@mWd1?$AA@			; `string'
PUBLIC	??_C@_04KMALLLII@mWd2?$AA@			; `string'
PUBLIC	??_C@_04LFBAIKMJ@mWd3?$AA@			; `string'
PUBLIC	??_C@_04PKFBBMAO@mWd4?$AA@			; `string'
PUBLIC	??_C@_04ODEKCNEP@mWd5?$AA@			; `string'
PUBLIC	??_C@_04MIGHHOIM@mWd6?$AA@			; `string'
PUBLIC	??_C@_04NBHMEPMN@mWd7?$AA@			; `string'
PUBLIC	??_C@_04FGOEFDAC@mWd8?$AA@			; `string'
PUBLIC	??_C@_04EPPPGCED@mWd9?$AA@			; `string'
PUBLIC	??_C@_05DOMPIIAD@mWd10?$AA@			; `string'
PUBLIC	??_C@_05CHNELJEC@mWd11?$AA@			; `string'
PUBLIC	??_C@_05MPJOKIB@mWd12?$AA@			; `string'
PUBLIC	??_C@_05BFOCNLMA@mWd13?$AA@			; `string'
PUBLIC	??_C@_05FKKDENAH@mWd14?$AA@			; `string'
PUBLIC	??_C@_05EDLIHMEG@mWd15?$AA@			; `string'
PUBLIC	??_C@_05GIJFCPIF@mWd16?$AA@			; `string'
PUBLIC	??_C@_05HBIOBOME@mWd17?$AA@			; `string'
PUBLIC	??_C@_05PGBGACAL@mWd18?$AA@			; `string'
PUBLIC	??_C@_05OPANDDEK@mWd19?$AA@			; `string'
PUBLIC	??_C@_05DMIJDGFK@mWd20?$AA@			; `string'
PUBLIC	??_C@_05CFJCAHBL@mWd21?$AA@			; `string'
PUBLIC	??_C@_05OLPFENI@mWd22?$AA@			; `string'
PUBLIC	??_C@_05BHKEGFJJ@mWd23?$AA@			; `string'
PUBLIC	??_C@_05FIOFPDFO@mWd24?$AA@			; `string'
PUBLIC	??_C@_05EBPOMCBP@mWd25?$AA@			; `string'
PUBLIC	??_C@_05GKNDJBNM@mWd26?$AA@			; `string'
PUBLIC	??_C@_05HDMIKAJN@mWd27?$AA@			; `string'
PUBLIC	??_C@_05PEFALMFC@mWd28?$AA@			; `string'
;	COMDAT ??_C@_04IHCGOIEL@mWd1?$AA@
CONST	SEGMENT
??_C@_04IHCGOIEL@mWd1?$AA@ DB 'mWd1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KMALLLII@mWd2?$AA@
CONST	SEGMENT
??_C@_04KMALLLII@mWd2?$AA@ DB 'mWd2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LFBAIKMJ@mWd3?$AA@
CONST	SEGMENT
??_C@_04LFBAIKMJ@mWd3?$AA@ DB 'mWd3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PKFBBMAO@mWd4?$AA@
CONST	SEGMENT
??_C@_04PKFBBMAO@mWd4?$AA@ DB 'mWd4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ODEKCNEP@mWd5?$AA@
CONST	SEGMENT
??_C@_04ODEKCNEP@mWd5?$AA@ DB 'mWd5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MIGHHOIM@mWd6?$AA@
CONST	SEGMENT
??_C@_04MIGHHOIM@mWd6?$AA@ DB 'mWd6', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NBHMEPMN@mWd7?$AA@
CONST	SEGMENT
??_C@_04NBHMEPMN@mWd7?$AA@ DB 'mWd7', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FGOEFDAC@mWd8?$AA@
CONST	SEGMENT
??_C@_04FGOEFDAC@mWd8?$AA@ DB 'mWd8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EPPPGCED@mWd9?$AA@
CONST	SEGMENT
??_C@_04EPPPGCED@mWd9?$AA@ DB 'mWd9', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DOMPIIAD@mWd10?$AA@
CONST	SEGMENT
??_C@_05DOMPIIAD@mWd10?$AA@ DB 'mWd10', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CHNELJEC@mWd11?$AA@
CONST	SEGMENT
??_C@_05CHNELJEC@mWd11?$AA@ DB 'mWd11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPJOKIB@mWd12?$AA@
CONST	SEGMENT
??_C@_05MPJOKIB@mWd12?$AA@ DB 'mWd12', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BFOCNLMA@mWd13?$AA@
CONST	SEGMENT
??_C@_05BFOCNLMA@mWd13?$AA@ DB 'mWd13', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKKDENAH@mWd14?$AA@
CONST	SEGMENT
??_C@_05FKKDENAH@mWd14?$AA@ DB 'mWd14', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EDLIHMEG@mWd15?$AA@
CONST	SEGMENT
??_C@_05EDLIHMEG@mWd15?$AA@ DB 'mWd15', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GIJFCPIF@mWd16?$AA@
CONST	SEGMENT
??_C@_05GIJFCPIF@mWd16?$AA@ DB 'mWd16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HBIOBOME@mWd17?$AA@
CONST	SEGMENT
??_C@_05HBIOBOME@mWd17?$AA@ DB 'mWd17', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PGBGACAL@mWd18?$AA@
CONST	SEGMENT
??_C@_05PGBGACAL@mWd18?$AA@ DB 'mWd18', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OPANDDEK@mWd19?$AA@
CONST	SEGMENT
??_C@_05OPANDDEK@mWd19?$AA@ DB 'mWd19', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DMIJDGFK@mWd20?$AA@
CONST	SEGMENT
??_C@_05DMIJDGFK@mWd20?$AA@ DB 'mWd20', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFJCAHBL@mWd21?$AA@
CONST	SEGMENT
??_C@_05CFJCAHBL@mWd21?$AA@ DB 'mWd21', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OLPFENI@mWd22?$AA@
CONST	SEGMENT
??_C@_05OLPFENI@mWd22?$AA@ DB 'mWd22', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BHKEGFJJ@mWd23?$AA@
CONST	SEGMENT
??_C@_05BHKEGFJJ@mWd23?$AA@ DB 'mWd23', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FIOFPDFO@mWd24?$AA@
CONST	SEGMENT
??_C@_05FIOFPDFO@mWd24?$AA@ DB 'mWd24', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EBPOMCBP@mWd25?$AA@
CONST	SEGMENT
??_C@_05EBPOMCBP@mWd25?$AA@ DB 'mWd25', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GKNDJBNM@mWd26?$AA@
CONST	SEGMENT
??_C@_05GKNDJBNM@mWd26?$AA@ DB 'mWd26', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDMIKAJN@mWd27?$AA@
CONST	SEGMENT
??_C@_05HDMIKAJN@mWd27?$AA@ DB 'mWd27', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PEFALMFC@mWd28?$AA@
CONST	SEGMENT
??_C@_05PEFALMFC@mWd28?$AA@ DB 'mWd28', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?x_rgszMatrix@@3PAPBDA DD FLAT:??_C@_04IHCGOIEL@mWd1?$AA@ ; x_rgszMatrix
	DD	FLAT:??_C@_04KMALLLII@mWd2?$AA@
	DD	FLAT:??_C@_04LFBAIKMJ@mWd3?$AA@
	DD	FLAT:??_C@_04PKFBBMAO@mWd4?$AA@
	DD	FLAT:??_C@_04ODEKCNEP@mWd5?$AA@
	DD	FLAT:??_C@_04MIGHHOIM@mWd6?$AA@
	DD	FLAT:??_C@_04NBHMEPMN@mWd7?$AA@
	DD	FLAT:??_C@_04FGOEFDAC@mWd8?$AA@
	DD	FLAT:??_C@_04EPPPGCED@mWd9?$AA@
	DD	FLAT:??_C@_05DOMPIIAD@mWd10?$AA@
	DD	FLAT:??_C@_05CHNELJEC@mWd11?$AA@
	DD	FLAT:??_C@_05MPJOKIB@mWd12?$AA@
	DD	FLAT:??_C@_05BFOCNLMA@mWd13?$AA@
	DD	FLAT:??_C@_05FKKDENAH@mWd14?$AA@
	DD	FLAT:??_C@_05EDLIHMEG@mWd15?$AA@
	DD	FLAT:??_C@_05GIJFCPIF@mWd16?$AA@
	DD	FLAT:??_C@_05HBIOBOME@mWd17?$AA@
	DD	FLAT:??_C@_05PGBGACAL@mWd18?$AA@
	DD	FLAT:??_C@_05OPANDDEK@mWd19?$AA@
	DD	FLAT:??_C@_05DMIJDGFK@mWd20?$AA@
	DD	FLAT:??_C@_05CFJCAHBL@mWd21?$AA@
	DD	FLAT:??_C@_05OLPFENI@mWd22?$AA@
	DD	FLAT:??_C@_05BHKEGFJJ@mWd23?$AA@
	DD	FLAT:??_C@_05FIOFPDFO@mWd24?$AA@
	DD	FLAT:??_C@_05EBPOMCBP@mWd25?$AA@
	DD	FLAT:??_C@_05GKNDJBNM@mWd26?$AA@
	DD	FLAT:??_C@_05HDMIKAJN@mWd27?$AA@
	DD	FLAT:??_C@_05PEFALMFC@mWd28?$AA@
_DATA	ENDS
CONST	SEGMENT
_x_rgdwTexCoordSize DD 08H
	DD	0cH
	DD	010H
	DD	04H
_x_rgcbTypeSizes DB 04H
	DB	08H
	DB	0cH
	DB	010H
	DB	04H
	DB	04H
	DB	04H
	DB	08H
	DB	04H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	04H
	DB	04H
	DB	08H
	DB	00H
CONST	ENDS
PUBLIC	??0CShowNormals@@QAE@XZ				; CShowNormals::CShowNormals
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\shownormal.cpp
;	COMDAT ??0CShowNormals@@QAE@XZ
_TEXT	SEGMENT
??0CShowNormals@@QAE@XZ PROC NEAR			; CShowNormals::CShowNormals, COMDAT
; _this$ = ecx

; 38   : {

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0000c	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0000f	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00012	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00015	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 39   : }

  00018	c3		 ret	 0
??0CShowNormals@@QAE@XZ ENDP				; CShowNormals::CShowNormals
_TEXT	ENDS
PUBLIC	??1CShowNormals@@QAE@XZ				; CShowNormals::~CShowNormals
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogs
;	COMDAT ??1CShowNormals@@QAE@XZ
_TEXT	SEGMENT
??1CShowNormals@@QAE@XZ PROC NEAR			; CShowNormals::~CShowNormals, COMDAT
; _this$ = ecx

; 47   : }

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 42   : {

  00003	8b f1		 mov	 esi, ecx

; 43   :     GXRELEASE(m_pVertexBuffer);

  00005	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00008	85 c0		 test	 eax, eax
  0000a	74 0a		 je	 SHORT $L56248
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	50		 push	 eax
  0000f	ff 51 08	 call	 DWORD PTR [ecx+8]
  00012	83 66 04 00	 and	 DWORD PTR [esi+4], 0
$L56248:

; 44   :     GXRELEASE(m_pDevice);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	85 c0		 test	 eax, eax
  0001a	74 09		 je	 SHORT $L56252
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	50		 push	 eax
  0001f	ff 51 08	 call	 DWORD PTR [ecx+8]
  00022	83 26 00	 and	 DWORD PTR [esi], 0
$L56252:

; 45   : 
; 46   :     delete []m_rgaeAttributeTable;

  00025	ff 76 1c	 push	 DWORD PTR [esi+28]
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	59		 pop	 ecx
  0002e	5e		 pop	 esi

; 47   : }

  0002f	c3		 ret	 0
??1CShowNormals@@QAE@XZ ENDP				; CShowNormals::~CShowNormals
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 165  :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	?CreateEmptyOutline@CShowNormals@@AAEJXZ	; CShowNormals::CreateEmptyOutline
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\shownormal.cpp
;	COMDAT ?CreateEmptyOutline@CShowNormals@@AAEJXZ
_TEXT	SEGMENT
?CreateEmptyOutline@CShowNormals@@AAEJXZ PROC NEAR	; CShowNormals::CreateEmptyOutline, COMDAT
; _this$ = ecx

; 484  : }

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 475  : {

  00003	8b f1		 mov	 esi, ecx

; 476  :     delete []m_rgaeAttributeTable;

  00005	ff 76 1c	 push	 DWORD PTR [esi+28]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 477  :     m_rgaeAttributeTable = NULL;
; 478  :     m_caeAttributeTable = 0;
; 479  : 
; 480  :     GXRELEASE(m_pVertexBuffer);

  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	83 66 1c 00	 and	 DWORD PTR [esi+28], 0
  00014	83 66 20 00	 and	 DWORD PTR [esi+32], 0
  00018	85 c0		 test	 eax, eax
  0001a	59		 pop	 ecx
  0001b	74 0a		 je	 SHORT $L56446
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	50		 push	 eax
  00020	ff 51 08	 call	 DWORD PTR [ecx+8]
  00023	83 66 04 00	 and	 DWORD PTR [esi+4], 0
$L56446:

; 481  :     GXRELEASE(m_pDevice);

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	85 c0		 test	 eax, eax
  0002b	74 09		 je	 SHORT $L56450
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	50		 push	 eax
  00030	ff 51 08	 call	 DWORD PTR [ecx+8]
  00033	83 26 00	 and	 DWORD PTR [esi], 0
$L56450:

; 482  : 
; 483  :     return S_OK;

  00036	33 c0		 xor	 eax, eax
  00038	5e		 pop	 esi

; 484  : }

  00039	c3		 ret	 0
?CreateEmptyOutline@CShowNormals@@AAEJXZ ENDP		; CShowNormals::CreateEmptyOutline
_TEXT	ENDS
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC NEAR				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 315  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
EXTRN	__fltused:NEAR
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 308  : }

  00000	8b ff		 npad	 2

; 304  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx

; 305  :     x = fx;

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _fx$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 306  :     y = fy;

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _fy$[ebp]
  0000f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 307  :     z = fz;

  00012	8b 4d 10	 mov	 ecx, DWORD PTR _fz$[ebp]
  00015	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 308  : }

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z			; D3DXVECTOR3::operator+=
; Function compile flags: /Ogs
;	COMDAT ??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z PROC NEAR		; D3DXVECTOR3::operator+=, COMDAT
; _this$ = ecx

; 332  :     return *this;
; 333  : }

  00000	8b ff		 npad	 2

; 328  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx

; 329  :     x += v.x;

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0000a	d9 01		 fld	 DWORD PTR [ecx]
  0000c	d8 00		 fadd	 DWORD PTR [eax]
  0000e	d9 18		 fstp	 DWORD PTR [eax]

; 330  :     y += v.y;

  00010	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00013	d8 40 04	 fadd	 DWORD PTR [eax+4]
  00016	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 331  :     z += v.z;

  00019	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0001c	d8 40 08	 fadd	 DWORD PTR [eax+8]
  0001f	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 332  :     return *this;
; 333  : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+=
_TEXT	ENDS
PUBLIC	??XD3DXVECTOR3@@QAEAAU0@M@Z			; D3DXVECTOR3::operator*=
; Function compile flags: /Ogs
;	COMDAT ??XD3DXVECTOR3@@QAEAAU0@M@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
??XD3DXVECTOR3@@QAEAAU0@M@Z PROC NEAR			; D3DXVECTOR3::operator*=, COMDAT
; _this$ = ecx

; 350  :     return *this;
; 351  : }

  00000	8b ff		 npad	 2

; 346  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 347  :     x *= f;

  00005	d9 45 08	 fld	 DWORD PTR _f$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	d8 08		 fmul	 DWORD PTR [eax]
  0000c	d9 18		 fstp	 DWORD PTR [eax]

; 348  :     y *= f;

  0000e	d9 45 08	 fld	 DWORD PTR _f$[ebp]
  00011	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00014	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 349  :     z *= f;

  00017	d9 45 08	 fld	 DWORD PTR _f$[ebp]
  0001a	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001d	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 350  :     return *this;
; 351  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??XD3DXVECTOR3@@QAEAAU0@M@Z ENDP			; D3DXVECTOR3::operator*=
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR4@@QAE@MMMM@Z			; D3DXVECTOR4::D3DXVECTOR4
; Function compile flags: /Ogs
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
_fw$ = 20						; size = 4
??0D3DXVECTOR4@@QAE@MMMM@Z PROC NEAR			; D3DXVECTOR4::D3DXVECTOR4, COMDAT
; _this$ = ecx

; 544  : }

  00000	8b ff		 npad	 2

; 539  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx

; 540  :     x = fx;

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _fx$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 541  :     y = fy;

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _fy$[ebp]
  0000f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 542  :     z = fz;

  00012	8b 4d 10	 mov	 ecx, DWORD PTR _fz$[ebp]
  00015	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 543  :     w = fw;

  00018	8b 4d 14	 mov	 ecx, DWORD PTR _fw$[ebp]
  0001b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 544  : }

  0001e	5d		 pop	 ebp
  0001f	c2 10 00	 ret	 16			; 00000010H
??0D3DXVECTOR4@@QAE@MMMM@Z ENDP				; D3DXVECTOR4::D3DXVECTOR4
_TEXT	ENDS
PUBLIC	__real@3b808081
PUBLIC	??0D3DXCOLOR@@QAE@K@Z				; D3DXCOLOR::D3DXCOLOR
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
; Function compile flags: /Ogs
CONST	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@K@Z
_TEXT	SEGMENT
tv186 = 8						; size = 4
tv185 = 8						; size = 4
tv184 = 8						; size = 4
tv183 = 8						; size = 4
_dw$ = 8						; size = 4
??0D3DXCOLOR@@QAE@K@Z PROC NEAR				; D3DXCOLOR::D3DXCOLOR, COMDAT
; _this$ = ecx

; 1352 : }

  00000	8b ff		 npad	 2

; 1346 : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1347 :     CONST FLOAT f = 1.0f / 255.0f;
; 1348 :     r = f * (FLOAT) (unsigned char) (dw >> 16);

  00005	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3b808081
  0000b	8b c1		 mov	 eax, ecx
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _dw$[ebp]
  00010	8b d1		 mov	 edx, ecx
  00012	c1 ea 10	 shr	 edx, 16			; 00000010H
  00015	0f b6 d2	 movzx	 edx, dl
  00018	89 55 08	 mov	 DWORD PTR tv186[ebp], edx

; 1349 :     g = f * (FLOAT) (unsigned char) (dw >>  8);

  0001b	8b d1		 mov	 edx, ecx
  0001d	c1 ea 08	 shr	 edx, 8
  00020	db 45 08	 fild	 DWORD PTR tv186[ebp]
  00023	0f b6 d2	 movzx	 edx, dl
  00026	d8 c9		 fmul	 ST(0), ST(1)
  00028	89 55 08	 mov	 DWORD PTR tv185[ebp], edx

; 1350 :     b = f * (FLOAT) (unsigned char) (dw >>  0);

  0002b	0f b6 d1	 movzx	 edx, cl
  0002e	d9 18		 fstp	 DWORD PTR [eax]
  00030	db 45 08	 fild	 DWORD PTR tv185[ebp]
  00033	89 55 08	 mov	 DWORD PTR tv184[ebp], edx

; 1351 :     a = f * (FLOAT) (unsigned char) (dw >> 24);

  00036	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00039	d8 c9		 fmul	 ST(0), ST(1)
  0003b	d9 58 04	 fstp	 DWORD PTR [eax+4]
  0003e	db 45 08	 fild	 DWORD PTR tv184[ebp]
  00041	89 4d 08	 mov	 DWORD PTR tv183[ebp], ecx
  00044	d8 c9		 fmul	 ST(0), ST(1)
  00046	d9 58 08	 fstp	 DWORD PTR [eax+8]
  00049	db 45 08	 fild	 DWORD PTR tv183[ebp]
  0004c	d8 c9		 fmul	 ST(0), ST(1)
  0004e	d9 58 0c	 fstp	 DWORD PTR [eax+12]
  00051	dd d8		 fstp	 ST(0)

; 1352 : }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
??0D3DXCOLOR@@QAE@K@Z ENDP				; D3DXCOLOR::D3DXCOLOR
_TEXT	ENDS
PUBLIC	?CWeights@DXCrackFVF@@QAEKXZ			; DXCrackFVF::CWeights
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\gxcrackfvf.h
;	COMDAT ?CWeights@DXCrackFVF@@QAEKXZ
_TEXT	SEGMENT
?CWeights@DXCrackFVF@@QAEKXZ PROC NEAR			; DXCrackFVF::CWeights, COMDAT
; _this$ = ecx

; 76   :     inline DWORD        CWeights()      { return m_cWeights; }

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	c3		 ret	 0
?CWeights@DXCrackFVF@@QAEKXZ ENDP			; DXCrackFVF::CWeights
_TEXT	ENDS
PUBLIC	?BIndexedWeights@DXCrackFVF@@QAEHXZ		; DXCrackFVF::BIndexedWeights
; Function compile flags: /Ogs
;	COMDAT ?BIndexedWeights@DXCrackFVF@@QAEHXZ
_TEXT	SEGMENT
?BIndexedWeights@DXCrackFVF@@QAEHXZ PROC NEAR		; DXCrackFVF::BIndexedWeights, COMDAT
; _this$ = ecx

; 81   :     inline BOOL         BIndexedWeights() { return (m_dwFVF & D3DFVF_LASTBETA_UBYTE4|D3DFVF_LASTBETA_D3DCOLOR) && m_cWeights; }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  00007	6a 00		 push	 0
  00009	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  0000e	58		 pop	 eax
  0000f	74 06		 je	 SHORT $L56546
  00011	39 41 38	 cmp	 DWORD PTR [ecx+56], eax
  00014	74 01		 je	 SHORT $L56546
  00016	40		 inc	 eax
$L56546:
  00017	c3		 ret	 0
?BIndexedWeights@DXCrackFVF@@QAEHXZ ENDP		; DXCrackFVF::BIndexedWeights
_TEXT	ENDS
PUBLIC	??0DXCrackFVF@@QAE@K@Z				; DXCrackFVF::DXCrackFVF
; Function compile flags: /Ogs
;	COMDAT ??0DXCrackFVF@@QAE@K@Z
_TEXT	SEGMENT
_dwFVF$ = 8						; size = 4
??0DXCrackFVF@@QAE@K@Z PROC NEAR			; DXCrackFVF::DXCrackFVF, COMDAT
; _this$ = ecx

; 192  : }

  00000	8b ff		 npad	 2

; 115  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx
  00007	53		 push	 ebx
  00008	8b 5d 08	 mov	 ebx, DWORD PTR _dwFVF$[ebp]
  0000b	56		 push	 esi

; 116  :     DWORD oCur = 0;
; 117  :     DWORD dwPosition;
; 118  :     DWORD dwTexCoordInfo;
; 119  :     DWORD iTexCoord;
; 120  :     DWORD dwTexCoordSize;
; 121  :     m_oTex[0] = 0;
; 122  : 
; 123  :     dwPosition = dwFVF & D3DFVF_POSITION_MASK;

  0000c	8b d3		 mov	 edx, ebx
  0000e	57		 push	 edi
  0000f	33 ff		 xor	 edi, edi
  00011	81 e2 0e 40 00
	00		 and	 edx, 16398		; 0000400eH
  00017	33 c9		 xor	 ecx, ecx

; 124  : 
; 125  :     if (dwPosition == D3DFVF_XYZ)

  00019	83 fa 02	 cmp	 edx, 2
  0001c	8d 70 18	 lea	 esi, DWORD PTR [eax+24]
  0001f	89 18		 mov	 DWORD PTR [eax], ebx
  00021	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00024	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00027	89 78 10	 mov	 DWORD PTR [eax+16], edi
  0002a	89 78 14	 mov	 DWORD PTR [eax+20], edi
  0002d	89 78 38	 mov	 DWORD PTR [eax+56], edi
  00030	89 78 3c	 mov	 DWORD PTR [eax+60], edi
  00033	89 3e		 mov	 DWORD PTR [esi], edi
  00035	75 05		 jne	 SHORT $L55537

; 126  :     {
; 127  :         oCur += 3 * sizeof(float);

  00037	6a 0c		 push	 12			; 0000000cH
$L56554:
  00039	59		 pop	 ecx

; 128  :     }
; 129  :     else if (dwPosition == D3DFVF_XYZRHW)

  0003a	eb 1d		 jmp	 SHORT $L56551
$L55537:
  0003c	83 fa 04	 cmp	 edx, 4
  0003f	75 04		 jne	 SHORT $L55540

; 130  :     {
; 131  :         oCur += 4 * sizeof(float);

  00041	6a 10		 push	 16			; 00000010H

; 132  :     }
; 133  :     else if (dwPosition >= D3DFVF_XYZB1)

  00043	eb f4		 jmp	 SHORT $L56554
$L55540:
  00045	83 fa 06	 cmp	 edx, 6
  00048	72 0f		 jb	 SHORT $L56551

; 134  :     {
; 135  :         m_cWeights = (dwPosition >> 1) - 2;

  0004a	d1 ea		 shr	 edx, 1
  0004c	8d 4a fe	 lea	 ecx, DWORD PTR [edx-2]
  0004f	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 136  :         oCur += (3 + m_cWeights) * sizeof(float);

  00052	8d 0c 8d 0c 00
	00 00		 lea	 ecx, DWORD PTR [ecx*4+12]
$L56551:

; 137  :     }
; 138  : 
; 139  :     if ( dwFVF & D3DFVF_NORMAL )

  00059	f6 c3 10	 test	 bl, 16			; 00000010H
  0005c	74 06		 je	 SHORT $L55545

; 140  :     {
; 141  :         m_oNormal = oCur;

  0005e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 142  :         oCur += 3 * sizeof(float);

  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
$L55545:

; 143  :     }
; 144  : 
; 145  :     if ( dwFVF & D3DFVF_PSIZE )

  00064	f6 c3 20	 test	 bl, 32			; 00000020H
  00067	74 06		 je	 SHORT $L56552

; 146  :     {
; 147  :         m_oPointSize = oCur;

  00069	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 148  :         oCur += sizeof(float);

  0006c	83 c1 04	 add	 ecx, 4
$L56552:

; 149  :     }
; 150  : 
; 151  :     if ( dwFVF & D3DFVF_DIFFUSE )

  0006f	f6 c3 40	 test	 bl, 64			; 00000040H
  00072	74 06		 je	 SHORT $L56553

; 152  :     {
; 153  :         m_oDiffuse = oCur;

  00074	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 154  :         oCur += sizeof(D3DCOLOR);

  00077	83 c1 04	 add	 ecx, 4
$L56553:

; 155  :     }
; 156  : 
; 157  :     if ( dwFVF & D3DFVF_SPECULAR )

  0007a	84 db		 test	 bl, bl
  0007c	79 06		 jns	 SHORT $L55551

; 158  :     {
; 159  :         m_oSpecular = oCur;

  0007e	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 160  :         oCur += sizeof(D3DCOLOR);

  00081	83 c1 04	 add	 ecx, 4
$L55551:

; 161  :     }
; 162  : 
; 163  :     if ( dwFVF & D3DFVF_TEXCOUNT_MASK )

  00084	f6 c7 0f	 test	 bh, 15			; 0000000fH
  00087	74 3d		 je	 SHORT $L55557

; 164  :     {
; 165  :         m_oTex[0] = oCur;
; 166  : 
; 167  :         // only one tu/tv set currently supported
; 168  : 
; 169  :         m_cTexCoords = ((dwFVF & D3DFVF_TEXCOUNT_MASK)>>D3DFVF_TEXCOUNT_SHIFT);

  00089	8b d3		 mov	 edx, ebx
  0008b	c1 ea 08	 shr	 edx, 8
  0008e	83 e2 0f	 and	 edx, 15			; 0000000fH

; 170  : 
; 171  :         if(m_cTexCoords > 8)

  00091	83 fa 08	 cmp	 edx, 8
  00094	89 0e		 mov	 DWORD PTR [esi], ecx
  00096	89 50 3c	 mov	 DWORD PTR [eax+60], edx
  00099	76 07		 jbe	 SHORT $L55554

; 172  :             m_cTexCoords = 8;

  0009b	c7 40 3c 08 00
	00 00		 mov	 DWORD PTR [eax+60], 8
$L55554:

; 173  : 
; 174  :         // all 2d, then go quick route
; 175  :         //if ((dwFVF & 0xffff0000) == 0)
; 176  :         //{
; 177  :             //oCur += sizeof(float) * 2 * m_cTexCoords;
; 178  :         //}
; 179  :         //else
; 180  :         {
; 181  :             dwTexCoordSize = (dwFVF & 0xffff0000) >> 16;

  000a2	c1 eb 10	 shr	 ebx, 16			; 00000010H

; 182  :             for (iTexCoord = 0; iTexCoord < m_cTexCoords; iTexCoord++)

  000a5	33 d2		 xor	 edx, edx
  000a7	39 78 3c	 cmp	 DWORD PTR [eax+60], edi
  000aa	76 1a		 jbe	 SHORT $L55557
$L55555:

; 183  :             {
; 184  :                 m_oTex[iTexCoord] = oCur;
; 185  :                 oCur += x_rgdwTexCoordSize[dwTexCoordSize & 0x3];

  000ac	8b fb		 mov	 edi, ebx
  000ae	83 e7 03	 and	 edi, 3
  000b1	89 0e		 mov	 DWORD PTR [esi], ecx
  000b3	03 0c bd 00 00
	00 00		 add	 ecx, DWORD PTR _x_rgdwTexCoordSize[edi*4]

; 186  :                 dwTexCoordSize = dwTexCoordSize >> 2;

  000ba	c1 eb 02	 shr	 ebx, 2
  000bd	42		 inc	 edx
  000be	83 c6 04	 add	 esi, 4
  000c1	3b 50 3c	 cmp	 edx, DWORD PTR [eax+60]
  000c4	72 e6		 jb	 SHORT $L55555
$L55557:
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi

; 187  :             }
; 188  :         }
; 189  :     }
; 190  : 
; 191  :     m_cBytesPerVertex = oCur;

  000c8	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000cb	5b		 pop	 ebx

; 192  : }

  000cc	5d		 pop	 ebp
  000cd	c2 04 00	 ret	 4
??0DXCrackFVF@@QAE@K@Z ENDP				; DXCrackFVF::DXCrackFVF
_TEXT	ENDS
PUBLIC	?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetPosition
; Function compile flags: /Ogs
;	COMDAT ?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_pvPos$ = 12						; size = 4
?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z PROC NEAR ; DXCrackFVF::SetPosition, COMDAT
; _this$ = ecx

; 211  : }

  00000	8b ff		 npad	 2

; 209  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 210  :     memcpy(pvPoint, pvPos, sizeof(D3DXVECTOR3));

  00006	8b 75 0c	 mov	 esi, DWORD PTR _pvPos$[ebp]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _pvPoint$[ebp]
  0000d	a5		 movsd
  0000e	a5		 movsd
  0000f	a5		 movsd
  00010	5f		 pop	 edi
  00011	5e		 pop	 esi

; 211  : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ENDP	; DXCrackFVF::SetPosition
_TEXT	ENDS
PUBLIC	?SetNormal@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetNormal
; Function compile flags: /Ogs
;	COMDAT ?SetNormal@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_pvNormal$ = 12						; size = 4
?SetNormal@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z PROC NEAR ; DXCrackFVF::SetNormal, COMDAT
; _this$ = ecx

; 223  :     }
; 224  : }

  00000	8b ff		 npad	 2

; 219  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 220  :     if (m_oNormal)

  00005	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00008	85 c0		 test	 eax, eax
  0000a	74 10		 je	 SHORT $L55575

; 221  :     {
; 222  :         memcpy(((PBYTE)pvPoint) + m_oNormal, pvNormal, sizeof(D3DXVECTOR3));

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pvPoint$[ebp]
  0000f	56		 push	 esi
  00010	8b 75 0c	 mov	 esi, DWORD PTR _pvNormal$[ebp]
  00013	57		 push	 edi
  00014	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  00017	a5		 movsd
  00018	a5		 movsd
  00019	a5		 movsd
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
$L55575:

; 223  :     }
; 224  : }

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?SetNormal@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ENDP	; DXCrackFVF::SetNormal
_TEXT	ENDS
PUBLIC	?SetWeight@DXCrackFVF@@QAEXPAXIM@Z		; DXCrackFVF::SetWeight
; Function compile flags: /Ogs
;	COMDAT ?SetWeight@DXCrackFVF@@QAEXPAXIM@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_iWeight$ = 12						; size = 4
_fWeight$ = 16						; size = 4
?SetWeight@DXCrackFVF@@QAEXPAXIM@Z PROC NEAR		; DXCrackFVF::SetWeight, COMDAT
; _this$ = ecx

; 331  :     }
; 332  : }

  00000	8b ff		 npad	 2

; 327  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 328  :     if (iWeight < m_cWeights)

  00005	8b 45 0c	 mov	 eax, DWORD PTR _iWeight$[ebp]
  00008	3b 41 38	 cmp	 eax, DWORD PTR [ecx+56]
  0000b	73 0a		 jae	 SHORT $L55652

; 329  :     {
; 330  :         memcpy(((PBYTE)pvPoint) + sizeof(D3DXVECTOR3) + sizeof(float) * iWeight, &fWeight, sizeof(float));

  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _fWeight$[ebp]
  00010	8b 55 08	 mov	 edx, DWORD PTR _pvPoint$[ebp]
  00013	89 4c 82 0c	 mov	 DWORD PTR [edx+eax*4+12], ecx
$L55652:

; 331  :     }
; 332  : }

  00017	5d		 pop	 ebp
  00018	c2 0c 00	 ret	 12			; 0000000cH
?SetWeight@DXCrackFVF@@QAEXPAXIM@Z ENDP			; DXCrackFVF::SetWeight
_TEXT	ENDS
PUBLIC	?SetIndices@DXCrackFVF@@QAEXPAXK@Z		; DXCrackFVF::SetIndices
; Function compile flags: /Ogs
;	COMDAT ?SetIndices@DXCrackFVF@@QAEXPAXK@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_dwIndices$ = 12					; size = 4
?SetIndices@DXCrackFVF@@QAEXPAXK@Z PROC NEAR		; DXCrackFVF::SetIndices, COMDAT
; _this$ = ecx

; 355  :     }
; 356  : }

  00000	8b ff		 npad	 2

; 351  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 352  :     if (BIndexedWeights())

  00008	e8 00 00 00 00	 call	 ?BIndexedWeights@DXCrackFVF@@QAEHXZ ; DXCrackFVF::BIndexedWeights
  0000d	85 c0		 test	 eax, eax
  0000f	74 0d		 je	 SHORT $L55671

; 353  :     {
; 354  :         *((LPDWORD)(((PBYTE)pvPoint) + sizeof(D3DXVECTOR3) + sizeof(float) * (CWeights() - 1))) = dwIndices;

  00011	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _dwIndices$[ebp]
  00017	8b 55 08	 mov	 edx, DWORD PTR _pvPoint$[ebp]
  0001a	89 4c 82 08	 mov	 DWORD PTR [edx+eax*4+8], ecx
$L55671:
  0001e	5e		 pop	 esi

; 355  :     }
; 356  : }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?SetIndices@DXCrackFVF@@QAEXPAXK@Z ENDP			; DXCrackFVF::SetIndices
_TEXT	ENDS
PUBLIC	?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ	; CD3DXCrackDecl1::BIndexedWeights
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\crackdecl.h
;	COMDAT ?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ
_TEXT	SEGMENT
?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ PROC NEAR	; CD3DXCrackDecl1::BIndexedWeights, COMDAT
; _this$ = ecx

; 184  :     BOOL BIndexedWeights()                           { return pIndexElement != NULL; }

  00000	33 c0		 xor	 eax, eax
  00002	39 81 90 00 00
	00		 cmp	 DWORD PTR [ecx+144], eax
  00008	0f 95 c0	 setne	 al
  0000b	c3		 ret	 0
?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ ENDP		; CD3DXCrackDecl1::BIndexedWeights
_TEXT	ENDS
PUBLIC	?BNormal@CD3DXCrackDecl1@@QAEHXZ		; CD3DXCrackDecl1::BNormal
; Function compile flags: /Ogs
;	COMDAT ?BNormal@CD3DXCrackDecl1@@QAEHXZ
_TEXT	SEGMENT
?BNormal@CD3DXCrackDecl1@@QAEHXZ PROC NEAR		; CD3DXCrackDecl1::BNormal, COMDAT
; _this$ = ecx

; 185  :     BOOL BNormal()                                   { return pNormalElement != NULL; }

  00000	33 c0		 xor	 eax, eax
  00002	39 81 94 00 00
	00		 cmp	 DWORD PTR [ecx+148], eax
  00008	0f 95 c0	 setne	 al
  0000b	c3		 ret	 0
?BNormal@CD3DXCrackDecl1@@QAEHXZ ENDP			; CD3DXCrackDecl1::BNormal
_TEXT	ENDS
PUBLIC	?BTexCoord@CD3DXCrackDecl1@@QAEHI@Z		; CD3DXCrackDecl1::BTexCoord
; Function compile flags: /Ogs
;	COMDAT ?BTexCoord@CD3DXCrackDecl1@@QAEHI@Z
_TEXT	SEGMENT
_iTexCoord$ = 8						; size = 4
?BTexCoord@CD3DXCrackDecl1@@QAEHI@Z PROC NEAR		; CD3DXCrackDecl1::BTexCoord, COMDAT
; _this$ = ecx

; 188  :     BOOL BTexCoord(UINT iTexCoord)                   { return rgpTextureElements[iTexCoord] != NULL; }

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 55 08	 mov	 edx, DWORD PTR _iTexCoord$[ebp]
  00008	33 c0		 xor	 eax, eax
  0000a	39 84 91 a0 00
	00 00		 cmp	 DWORD PTR [ecx+edx*4+160], eax
  00011	0f 95 c0	 setne	 al
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?BTexCoord@CD3DXCrackDecl1@@QAEHI@Z ENDP		; CD3DXCrackDecl1::BTexCoord
_TEXT	ENDS
PUBLIC	?CWeights@CD3DXCrackDecl1@@QAEHXZ		; CD3DXCrackDecl1::CWeights
; Function compile flags: /Ogs
;	COMDAT ?CWeights@CD3DXCrackDecl1@@QAEHXZ
_TEXT	SEGMENT
?CWeights@CD3DXCrackDecl1@@QAEHXZ PROC NEAR		; CD3DXCrackDecl1::CWeights, COMDAT
; _this$ = ecx

; 190  :     BOOL CWeights()                                  { return pWeightElement == NULL ? 0 : (pWeightElement->Type - D3DDECLTYPE_FLOAT1) + 1; }

  00000	8b 81 8c 00 00
	00		 mov	 eax, DWORD PTR [ecx+140]
  00006	85 c0		 test	 eax, eax
  00008	75 01		 jne	 SHORT $L56569
  0000a	c3		 ret	 0
$L56569:
  0000b	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0000f	40		 inc	 eax
  00010	c3		 ret	 0
?CWeights@CD3DXCrackDecl1@@QAEHXZ ENDP			; CD3DXCrackDecl1::CWeights
_TEXT	ENDS
PUBLIC	?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z ; CD3DXCrackDecl1::PvGetPosition
; Function compile flags: /Ogs
;	COMDAT ?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z PROC NEAR ; CD3DXCrackDecl1::PvGetPosition, COMDAT
; _this$ = ecx

; 192  :     LPD3DXVECTOR3 PvGetPosition(PBYTE pvPoint)       { return (LPD3DXVECTOR3)(pvPoint + pPositionElement->Offset); }

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 81 88 00 00
	00		 mov	 eax, DWORD PTR [ecx+136]
  0000b	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  0000f	03 45 08	 add	 eax, DWORD PTR _pvPoint$[ebp]
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z ENDP ; CD3DXCrackDecl1::PvGetPosition
_TEXT	ENDS
PUBLIC	?PvGetNormal@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z ; CD3DXCrackDecl1::PvGetNormal
; Function compile flags: /Ogs
;	COMDAT ?PvGetNormal@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
?PvGetNormal@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z PROC NEAR ; CD3DXCrackDecl1::PvGetNormal, COMDAT
; _this$ = ecx

; 193  :     LPD3DXVECTOR3 PvGetNormal(PBYTE pvPoint)         { return (LPD3DXVECTOR3)(pvPoint + pNormalElement->Offset); }

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 81 94 00 00
	00		 mov	 eax, DWORD PTR [ecx+148]
  0000b	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  0000f	03 45 08	 add	 eax, DWORD PTR _pvPoint$[ebp]
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?PvGetNormal@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z ENDP ; CD3DXCrackDecl1::PvGetNormal
_TEXT	ENDS
PUBLIC	?PdwGetIndices@CD3DXCrackDecl1@@QAEPAKPAE@Z	; CD3DXCrackDecl1::PdwGetIndices
; Function compile flags: /Ogs
;	COMDAT ?PdwGetIndices@CD3DXCrackDecl1@@QAEPAKPAE@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
?PdwGetIndices@CD3DXCrackDecl1@@QAEPAKPAE@Z PROC NEAR	; CD3DXCrackDecl1::PdwGetIndices, COMDAT
; _this$ = ecx

; 195  :     LPDWORD PdwGetIndices(PBYTE pvPoint)             { return (LPDWORD)(pvPoint + pIndexElement->Offset); }

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 81 90 00 00
	00		 mov	 eax, DWORD PTR [ecx+144]
  0000b	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  0000f	03 45 08	 add	 eax, DWORD PTR _pvPoint$[ebp]
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?PdwGetIndices@CD3DXCrackDecl1@@QAEPAKPAE@Z ENDP	; CD3DXCrackDecl1::PdwGetIndices
_TEXT	ENDS
PUBLIC	?FGetWeight@CD3DXCrackDecl1@@QAEMPAEI@Z		; CD3DXCrackDecl1::FGetWeight
; Function compile flags: /Ogs
;	COMDAT ?FGetWeight@CD3DXCrackDecl1@@QAEMPAEI@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?FGetWeight@CD3DXCrackDecl1@@QAEMPAEI@Z PROC NEAR	; CD3DXCrackDecl1::FGetWeight, COMDAT
; _this$ = ecx

; 196  :     FLOAT FGetWeight(PBYTE pvPoint, UINT iWeight)    { return ((FLOAT*)(pvPoint + pWeightElement->Offset))[iWeight]; }

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 81 8c 00 00
	00		 mov	 eax, DWORD PTR [ecx+140]
  0000b	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  0000f	03 45 08	 add	 eax, DWORD PTR _pvPoint$[ebp]
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _iWeight$[ebp]
  00015	d9 04 88	 fld	 DWORD PTR [eax+ecx*4]
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?FGetWeight@CD3DXCrackDecl1@@QAEMPAEI@Z ENDP		; CD3DXCrackDecl1::FGetWeight
_TEXT	ENDS
PUBLIC	??0CD3DXCrackDecl1@@QAE@XZ			; CD3DXCrackDecl1::CD3DXCrackDecl1
EXTRN	??0CD3DXCrackDecl@@QAE@XZ:NEAR			; CD3DXCrackDecl::CD3DXCrackDecl
; Function compile flags: /Ogs
;	COMDAT ??0CD3DXCrackDecl1@@QAE@XZ
_TEXT	SEGMENT
??0CD3DXCrackDecl1@@QAE@XZ PROC NEAR			; CD3DXCrackDecl1::CD3DXCrackDecl1, COMDAT
; _this$ = ecx

; 254  :         }

  00000	8b ff		 npad	 2
  00002	56		 push	 esi
  00003	57		 push	 edi

; 252  :         {

  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??0CD3DXCrackDecl@@QAE@XZ ; CD3DXCrackDecl::CD3DXCrackDecl
  0000b	33 c0		 xor	 eax, eax

; 253  :         memset(rgpTextureElements, 0, sizeof(LPD3DVERTEXELEMENT9) * 8);

  0000d	6a 08		 push	 8
  0000f	59		 pop	 ecx
  00010	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00016	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax
  0001c	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  00022	89 86 94 00 00
	00		 mov	 DWORD PTR [esi+148], eax
  00028	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax
  0002e	89 86 9c 00 00
	00		 mov	 DWORD PTR [esi+156], eax
  00034	8d be a0 00 00
	00		 lea	 edi, DWORD PTR [esi+160]
  0003a	f3 ab		 rep stosd
  0003c	5f		 pop	 edi

; 254  :         }

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	c3		 ret	 0
??0CD3DXCrackDecl1@@QAE@XZ ENDP				; CD3DXCrackDecl1::CD3DXCrackDecl1
_TEXT	ENDS
PUBLIC	?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z ; CD3DXCrackDecl1::SetDeclaration
EXTRN	_D3DXGetDeclVertexSize@8:NEAR
EXTRN	?SetDeclaration@CD3DXCrackDecl@@QAEJPBU_D3DVERTEXELEMENT9@@@Z:NEAR ; CD3DXCrackDecl::SetDeclaration
; Function compile flags: /Ogs
;	COMDAT ?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z
_TEXT	SEGMENT
_pElementsNew$ = 8					; size = 4
?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z PROC NEAR ; CD3DXCrackDecl1::SetDeclaration, COMDAT
; _this$ = ecx

; 355  :     }

  00000	8b ff		 npad	 2

; 270  :     {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 271  :         CONST D3DVERTEXELEMENT9 *pPlace;
; 272  : 
; 273  :         CD3DXCrackDecl::SetDeclaration(pElementsNew);

  00006	ff 75 08	 push	 DWORD PTR _pElementsNew$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?SetDeclaration@CD3DXCrackDecl@@QAEJPBU_D3DVERTEXELEMENT9@@@Z ; CD3DXCrackDecl::SetDeclaration

; 274  : 
; 275  : #ifdef DEBUG
; 276  :         // this class only works for single stream data types
; 277  :         pPlace = pElementsNew;
; 278  :         while(pPlace->Stream != 0xFF)
; 279  :         {
; 280  :             GXASSERT(pPlace->Stream == 0);
; 281  :             pPlace++;
; 282  :         }
; 283  : #endif
; 284  :         // should be pointing into local copy of declaration
; 285  :         pPlace = pElements;

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	e9 c9 00 00 00	 jmp	 $L56581
$L56019:

; 288  :         {
; 289  :             if (pPlace->UsageIndex == 0 || pPlace->Usage == D3DDECLUSAGE_TEXCOORD || 
; 290  :                 pPlace->Usage == D3DDECLUSAGE_COLOR )

  00017	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0001a	84 d2		 test	 dl, dl
  0001c	74 11		 je	 SHORT $L56022
  0001e	8a 48 06	 mov	 cl, BYTE PTR [eax+6]
  00021	80 f9 05	 cmp	 cl, 5
  00024	74 09		 je	 SHORT $L56022
  00026	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  00029	0f 85 ae 00 00
	00		 jne	 $L56028
$L56022:

; 291  :             {
; 292  :                 switch (pPlace->Usage)

  0002f	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00033	83 e9 00	 sub	 ecx, 0
  00036	0f 84 95 00 00
	00		 je	 $L56027
  0003c	49		 dec	 ecx
  0003d	0f 84 80 00 00
	00		 je	 $L56029
  00043	49		 dec	 ecx
  00044	74 68		 je	 SHORT $L56031
  00046	49		 dec	 ecx
  00047	74 57		 je	 SHORT $L56034
  00049	49		 dec	 ecx
  0004a	49		 dec	 ecx
  0004b	74 3c		 je	 SHORT $L56044
  0004d	83 e9 05	 sub	 ecx, 5
  00050	0f 85 87 00 00
	00		 jne	 $L56028

; 321  : 
; 322  :                 case D3DDECLUSAGE_COLOR:
; 323  :                     if (pPlace->UsageIndex == 0)

  00056	84 d2		 test	 dl, dl
  00058	75 15		 jne	 SHORT $L56037

; 324  :                     {
; 325  :                         if ((pPlace->Type == D3DDECLTYPE_FLOAT4) || (pPlace->Type == D3DDECLTYPE_D3DCOLOR))

  0005a	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  0005d	80 f9 03	 cmp	 cl, 3
  00060	74 05		 je	 SHORT $L56039
  00062	80 f9 04	 cmp	 cl, 4
  00065	75 76		 jne	 SHORT $L56028
$L56039:

; 326  :                         {
; 327  :                             pDiffuseElement = pPlace;

  00067	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax

; 328  :                         }
; 329  :                     }
; 330  :                     else

  0006d	eb 6e		 jmp	 SHORT $L56028
$L56037:

; 331  :                     if (pPlace->UsageIndex == 1)

  0006f	80 fa 01	 cmp	 dl, 1
  00072	75 69		 jne	 SHORT $L56028

; 332  :                     {
; 333  :                         if ((pPlace->Type == D3DDECLTYPE_FLOAT4) || (pPlace->Type == D3DDECLTYPE_D3DCOLOR))

  00074	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  00077	80 f9 03	 cmp	 cl, 3
  0007a	74 05		 je	 SHORT $L56043
  0007c	80 f9 04	 cmp	 cl, 4
  0007f	75 5c		 jne	 SHORT $L56028
$L56043:

; 334  :                         {
; 335  :                             pSpecularElement = pPlace;

  00081	89 86 9c 00 00
	00		 mov	 DWORD PTR [esi+156], eax

; 336  :                         }
; 337  :                     }
; 338  :                     break;

  00087	eb 54		 jmp	 SHORT $L56028
$L56044:

; 339  : 
; 340  :                 case D3DDECLUSAGE_TEXCOORD:
; 341  :                     if ((pPlace->Type >= D3DDECLTYPE_FLOAT1) && (pPlace->Type <= D3DDECLTYPE_FLOAT4) && (pPlace->UsageIndex < 8))

  00089	80 78 04 03	 cmp	 BYTE PTR [eax+4], 3
  0008d	77 4e		 ja	 SHORT $L56028
  0008f	80 fa 08	 cmp	 dl, 8
  00092	73 49		 jae	 SHORT $L56028

; 342  :                     {
; 343  :                         rgpTextureElements[pPlace->UsageIndex] = pPlace;

  00094	0f b6 ca	 movzx	 ecx, dl
  00097	89 84 8e a0 00
	00 00		 mov	 DWORD PTR [esi+ecx*4+160], eax

; 344  :                     }
; 345  :                     break;

  0009e	eb 3d		 jmp	 SHORT $L56028
$L56034:

; 314  : 
; 315  :                 case D3DDECLUSAGE_NORMAL:
; 316  :                     if (pPlace->Type == D3DDECLTYPE_FLOAT3)

  000a0	80 78 04 02	 cmp	 BYTE PTR [eax+4], 2
  000a4	75 37		 jne	 SHORT $L56028

; 317  :                     {
; 318  :                         pNormalElement = pPlace;

  000a6	89 86 94 00 00
	00		 mov	 DWORD PTR [esi+148], eax

; 319  :                     }
; 320  :                     break;

  000ac	eb 2f		 jmp	 SHORT $L56028
$L56031:

; 307  : 
; 308  :                 case D3DDECLUSAGE_BLENDINDICES:
; 309  :                     if ((pPlace->Type == D3DDECLTYPE_UBYTE4) || (pPlace->Type == D3DDECLTYPE_D3DCOLOR))

  000ae	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  000b1	80 f9 05	 cmp	 cl, 5
  000b4	74 05		 je	 SHORT $L56033
  000b6	80 f9 04	 cmp	 cl, 4
  000b9	75 22		 jne	 SHORT $L56028
$L56033:

; 310  :                     {
; 311  :                         pIndexElement = pPlace;

  000bb	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax

; 312  :                     }
; 313  :                     break;

  000c1	eb 1a		 jmp	 SHORT $L56028
$L56029:

; 298  :                     }
; 299  :                     break;
; 300  : 
; 301  :                 case D3DDECLUSAGE_BLENDWEIGHT:
; 302  :                     if ((pPlace->Type >= D3DDECLTYPE_FLOAT1) && (pPlace->Type <= D3DDECLTYPE_FLOAT4))

  000c3	80 78 04 03	 cmp	 BYTE PTR [eax+4], 3
  000c7	77 14		 ja	 SHORT $L56028

; 303  :                     {
; 304  :                         pWeightElement = pPlace;

  000c9	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax

; 305  :                     }
; 306  :                     break;

  000cf	eb 0c		 jmp	 SHORT $L56028
$L56027:

; 293  :                 {
; 294  :                 case D3DDECLUSAGE_POSITION:
; 295  :                     if (pPlace->Type == D3DDECLTYPE_FLOAT3)

  000d1	80 78 04 02	 cmp	 BYTE PTR [eax+4], 2
  000d5	75 06		 jne	 SHORT $L56028

; 296  :                     {
; 297  :                         pPositionElement = pPlace;

  000d7	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
$L56028:

; 346  :                 }
; 347  :             }
; 348  : 
; 349  :             pPlace++;

  000dd	83 c0 08	 add	 eax, 8
$L56581:

; 286  : 
; 287  :         while(pPlace->Stream != 0xFF)

  000e0	66 81 38 ff 00	 cmp	 WORD PTR [eax], 255	; 000000ffH
  000e5	0f 85 2c ff ff
	ff		 jne	 $L56019

; 350  :         }
; 351  : 
; 352  :         m_cBytesPerVertex = D3DXGetDeclVertexSize(pElements,0);

  000eb	6a 00		 push	 0
  000ed	ff 36		 push	 DWORD PTR [esi]
  000ef	e8 00 00 00 00	 call	 _D3DXGetDeclVertexSize@8
  000f4	89 86 c0 00 00
	00		 mov	 DWORD PTR [esi+192], eax

; 353  : 
; 354  :         return S_OK;

  000fa	33 c0		 xor	 eax, eax
  000fc	5e		 pop	 esi

; 355  :     }

  000fd	5d		 pop	 ebp
  000fe	c2 04 00	 ret	 4
?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z ENDP ; CD3DXCrackDecl1::SetDeclaration
_TEXT	ENDS
PUBLIC	?Init@CShowNormals@@QAEJPAUID3DXBaseMesh@@KM@Z	; CShowNormals::Init
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_D3DXVec3Normalize@8:NEAR
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\shownormal.cpp
;	COMDAT ?Init@CShowNormals@@QAEJPAUID3DXBaseMesh@@KM@Z
_TEXT	SEGMENT
_pDecl$ = -1212						; size = 520
_Caps$ = -692						; size = 304
$T56584 = -388						; size = 64
_cdSrc$ = -324						; size = 196
_cfvfDest$ = -128					; size = 64
_vZero$ = -64						; size = 12
$T56695 = -52						; size = 4
_cbSizeOfVector$ = -48					; size = 4
_vPos$ = -44						; size = 12
$T56689 = -32						; size = 4
$T56660 = -32						; size = 4
$T56654 = -32						; size = 4
_vNormal$ = -28						; size = 12
_hr$ = -16						; size = 4
tv204 = -12						; size = 4
tv172 = -12						; size = 4
tv160 = -12						; size = 4
_cVertices$ = -12					; size = 4
_pbSrc$ = -8						; size = 4
_pbDest$ = -4						; size = 4
_ptmMesh$ = 8						; size = 4
_dwTexStage$ = 12					; size = 4
tv363 = 16						; size = 4
$T56672 = 16						; size = 4
$T56666 = 16						; size = 4
_cWeights$ = 16						; size = 4
_fLength$ = 16						; size = 4
?Init@CShowNormals@@QAEJPAUID3DXBaseMesh@@KM@Z PROC NEAR ; CShowNormals::Init, COMDAT
; _this$ = ecx

; 284  : }

  00000	8b ff		 npad	 2

; 58   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec bc 04 00
	00		 sub	 esp, 1212		; 000004bcH
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b d9		 mov	 ebx, ecx

; 59   :     HRESULT hr = S_OK;
; 60   :     PBYTE pbSrc = NULL;

  00010	33 ff		 xor	 edi, edi

; 61   :     PBYTE pbDest = NULL;
; 62   :     DWORD iVertex;
; 63   :     DWORD cVertices;
; 64   :     DXCrackFVF cfvfDest(D3DFVF_XYZ);

  00012	6a 02		 push	 2
  00014	8d 4d 80	 lea	 ecx, DWORD PTR _cfvfDest$[ebp]
  00017	89 7d f8	 mov	 DWORD PTR _pbSrc$[ebp], edi
  0001a	89 7d fc	 mov	 DWORD PTR _pbDest$[ebp], edi
  0001d	e8 00 00 00 00	 call	 ??0DXCrackFVF@@QAE@K@Z	; DXCrackFVF::DXCrackFVF

; 65   :     CD3DXCrackDecl1 cdSrc;

  00022	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _cdSrc$[ebp]
  00028	e8 00 00 00 00	 call	 ??0CD3DXCrackDecl1@@QAE@XZ ; CD3DXCrackDecl1::CD3DXCrackDecl1

; 66   :     D3DXVECTOR3 vPos;
; 67   :     D3DXVECTOR3 vNormal;
; 68   :     D3DXVECTOR3 vZero(0.0f, 0.0f, 0.0f);

  0002d	d9 ee		 fldz

; 69   :     float fSum;
; 70   :     float fWeight;
; 71   :     DWORD iWeight;
; 72   :     D3DCAPS9 Caps;
; 73   :     DWORD cbSizeOfVector;
; 74   :     DWORD cWeights;
; 75   :     D3DVERTEXELEMENT9 pDecl[MAX_FVF_DECL_SIZE];
; 76   :     UINT iAttrib;
; 77   : 
; 78   :     m_fScale = fLength;

  0002f	8b 45 10	 mov	 eax, DWORD PTR _fLength$[ebp]
  00032	d9 5d c0	 fstp	 DWORD PTR _vZero$[ebp]
  00035	d9 ee		 fldz

; 79   : 
; 80   :     hr = CreateEmptyOutline();

  00037	8b cb		 mov	 ecx, ebx
  00039	d9 5d c4	 fstp	 DWORD PTR _vZero$[ebp+4]
  0003c	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  0003f	d9 ee		 fldz
  00041	d9 5d c8	 fstp	 DWORD PTR _vZero$[ebp+8]
  00044	e8 00 00 00 00	 call	 ?CreateEmptyOutline@CShowNormals@@AAEJXZ ; CShowNormals::CreateEmptyOutline

; 81   :     if (FAILED(hr))

  00049	3b c7		 cmp	 eax, edi

; 82   :         goto e_Exit;
; 83   : 
; 84   :     if (ptmMesh == NULL)

  0004b	8b 75 08	 mov	 esi, DWORD PTR _ptmMesh$[ebp]
  0004e	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
  00051	0f 8c b6 04 00
	00		 jl	 $e_Exit$56283
  00057	3b f7		 cmp	 esi, edi
  00059	0f 84 ae 04 00
	00		 je	 $e_Exit$56283

; 85   :         goto e_Exit;
; 86   : 
; 87   :     cVertices = ptmMesh->GetNumVertices();

  0005f	8b 06		 mov	 eax, DWORD PTR [esi]
  00061	56		 push	 esi
  00062	ff 50 14	 call	 DWORD PTR [eax+20]

; 88   : 
; 89   :     ptmMesh->GetDeclaration(pDecl);

  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8d 8d 44 fb ff
	ff		 lea	 ecx, DWORD PTR _pDecl$[ebp]
  0006d	51		 push	 ecx
  0006e	56		 push	 esi
  0006f	ff 50 1c	 call	 DWORD PTR [eax+28]

; 90   :     cdSrc.SetDeclaration(pDecl);;

  00072	8d 85 44 fb ff
	ff		 lea	 eax, DWORD PTR _pDecl$[ebp]
  00078	50		 push	 eax
  00079	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _cdSrc$[ebp]
  0007f	e8 00 00 00 00	 call	 ?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z ; CD3DXCrackDecl1::SetDeclaration

; 91   : 
; 92   :     // if the texture stage is 
; 93   :     if ((dwTexStage != UNUSED32) && !cdSrc.BTexCoord(dwTexStage))

  00084	8b 45 0c	 mov	 eax, DWORD PTR _dwTexStage$[ebp]
  00087	83 f8 ff	 cmp	 eax, -1
  0008a	74 1f		 je	 SHORT $L56744
  0008c	8b 84 85 5c ff
	ff ff		 mov	 eax, DWORD PTR _cdSrc$[ebp+eax*4+160]
  00093	3b c7		 cmp	 eax, edi
  00095	0f 84 72 04 00
	00		 je	 $e_Exit$56283

; 94   :         goto e_Exit;
; 95   : 
; 96   :     if (dwTexStage != UNUSED32)
; 97   :         cbSizeOfVector = x_rgcbTypeSizes[cdSrc.rgpTextureElements[dwTexStage]->Type];

  0009b	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0009f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _x_rgcbTypeSizes[eax]
  000a6	89 45 d0	 mov	 DWORD PTR _cbSizeOfVector$[ebp], eax

; 98   : 
; 99   :     if ((dwTexStage == UNUSED32) && !cdSrc.BNormal())

  000a9	eb 0c		 jmp	 SHORT $L56290
$L56744:
  000ab	39 bd 50 ff ff
	ff		 cmp	 DWORD PTR _cdSrc$[ebp+148], edi
  000b1	0f 84 56 04 00
	00		 je	 $e_Exit$56283
$L56290:

; 100  :         goto e_Exit;
; 101  : 
; 102  :     ptmMesh->GetDevice(&m_pDevice);

  000b7	8b 06		 mov	 eax, DWORD PTR [esi]
  000b9	53		 push	 ebx
  000ba	56		 push	 esi
  000bb	ff 50 28	 call	 DWORD PTR [eax+40]

; 103  : 
; 104  :     m_pDevice->GetDeviceCaps(&Caps);

  000be	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c2	8d 95 4c fd ff
	ff		 lea	 edx, DWORD PTR _Caps$[ebp]
  000c8	52		 push	 edx
  000c9	50		 push	 eax
  000ca	ff 51 1c	 call	 DWORD PTR [ecx+28]

; 105  :     m_bHWVertexShaders = Caps.VertexShaderVersion >= D3DVS_VERSION(1,1);

  000cd	81 bd 10 fe ff
	ff 01 01 fe ff	 cmp	 DWORD PTR _Caps$[ebp+196], -130815 ; fffe0101H

; 106  : 
; 107  :     hr = ptmMesh->GetAttributeTable(NULL, &m_caeAttributeTable);

  000d7	8d 7b 20	 lea	 edi, DWORD PTR [ebx+32]
  000da	1b c0		 sbb	 eax, eax
  000dc	57		 push	 edi
  000dd	40		 inc	 eax
  000de	6a 00		 push	 0
  000e0	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  000e3	8b 06		 mov	 eax, DWORD PTR [esi]
  000e5	56		 push	 esi
  000e6	ff 50 4c	 call	 DWORD PTR [eax+76]

; 108  :     if (FAILED(hr))

  000e9	85 c0		 test	 eax, eax
  000eb	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
  000ee	0f 8c 19 04 00
	00		 jl	 $e_Exit$56283

; 109  :         goto e_Exit;
; 110  : 
; 111  :     if (m_caeAttributeTable == 0)

  000f4	8b 07		 mov	 eax, DWORD PTR [edi]
  000f6	85 c0		 test	 eax, eax
  000f8	0f 84 0f 04 00
	00		 je	 $e_Exit$56283

; 112  :     {
; 113  :         // not attribute sorted!  just return for now
; 114  :         goto e_Exit;
; 115  :     }
; 116  : 
; 117  :     m_rgaeAttributeTable = new D3DXATTRIBUTERANGE[m_caeAttributeTable];

  000fe	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00101	c1 e0 02	 shl	 eax, 2
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0010a	59		 pop	 ecx

; 118  :     if (m_rgaeAttributeTable == NULL)

  0010b	33 c9		 xor	 ecx, ecx
  0010d	3b c1		 cmp	 eax, ecx
  0010f	89 45 f4	 mov	 DWORD PTR tv160[ebp], eax
  00112	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  00115	75 0c		 jne	 SHORT $L56299

; 119  :     {
; 120  :         hr = E_OUTOFMEMORY;

  00117	c7 45 f0 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 272  :         }

  0011e	e9 ea 03 00 00	 jmp	 $e_Exit$56283
$L56299:

; 121  :         goto e_Exit;
; 122  :     }
; 123  : 
; 124  :     if ((cdSrc.CWeights() > 0) && !cdSrc.BIndexedWeights())

  00123	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _cdSrc$[ebp+140]
  00129	3b c1		 cmp	 eax, ecx
  0012b	74 4b		 je	 SHORT $L56305
  0012d	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00131	40		 inc	 eax
  00132	3b c1		 cmp	 eax, ecx
  00134	7e 42		 jle	 SHORT $L56305
  00136	39 8d 4c ff ff
	ff		 cmp	 DWORD PTR _cdSrc$[ebp+144], ecx
  0013c	75 26		 jne	 SHORT $L56621

; 125  :     {
; 126  :         m_bSkinning = TRUE;

  0013e	c7 43 0c 01 00
	00 00		 mov	 DWORD PTR [ebx+12], 1

; 127  :         m_bIndexedSkinning = FALSE;

  00145	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx

; 128  :         cfvfDest = DXCrackFVF(SKINNEDFVF);

  00148	6a 1c		 push	 28			; 0000001cH
$L56757:
  0014a	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T56584[ebp]
  00150	e8 00 00 00 00	 call	 ??0DXCrackFVF@@QAE@K@Z	; DXCrackFVF::DXCrackFVF
  00155	6a 10		 push	 16			; 00000010H
  00157	59		 pop	 ecx
  00158	8b f0		 mov	 esi, eax
  0015a	8d 7d 80	 lea	 edi, DWORD PTR _cfvfDest$[ebp]
  0015d	f3 a5		 rep movsd

; 129  :     }
; 130  :     else if (cdSrc.CWeights() > 0)

  0015f	8b 75 08	 mov	 esi, DWORD PTR _ptmMesh$[ebp]
  00162	eb 17		 jmp	 SHORT $L56307
$L56621:
  00164	3b c1		 cmp	 eax, ecx
  00166	7e 10		 jle	 SHORT $L56305

; 131  :     {
; 132  :         m_bSkinning = TRUE;

  00168	33 c0		 xor	 eax, eax
  0016a	40		 inc	 eax
  0016b	89 43 0c	 mov	 DWORD PTR [ebx+12], eax

; 133  :         m_bIndexedSkinning = TRUE;

  0016e	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 134  :         cfvfDest = DXCrackFVF(INDEXSKINNEDFVF);

  00171	68 1e 80 00 00	 push	 32798			; 0000801eH

; 135  :     }
; 136  :     else

  00176	eb d2		 jmp	 SHORT $L56757
$L56305:

; 137  :     {
; 138  :         m_bSkinning = FALSE;

  00178	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
$L56307:

; 139  :     }
; 140  : 
; 141  :     hr = ptmMesh->GetAttributeTable(m_rgaeAttributeTable, NULL);

  0017b	8b 06		 mov	 eax, DWORD PTR [esi]
  0017d	6a 00		 push	 0
  0017f	ff 75 f4	 push	 DWORD PTR tv160[ebp]
  00182	56		 push	 esi
  00183	ff 50 4c	 call	 DWORD PTR [eax+76]

; 142  :     if (FAILED(hr))

  00186	85 c0		 test	 eax, eax
  00188	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
  0018b	0f 8c 7c 03 00
	00		 jl	 $e_Exit$56283

; 143  :         goto e_Exit;
; 144  : 
; 145  :     cVertices = 0;

  00191	83 65 f4 00	 and	 DWORD PTR _cVertices$[ebp], 0

; 146  :     for (iAttrib = 0; iAttrib < m_caeAttributeTable; iAttrib++)

  00195	83 7b 20 00	 cmp	 DWORD PTR [ebx+32], 0
  00199	76 1e		 jbe	 SHORT $L56313
  0019b	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  0019e	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
  001a1	83 c0 0c	 add	 eax, 12			; 0000000cH
$L56311:

; 147  :     {
; 148  :         cVertices = max(cVertices, m_rgaeAttributeTable[iAttrib].VertexStart + m_rgaeAttributeTable[iAttrib].VertexCount);

  001a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001a7	8b 38		 mov	 edi, DWORD PTR [eax]
  001a9	03 cf		 add	 ecx, edi
  001ab	39 4d f4	 cmp	 DWORD PTR _cVertices$[ebp], ecx
  001ae	77 03		 ja	 SHORT $L56587
  001b0	89 4d f4	 mov	 DWORD PTR _cVertices$[ebp], ecx
$L56587:

; 146  :     for (iAttrib = 0; iAttrib < m_caeAttributeTable; iAttrib++)

  001b3	83 c0 14	 add	 eax, 20			; 00000014H
  001b6	4a		 dec	 edx
  001b7	75 eb		 jne	 SHORT $L56311
$L56313:

; 149  :     }
; 150  :     // get the maximum vertex index
; 151  : 
; 152  :     hr = m_pDevice->CreateVertexBuffer(cVertices * 2 * cfvfDest.m_cBytesPerVertex, 
; 153  :                     D3DUSAGE_WRITEONLY|(m_bHWVertexShaders ? 0:D3DUSAGE_SOFTWAREPROCESSING), 
; 154  :                     cfvfDest.m_dwFVF, D3DPOOL_MANAGED, &m_pVertexBuffer, NULL);

  001b9	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  001bc	8b 03		 mov	 eax, DWORD PTR [ebx]
  001be	f7 da		 neg	 edx
  001c0	6a 00		 push	 0
  001c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c4	1b d2		 sbb	 edx, edx
  001c6	83 e2 f0	 and	 edx, -16		; fffffff0H
  001c9	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
  001cc	57		 push	 edi
  001cd	6a 01		 push	 1
  001cf	ff 75 80	 push	 DWORD PTR _cfvfDest$[ebp]
  001d2	83 c2 10	 add	 edx, 16			; 00000010H
  001d5	83 ca 08	 or	 edx, 8
  001d8	52		 push	 edx
  001d9	8b 55 84	 mov	 edx, DWORD PTR _cfvfDest$[ebp+4]
  001dc	0f af 55 f4	 imul	 edx, DWORD PTR _cVertices$[ebp]
  001e0	d1 e2		 shl	 edx, 1
  001e2	52		 push	 edx
  001e3	50		 push	 eax
  001e4	ff 51 68	 call	 DWORD PTR [ecx+104]

; 155  : 
; 156  :     hr = ptmMesh->LockVertexBuffer(D3DLOCK_READONLY, (PVOID*)&pbSrc);

  001e7	8b 06		 mov	 eax, DWORD PTR [esi]
  001e9	8d 4d f8	 lea	 ecx, DWORD PTR _pbSrc$[ebp]
  001ec	51		 push	 ecx
  001ed	6a 10		 push	 16			; 00000010H
  001ef	56		 push	 esi
  001f0	ff 50 3c	 call	 DWORD PTR [eax+60]

; 157  :     if (FAILED(hr))

  001f3	85 c0		 test	 eax, eax
  001f5	7d 0f		 jge	 SHORT $L56316

; 158  :     {
; 159  :         hr = CreateEmptyOutline();

  001f7	8b cb		 mov	 ecx, ebx
  001f9	e8 00 00 00 00	 call	 ?CreateEmptyOutline@CShowNormals@@AAEJXZ ; CShowNormals::CreateEmptyOutline
  001fe	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 272  :         }

  00201	e9 07 03 00 00	 jmp	 $e_Exit$56283
$L56316:

; 160  :         goto e_Exit;   
; 161  :     }
; 162  : 
; 163  :     hr = m_pVertexBuffer->Lock(0, 0, (PVOID*)&pbDest, D3DLOCK_NOSYSLOCK);

  00206	8b 3f		 mov	 edi, DWORD PTR [edi]
  00208	8b 07		 mov	 eax, DWORD PTR [edi]
  0020a	68 00 08 00 00	 push	 2048			; 00000800H
  0020f	8d 4d fc	 lea	 ecx, DWORD PTR _pbDest$[ebp]
  00212	51		 push	 ecx
  00213	6a 00		 push	 0
  00215	6a 00		 push	 0
  00217	57		 push	 edi
  00218	ff 50 2c	 call	 DWORD PTR [eax+44]

; 164  :     if (FAILED(hr))

  0021b	85 c0		 test	 eax, eax
  0021d	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
  00220	0f 8c e7 02 00
	00		 jl	 $e_Exit$56283

; 165  :         goto e_Exit;   
; 166  : 
; 167  :     if (m_bSkinning)

  00226	83 7b 0c 00	 cmp	 DWORD PTR [ebx+12], 0

; 168  :     {
; 169  :         // first figure out the counts for the number of creases per attribute group
; 170  :         for (iVertex = 0; iVertex < cVertices; iVertex++)

  0022a	8b 45 f4	 mov	 eax, DWORD PTR _cVertices$[ebp]
  0022d	0f 84 08 02 00
	00		 je	 $L56322
  00233	85 c0		 test	 eax, eax
  00235	0f 86 d2 02 00
	00		 jbe	 $e_Exit$56283
  0023b	89 45 f4	 mov	 DWORD PTR tv204[ebp], eax
$L56323:

; 171  :         {
; 172  :             vPos = *cdSrc.PvGetPosition(pbSrc);

  0023e	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cdSrc$[ebp+136]
  00244	0f b7 70 02	 movzx	 esi, WORD PTR [eax+2]
  00248	03 75 f8	 add	 esi, DWORD PTR _pbSrc$[ebp]

; 173  : 
; 174  :             // if use the normal, easy
; 175  :             if (dwTexStage == UNUSED32)

  0024b	8b 55 0c	 mov	 edx, DWORD PTR _dwTexStage$[ebp]
  0024e	83 fa ff	 cmp	 edx, -1
  00251	8d 7d d4	 lea	 edi, DWORD PTR _vPos$[ebp]
  00254	a5		 movsd
  00255	a5		 movsd
  00256	a5		 movsd

; 176  :             {
; 177  :                 vNormal = *cdSrc.PvGetNormal(pbSrc);

  00257	8d 7d e4	 lea	 edi, DWORD PTR _vNormal$[ebp]
  0025a	75 12		 jne	 SHORT $L56326
  0025c	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cdSrc$[ebp+148]
  00262	0f b7 70 02	 movzx	 esi, WORD PTR [eax+2]
  00266	03 75 f8	 add	 esi, DWORD PTR _pbSrc$[ebp]
  00269	a5		 movsd
  0026a	a5		 movsd
  0026b	a5		 movsd

; 178  :             }
; 179  :             else  // else grab a texture coordinate as a vector

  0026c	eb 27		 jmp	 SHORT $L56327
$L56326:

; 180  :             {
; 181  :                 // set all parts of the vector to zero
; 182  :                 memset(&vNormal, 0, sizeof(D3DXVECTOR3));
; 183  : 
; 184  :                 // copy the parts found in the mesh
; 185  :                 memcpy(&vNormal, pbSrc + cdSrc.rgpTextureElements[dwTexStage]->Offset, cbSizeOfVector);

  0026e	8b 4d d0	 mov	 ecx, DWORD PTR _cbSizeOfVector$[ebp]
  00271	33 c0		 xor	 eax, eax
  00273	ab		 stosd
  00274	ab		 stosd
  00275	ab		 stosd
  00276	8b 84 95 5c ff
	ff ff		 mov	 eax, DWORD PTR _cdSrc$[ebp+edx*4+160]
  0027d	0f b7 70 02	 movzx	 esi, WORD PTR [eax+2]
  00281	03 75 f8	 add	 esi, DWORD PTR _pbSrc$[ebp]
  00284	8b c1		 mov	 eax, ecx
  00286	c1 e9 02	 shr	 ecx, 2
  00289	8d 7d e4	 lea	 edi, DWORD PTR _vNormal$[ebp]
  0028c	f3 a5		 rep movsd
  0028e	8b c8		 mov	 ecx, eax
  00290	83 e1 03	 and	 ecx, 3
  00293	f3 a4		 rep movsb
$L56327:

; 186  : 
; 187  :             }
; 188  :             D3DXVec3Normalize(&vNormal, &vNormal);

  00295	8d 45 e4	 lea	 eax, DWORD PTR _vNormal$[ebp]
  00298	50		 push	 eax
  00299	50		 push	 eax
  0029a	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 189  : 
; 190  : 
; 191  :             // first copy the weights that exist in the source
; 192  :             fSum = 0.0f;

  0029f	d9 ee		 fldz

; 193  :             cWeights = cdSrc.BIndexedWeights() ? cdSrc.CWeights() - 1: cdSrc.CWeights();

  002a1	8b b5 48 ff ff
	ff		 mov	 esi, DWORD PTR _cdSrc$[ebp+140]
  002a7	33 c9		 xor	 ecx, ecx
  002a9	39 8d 4c ff ff
	ff		 cmp	 DWORD PTR _cdSrc$[ebp+144], ecx
  002af	74 12		 je	 SHORT $L56588
  002b1	3b f1		 cmp	 esi, ecx
  002b3	75 04		 jne	 SHORT $L56637
  002b5	33 c0		 xor	 eax, eax
  002b7	eb 05		 jmp	 SHORT $L56638
$L56637:
  002b9	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  002bd	40		 inc	 eax
$L56638:
  002be	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  002c1	eb 0d		 jmp	 SHORT $L56758
$L56588:
  002c3	3b f1		 cmp	 esi, ecx
  002c5	75 04		 jne	 SHORT $L56644
  002c7	33 d2		 xor	 edx, edx
  002c9	eb 05		 jmp	 SHORT $L56758
$L56644:
  002cb	0f b6 56 04	 movzx	 edx, BYTE PTR [esi+4]
  002cf	42		 inc	 edx
$L56758:

; 194  :             for (iWeight = 0; iWeight < cWeights; iWeight++)

  002d0	3b d1		 cmp	 edx, ecx
  002d2	89 55 10	 mov	 DWORD PTR _cWeights$[ebp], edx
  002d5	76 4e		 jbe	 SHORT $L56746
  002d7	6a 0c		 push	 12			; 0000000cH
  002d9	58		 pop	 eax
  002da	eb 06		 jmp	 SHORT $L56329
$L56754:
  002dc	8b b5 48 ff ff
	ff		 mov	 esi, DWORD PTR _cdSrc$[ebp+140]
$L56329:

; 195  :             {
; 196  :                 fWeight = cdSrc.FGetWeight(pbSrc, iWeight);

  002e2	0f b7 76 02	 movzx	 esi, WORD PTR [esi+2]
  002e6	8b 7d f8	 mov	 edi, DWORD PTR _pbSrc$[ebp]
  002e9	03 f0		 add	 esi, eax

; 197  :                 fSum += fWeight;
; 198  : 
; 199  :                 cfvfDest.SetWeight(pbDest, iWeight, fWeight);

  002eb	3b 4d b8	 cmp	 ecx, DWORD PTR _cfvfDest$[ebp+56]
  002ee	d9 44 3e f4	 fld	 DWORD PTR [esi+edi-12]
  002f2	d9 c0		 fld	 ST(0)
  002f4	de c2		 faddp	 ST(2), ST(0)
  002f6	d9 55 e0	 fst	 DWORD PTR $T56654[ebp]
  002f9	73 09		 jae	 SHORT $L56752
  002fb	8b 75 fc	 mov	 esi, DWORD PTR _pbDest$[ebp]
  002fe	8b 7d e0	 mov	 edi, DWORD PTR $T56654[ebp]
  00301	89 3c 30	 mov	 DWORD PTR [eax+esi], edi
$L56752:

; 200  :                 cfvfDest.SetWeight(pbDest + cfvfDest.m_cBytesPerVertex, iWeight, fWeight);

  00304	3b 4d b8	 cmp	 ecx, DWORD PTR _cfvfDest$[ebp+56]
  00307	d9 5d e0	 fstp	 DWORD PTR $T56660[ebp]
  0030a	73 11		 jae	 SHORT $L56330

; 282  : 
; 283  :     return hr;

  0030c	8b 55 84	 mov	 edx, DWORD PTR _cfvfDest$[ebp+4]
  0030f	8b 75 fc	 mov	 esi, DWORD PTR _pbDest$[ebp]
  00312	8b 7d e0	 mov	 edi, DWORD PTR $T56660[ebp]
  00315	03 d0		 add	 edx, eax
  00317	89 3c 32	 mov	 DWORD PTR [edx+esi], edi
  0031a	8b 55 10	 mov	 edx, DWORD PTR _cWeights$[ebp]
$L56330:
  0031d	41		 inc	 ecx
  0031e	83 c0 04	 add	 eax, 4
  00321	3b ca		 cmp	 ecx, edx
  00323	72 b7		 jb	 SHORT $L56754
$L56746:

; 201  :             }
; 202  : 
; 203  :             // now set the implied weight - always exists in dest
; 204  :             cfvfDest.SetWeight(pbDest, iWeight, 1.0f - fSum);

  00325	8b 55 b8	 mov	 edx, DWORD PTR _cfvfDest$[ebp+56]
  00328	d9 e8		 fld1
  0032a	3b ca		 cmp	 ecx, edx
  0032c	de e1		 fsubrp	 ST(1), ST(0)
  0032e	d9 55 10	 fst	 DWORD PTR $T56666[ebp]
  00331	73 0a		 jae	 SHORT $L56665
  00333	8b 45 fc	 mov	 eax, DWORD PTR _pbDest$[ebp]
  00336	8b 75 10	 mov	 esi, DWORD PTR $T56666[ebp]
  00339	89 74 88 0c	 mov	 DWORD PTR [eax+ecx*4+12], esi
$L56665:

; 205  :             cfvfDest.SetWeight(pbDest + cfvfDest.m_cBytesPerVertex, iWeight, 1.0f - fSum);

  0033d	3b ca		 cmp	 ecx, edx
  0033f	d9 5d 10	 fstp	 DWORD PTR $T56672[ebp]
  00342	73 10		 jae	 SHORT $L56748

; 282  : 
; 283  :     return hr;

  00344	8b 45 84	 mov	 eax, DWORD PTR _cfvfDest$[ebp+4]
  00347	8b 75 fc	 mov	 esi, DWORD PTR _pbDest$[ebp]
  0034a	8b 7d 10	 mov	 edi, DWORD PTR $T56672[ebp]
  0034d	8d 44 88 0c	 lea	 eax, DWORD PTR [eax+ecx*4+12]
  00351	89 3c 30	 mov	 DWORD PTR [eax+esi], edi
$L56748:
  00354	41		 inc	 ecx
  00355	83 bd 4c ff ff
	ff 00		 cmp	 DWORD PTR _cdSrc$[ebp+144], 0
  0035c	74 08		 je	 SHORT $L56590
  0035e	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00361	89 45 10	 mov	 DWORD PTR tv363[ebp], eax
  00364	eb 03		 jmp	 SHORT $L56682
$L56590:

; 206  :             iWeight += 1;
; 207  : 
; 208  :             // set any other weights that are unused to 0.0f
; 209  :             cWeights = cdSrc.BIndexedWeights() ? cfvfDest.CWeights() - 1: cfvfDest.CWeights();

  00366	89 55 10	 mov	 DWORD PTR tv363[ebp], edx
$L56682:

; 210  :             for (; iWeight < cWeights; iWeight++)

  00369	3b 4d 10	 cmp	 ecx, DWORD PTR tv363[ebp]
  0036c	73 3a		 jae	 SHORT $L56334

; 211  :             {
; 212  :                 cfvfDest.SetWeight(pbDest, iWeight, 0.0f);

  0036e	d9 ee		 fldz
  00370	8d 04 8d 0c 00
	00 00		 lea	 eax, DWORD PTR [ecx*4+12]
  00377	d9 5d e0	 fstp	 DWORD PTR $T56689[ebp]

; 213  :                 cfvfDest.SetWeight(pbDest + cfvfDest.m_cBytesPerVertex, iWeight, 0.0f);

  0037a	d9 ee		 fldz
  0037c	d9 5d cc	 fstp	 DWORD PTR $T56695[ebp]
  0037f	eb 03		 jmp	 SHORT $L56332
$L56755:

; 206  :             iWeight += 1;
; 207  : 
; 208  :             // set any other weights that are unused to 0.0f
; 209  :             cWeights = cdSrc.BIndexedWeights() ? cfvfDest.CWeights() - 1: cfvfDest.CWeights();

  00381	8b 55 b8	 mov	 edx, DWORD PTR _cfvfDest$[ebp+56]
$L56332:

; 211  :             {
; 212  :                 cfvfDest.SetWeight(pbDest, iWeight, 0.0f);

  00384	3b ca		 cmp	 ecx, edx
  00386	73 17		 jae	 SHORT $L56333
  00388	8b 55 fc	 mov	 edx, DWORD PTR _pbDest$[ebp]
  0038b	8b 75 e0	 mov	 esi, DWORD PTR $T56689[ebp]

; 213  :                 cfvfDest.SetWeight(pbDest + cfvfDest.m_cBytesPerVertex, iWeight, 0.0f);

  0038e	8b 7d cc	 mov	 edi, DWORD PTR $T56695[ebp]
  00391	89 34 10	 mov	 DWORD PTR [eax+edx], esi

; 282  : 
; 283  :     return hr;

  00394	8b 55 84	 mov	 edx, DWORD PTR _cfvfDest$[ebp+4]
  00397	8b 75 fc	 mov	 esi, DWORD PTR _pbDest$[ebp]
  0039a	03 d0		 add	 edx, eax
  0039c	89 3c 32	 mov	 DWORD PTR [edx+esi], edi
$L56333:
  0039f	41		 inc	 ecx
  003a0	83 c0 04	 add	 eax, 4
  003a3	3b 4d 10	 cmp	 ecx, DWORD PTR tv363[ebp]
  003a6	72 d9		 jb	 SHORT $L56755
$L56334:

; 214  :             }
; 215  : 
; 216  :             // if indexed skinning, copy the indices
; 217  :             if (cdSrc.BIndexedWeights())

  003a8	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _cdSrc$[ebp+144]
  003ae	85 c0		 test	 eax, eax
  003b0	74 36		 je	 SHORT $L56335

; 218  :             {
; 219  :                 cfvfDest.SetIndices(pbDest, *cdSrc.PdwGetIndices(pbSrc));

  003b2	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  003b6	8b 4d f8	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  003b9	ff 34 08	 push	 DWORD PTR [eax+ecx]
  003bc	8d 4d 80	 lea	 ecx, DWORD PTR _cfvfDest$[ebp]
  003bf	ff 75 fc	 push	 DWORD PTR _pbDest$[ebp]
  003c2	e8 00 00 00 00	 call	 ?SetIndices@DXCrackFVF@@QAEXPAXK@Z ; DXCrackFVF::SetIndices

; 220  :                 cfvfDest.SetIndices(pbDest + cfvfDest.m_cBytesPerVertex, *cdSrc.PdwGetIndices(pbSrc));

  003c7	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _cdSrc$[ebp+144]
  003cd	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  003d1	8b 4d f8	 mov	 ecx, DWORD PTR _pbSrc$[ebp]
  003d4	ff 34 08	 push	 DWORD PTR [eax+ecx]
  003d7	8b 45 fc	 mov	 eax, DWORD PTR _pbDest$[ebp]
  003da	8b 4d 84	 mov	 ecx, DWORD PTR _cfvfDest$[ebp+4]
  003dd	03 c8		 add	 ecx, eax
  003df	51		 push	 ecx
  003e0	8d 4d 80	 lea	 ecx, DWORD PTR _cfvfDest$[ebp]
  003e3	e8 00 00 00 00	 call	 ?SetIndices@DXCrackFVF@@QAEXPAXK@Z ; DXCrackFVF::SetIndices
$L56335:

; 221  :             }
; 222  : 
; 223  :             // set one normal to zero and the other to the correct value
; 224  :             //   both points have the same position though.  the normal
; 225  :             //   is added post skinning 
; 226  : 
; 227  :             // normal to zero
; 228  :             cfvfDest.SetPosition(pbDest, &vPos);

  003e8	8b 7d fc	 mov	 edi, DWORD PTR _pbDest$[ebp]
  003eb	8d 75 d4	 lea	 esi, DWORD PTR _vPos$[ebp]
  003ee	a5		 movsd
  003ef	a5		 movsd

; 229  :             cfvfDest.SetNormal(pbDest, &vZero);

  003f0	8d 45 c0	 lea	 eax, DWORD PTR _vZero$[ebp]
  003f3	50		 push	 eax
  003f4	a5		 movsd
  003f5	ff 75 fc	 push	 DWORD PTR _pbDest$[ebp]
  003f8	8d 4d 80	 lea	 ecx, DWORD PTR _cfvfDest$[ebp]
  003fb	e8 00 00 00 00	 call	 ?SetNormal@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetNormal

; 230  :             pbDest += cfvfDest.m_cBytesPerVertex;

  00400	8b 45 84	 mov	 eax, DWORD PTR _cfvfDest$[ebp+4]
  00403	01 45 fc	 add	 DWORD PTR _pbDest$[ebp], eax

; 231  : 
; 232  :             // correct normal
; 233  :             cfvfDest.SetPosition(pbDest, &vPos);

  00406	8b 7d fc	 mov	 edi, DWORD PTR _pbDest$[ebp]
  00409	8d 75 d4	 lea	 esi, DWORD PTR _vPos$[ebp]
  0040c	a5		 movsd
  0040d	a5		 movsd

; 234  :             cfvfDest.SetNormal(pbDest, &vNormal);

  0040e	8d 45 e4	 lea	 eax, DWORD PTR _vNormal$[ebp]
  00411	50		 push	 eax
  00412	a5		 movsd
  00413	ff 75 fc	 push	 DWORD PTR _pbDest$[ebp]
  00416	8d 4d 80	 lea	 ecx, DWORD PTR _cfvfDest$[ebp]
  00419	e8 00 00 00 00	 call	 ?SetNormal@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetNormal

; 235  :             pbDest += cfvfDest.m_cBytesPerVertex;

  0041e	8b 45 84	 mov	 eax, DWORD PTR _cfvfDest$[ebp+4]
  00421	01 45 fc	 add	 DWORD PTR _pbDest$[ebp], eax

; 236  : 
; 237  :             pbSrc += cdSrc.m_cBytesPerVertex;

  00424	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _cdSrc$[ebp+192]
  0042a	01 45 f8	 add	 DWORD PTR _pbSrc$[ebp], eax
  0042d	ff 4d f4	 dec	 DWORD PTR tv204[ebp]
  00430	0f 85 08 fe ff
	ff		 jne	 $L56323

; 238  :         }
; 239  :     }
; 240  :     else

  00436	e9 cf 00 00 00	 jmp	 $L56759
$L56322:

; 241  :     {
; 242  :         // first figure out the counts for the number of creases per attribute group
; 243  :         for (iVertex = 0; iVertex < cVertices; iVertex++)

  0043b	85 c0		 test	 eax, eax
  0043d	0f 86 ca 00 00
	00		 jbe	 $e_Exit$56283
  00443	89 45 f4	 mov	 DWORD PTR tv172[ebp], eax
$L56337:

; 244  :         {
; 245  :             vPos = *cdSrc.PvGetPosition(pbSrc);

  00446	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _cdSrc$[ebp+136]
  0044c	0f b7 70 02	 movzx	 esi, WORD PTR [eax+2]
  00450	03 75 f8	 add	 esi, DWORD PTR _pbSrc$[ebp]

; 246  :             // show binormals
; 247  : 
; 248  :             // if use the normal, easy
; 249  :             if (dwTexStage == UNUSED32)

  00453	8b 55 0c	 mov	 edx, DWORD PTR _dwTexStage$[ebp]
  00456	83 fa ff	 cmp	 edx, -1
  00459	8d 7d d4	 lea	 edi, DWORD PTR _vPos$[ebp]
  0045c	a5		 movsd
  0045d	a5		 movsd
  0045e	a5		 movsd

; 250  :             {
; 251  :                 vNormal = *cdSrc.PvGetNormal(pbSrc);

  0045f	8d 7d e4	 lea	 edi, DWORD PTR _vNormal$[ebp]
  00462	75 12		 jne	 SHORT $L56340
  00464	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _cdSrc$[ebp+148]
  0046a	0f b7 70 02	 movzx	 esi, WORD PTR [eax+2]
  0046e	03 75 f8	 add	 esi, DWORD PTR _pbSrc$[ebp]
  00471	a5		 movsd
  00472	a5		 movsd
  00473	a5		 movsd

; 252  :             }
; 253  :             else  // else grab a texture coordinate as a vector

  00474	eb 27		 jmp	 SHORT $L56341
$L56340:

; 254  :             {
; 255  :                 // set all parts of the vector to zero
; 256  :                 memset(&vNormal, 0, sizeof(D3DXVECTOR3));
; 257  : 
; 258  :                 // copy the parts found in the mesh
; 259  :                 memcpy(&vNormal, pbSrc + cdSrc.rgpTextureElements[dwTexStage]->Offset, cbSizeOfVector);

  00476	8b 4d d0	 mov	 ecx, DWORD PTR _cbSizeOfVector$[ebp]
  00479	33 c0		 xor	 eax, eax
  0047b	ab		 stosd
  0047c	ab		 stosd
  0047d	ab		 stosd
  0047e	8b 84 95 5c ff
	ff ff		 mov	 eax, DWORD PTR _cdSrc$[ebp+edx*4+160]
  00485	0f b7 70 02	 movzx	 esi, WORD PTR [eax+2]
  00489	03 75 f8	 add	 esi, DWORD PTR _pbSrc$[ebp]
  0048c	8b c1		 mov	 eax, ecx
  0048e	c1 e9 02	 shr	 ecx, 2
  00491	8d 7d e4	 lea	 edi, DWORD PTR _vNormal$[ebp]
  00494	f3 a5		 rep movsd
  00496	8b c8		 mov	 ecx, eax
  00498	83 e1 03	 and	 ecx, 3
  0049b	f3 a4		 rep movsb
$L56341:

; 260  : 
; 261  :             }
; 262  :             D3DXVec3Normalize(&vNormal, &vNormal);

  0049d	8d 45 e4	 lea	 eax, DWORD PTR _vNormal$[ebp]
  004a0	50		 push	 eax
  004a1	50		 push	 eax
  004a2	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 263  :             vNormal *= fLength;

  004a7	d9 45 e4	 fld	 DWORD PTR _vNormal$[ebp]
  004aa	d8 4d 10	 fmul	 DWORD PTR _fLength$[ebp]

; 264  :             pbSrc += cdSrc.m_cBytesPerVertex;

  004ad	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _cdSrc$[ebp+192]

; 265  : 
; 266  :             cfvfDest.SetPosition(pbDest, &vPos);

  004b3	8b 7d fc	 mov	 edi, DWORD PTR _pbDest$[ebp]
  004b6	01 45 f8	 add	 DWORD PTR _pbSrc$[ebp], eax
  004b9	d9 5d e4	 fstp	 DWORD PTR _vNormal$[ebp]

; 267  :             pbDest += cfvfDest.m_cBytesPerVertex;

  004bc	8b 45 84	 mov	 eax, DWORD PTR _cfvfDest$[ebp+4]
  004bf	d9 45 e8	 fld	 DWORD PTR _vNormal$[ebp+4]
  004c2	8d 75 d4	 lea	 esi, DWORD PTR _vPos$[ebp]
  004c5	d8 4d 10	 fmul	 DWORD PTR _fLength$[ebp]
  004c8	d9 5d e8	 fstp	 DWORD PTR _vNormal$[ebp+4]
  004cb	d9 45 ec	 fld	 DWORD PTR _vNormal$[ebp+8]
  004ce	d8 4d 10	 fmul	 DWORD PTR _fLength$[ebp]
  004d1	d9 5d ec	 fstp	 DWORD PTR _vNormal$[ebp+8]
  004d4	a5		 movsd

; 268  : 
; 269  :             vPos += vNormal;

  004d5	d9 45 d4	 fld	 DWORD PTR _vPos$[ebp]
  004d8	a5		 movsd
  004d9	a5		 movsd
  004da	d8 45 e4	 fadd	 DWORD PTR _vNormal$[ebp]
  004dd	01 45 fc	 add	 DWORD PTR _pbDest$[ebp], eax

; 270  :             cfvfDest.SetPosition(pbDest, &vPos);

  004e0	8b 7d fc	 mov	 edi, DWORD PTR _pbDest$[ebp]
  004e3	d9 5d d4	 fstp	 DWORD PTR _vPos$[ebp]
  004e6	d9 45 d8	 fld	 DWORD PTR _vPos$[ebp+4]
  004e9	8d 75 d4	 lea	 esi, DWORD PTR _vPos$[ebp]
  004ec	d8 45 e8	 fadd	 DWORD PTR _vNormal$[ebp+4]
  004ef	d9 5d d8	 fstp	 DWORD PTR _vPos$[ebp+4]
  004f2	d9 45 dc	 fld	 DWORD PTR _vPos$[ebp+8]
  004f5	d8 45 ec	 fadd	 DWORD PTR _vNormal$[ebp+8]
  004f8	d9 5d dc	 fstp	 DWORD PTR _vPos$[ebp+8]
  004fb	a5		 movsd
  004fc	a5		 movsd
  004fd	a5		 movsd

; 271  :             pbDest += cfvfDest.m_cBytesPerVertex;

  004fe	01 45 fc	 add	 DWORD PTR _pbDest$[ebp], eax
  00501	ff 4d f4	 dec	 DWORD PTR tv172[ebp]
  00504	0f 85 3c ff ff
	ff		 jne	 $L56337
$L56759:

; 241  :     {
; 242  :         // first figure out the counts for the number of creases per attribute group
; 243  :         for (iVertex = 0; iVertex < cVertices; iVertex++)

  0050a	8b 75 08	 mov	 esi, DWORD PTR _ptmMesh$[ebp]
$e_Exit$56283:

; 273  :     }
; 274  : 
; 275  : e_Exit:
; 276  : 
; 277  :     if (pbSrc != NULL)

  0050d	83 7d f8 00	 cmp	 DWORD PTR _pbSrc$[ebp], 0
  00511	74 06		 je	 SHORT $L56343

; 278  :         ptmMesh->UnlockVertexBuffer();

  00513	8b 06		 mov	 eax, DWORD PTR [esi]
  00515	56		 push	 esi
  00516	ff 50 40	 call	 DWORD PTR [eax+64]
$L56343:

; 279  : 
; 280  :     if (pbDest != NULL)

  00519	83 7d fc 00	 cmp	 DWORD PTR _pbDest$[ebp], 0
  0051d	74 09		 je	 SHORT $L56344

; 281  :         m_pVertexBuffer->Unlock();

  0051f	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00522	8b 03		 mov	 eax, DWORD PTR [ebx]
  00524	53		 push	 ebx
  00525	ff 50 30	 call	 DWORD PTR [eax+48]
$L56344:

; 282  : 
; 283  :     return hr;

  00528	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]
  0052b	5f		 pop	 edi
  0052c	5e		 pop	 esi
  0052d	5b		 pop	 ebx

; 284  : }

  0052e	c9		 leave
  0052f	c2 0c 00	 ret	 12			; 0000000cH
?Init@CShowNormals@@QAEJPAUID3DXBaseMesh@@KM@Z ENDP	; CShowNormals::Init
_TEXT	ENDS
PUBLIC	??_C@_04BEMIBDAE@mTot?$AA@			; `string'
PUBLIC	??_C@_07HHMNENJH@mWorlds?$AA@			; `string'
PUBLIC	??_C@_04BFCOOMBD@vScl?$AA@			; `string'
PUBLIC	??_C@_04JKCKMDGO@vClr?$AA@			; `string'
PUBLIC	?Draw@CShowNormals@@QAEJKKPAUID3DXEffect@@0KPAUD3DXMATRIX@@K@Z ; CShowNormals::Draw
EXTRN	_D3DXMatrixMultiply@12:NEAR
;	COMDAT ??_C@_04BEMIBDAE@mTot?$AA@
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.inl
CONST	SEGMENT
??_C@_04BEMIBDAE@mTot?$AA@ DB 'mTot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HHMNENJH@mWorlds?$AA@
CONST	SEGMENT
??_C@_07HHMNENJH@mWorlds?$AA@ DB 'mWorlds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BFCOOMBD@vScl?$AA@
CONST	SEGMENT
??_C@_04BFCOOMBD@vScl?$AA@ DB 'vScl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JKCKMDGO@vClr?$AA@
CONST	SEGMENT
??_C@_04JKCKMDGO@vClr?$AA@ DB 'vClr', 00H		; `string'
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\shownormal.cpp
CONST	ENDS
;	COMDAT ?Draw@CShowNormals@@QAEJKKPAUID3DXEffect@@0KPAUD3DXMATRIX@@K@Z
_TEXT	SEGMENT
_matTot$ = -304						; size = 64
_matView$ = -240					; size = 64
_matProj$ = -176					; size = 64
_matWorld$ = -112					; size = 64
_vScale$ = -48						; size = 16
_vClr$ = -32						; size = 16
_dwSoftwareMode$ = -16					; size = 4
_cPasses$ = -12						; size = 4
_cBytesPerVertex$ = -8					; size = 4
_bChangedSWMode$ = -4					; size = 4
_cLines$ = 8						; size = 4
_iAttrib$ = 8						; size = 4
_iVertex$ = 12						; size = 4
_pfxCurrent$ = 16					; size = 4
_pfxShowNormals$ = 16					; size = 4
_dwFVF$ = 20						; size = 4
_pfxColor$ = 20						; size = 4
tv648 = 24						; size = 4
tv647 = 24						; size = 4
tv646 = 24						; size = 4
tv645 = 24						; size = 4
_iPass$ = 24						; size = 4
_dwColor$ = 24						; size = 4
_cLinesCur$ = 28					; size = 4
_rgmIndexedMatrices$ = 28				; size = 4
_cIndexedMatrices$ = 32					; size = 4
?Draw@CShowNormals@@QAEJKKPAUID3DXEffect@@0KPAUD3DXMATRIX@@K@Z PROC NEAR ; CShowNormals::Draw, COMDAT
; _this$ = ecx

; 471  : }

  00000	8b ff		 npad	 2

; 305  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  0000b	53		 push	 ebx

; 306  :     HRESULT hr;
; 307  :     LPD3DXEFFECT pfxCurrent;
; 308  :     DWORD dwFVF;
; 309  :     UINT iPass;
; 310  :     UINT cPasses;
; 311  :     DWORD cBytesPerVertex;
; 312  :     D3DXMATRIX matWorld;
; 313  :     D3DXMATRIX matView;
; 314  :     D3DXMATRIX matProj;
; 315  :     D3DXMATRIX matTot;
; 316  :     D3DXVECTOR4 vScale(m_fScale, 0.0f, 0.0f,0.0f);

  0000c	d9 ee		 fldz
  0000e	d9 5d d4	 fstp	 DWORD PTR _vScale$[ebp+4]
  00011	56		 push	 esi
  00012	8b f1		 mov	 esi, ecx
  00014	d9 ee		 fldz
  00016	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00019	d9 5d d8	 fstp	 DWORD PTR _vScale$[ebp+8]
  0001c	89 45 d0	 mov	 DWORD PTR _vScale$[ebp], eax
  0001f	d9 ee		 fldz

; 317  :     D3DXCOLOR vClr(dwColor);

  00021	8b 45 18	 mov	 eax, DWORD PTR _dwColor$[ebp]
  00024	d9 5d dc	 fstp	 DWORD PTR _vScale$[ebp+12]
  00027	8b c8		 mov	 ecx, eax
  00029	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3b808081
  0002f	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00032	0f b6 c9	 movzx	 ecx, cl
  00035	89 4d 18	 mov	 DWORD PTR tv648[ebp], ecx
  00038	8b c8		 mov	 ecx, eax
  0003a	c1 e9 08	 shr	 ecx, 8
  0003d	db 45 18	 fild	 DWORD PTR tv648[ebp]
  00040	0f b6 c9	 movzx	 ecx, cl
  00043	d8 c9		 fmul	 ST(0), ST(1)
  00045	89 4d 18	 mov	 DWORD PTR tv647[ebp], ecx
  00048	0f b6 c8	 movzx	 ecx, al
  0004b	d9 5d e0	 fstp	 DWORD PTR _vClr$[ebp]
  0004e	db 45 18	 fild	 DWORD PTR tv647[ebp]
  00051	89 4d 18	 mov	 DWORD PTR tv646[ebp], ecx
  00054	c1 e8 18	 shr	 eax, 24			; 00000018H
  00057	57		 push	 edi
  00058	d8 c9		 fmul	 ST(0), ST(1)
  0005a	d9 5d e4	 fstp	 DWORD PTR _vClr$[ebp+4]
  0005d	db 45 18	 fild	 DWORD PTR tv646[ebp]
  00060	89 45 18	 mov	 DWORD PTR tv645[ebp], eax

; 318  : 	BOOL dwSoftwareMode;
; 319  :     DWORD cLines;
; 320  :     DWORD cLinesCur;
; 321  :     DWORD iVertexStart;
; 322  :     DWORD iMatrix;
; 323  :     BOOL bChangedSWMode = FALSE;

  00063	33 c0		 xor	 eax, eax

; 324  :     DWORD iSubset;
; 325  : 
; 326  :     if (m_bSkinning)

  00065	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  00068	d8 c9		 fmul	 ST(0), ST(1)
  0006a	89 45 fc	 mov	 DWORD PTR _bChangedSWMode$[ebp], eax
  0006d	d9 5d e8	 fstp	 DWORD PTR _vClr$[ebp+8]
  00070	db 45 18	 fild	 DWORD PTR tv645[ebp]
  00073	d8 c9		 fmul	 ST(0), ST(1)
  00075	d9 5d ec	 fstp	 DWORD PTR _vClr$[ebp+12]
  00078	dd d8		 fstp	 ST(0)
  0007a	0f 84 1d 02 00
	00		 je	 $L56403

; 327  :     {
; 328  :         if (!m_bIndexedSkinning)

  00080	39 46 10	 cmp	 DWORD PTR [esi+16], eax

; 329  :         {
; 330  :             pfxCurrent = pfxShowNormals;

  00083	8b 7d 10	 mov	 edi, DWORD PTR _pfxShowNormals$[ebp]

; 331  :             dwFVF = SKINNEDFVF;
; 332  :             cBytesPerVertex = SKINNEDFVFSTRIDE;
; 333  :             pfxShowNormals->SetTechnique(pfxShowNormals->GetTechnique(0));

  00086	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00088	89 7d 10	 mov	 DWORD PTR _pfxCurrent$[ebp], edi
  0008b	0f 85 20 01 00
	00		 jne	 $L56404
  00091	50		 push	 eax
  00092	57		 push	 edi
  00093	c7 45 14 1c 00
	00 00		 mov	 DWORD PTR _dwFVF$[ebp], 28 ; 0000001cH
  0009a	c7 45 f8 28 00
	00 00		 mov	 DWORD PTR _cBytesPerVertex$[ebp], 40 ; 00000028H
  000a1	ff 53 30	 call	 DWORD PTR [ebx+48]
  000a4	50		 push	 eax
  000a5	57		 push	 edi
  000a6	ff 93 f0 00 00
	00		 call	 DWORD PTR [ebx+240]

; 334  : 
; 335  :             m_pDevice->GetTransform(D3DTS_VIEW,&matView);

  000ac	8b 06		 mov	 eax, DWORD PTR [esi]
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	8d 95 10 ff ff
	ff		 lea	 edx, DWORD PTR _matView$[ebp]
  000b6	52		 push	 edx
  000b7	6a 02		 push	 2
  000b9	50		 push	 eax
  000ba	ff 91 b4 00 00
	00		 call	 DWORD PTR [ecx+180]

; 336  :             m_pDevice->GetTransform(D3DTS_PROJECTION,&matProj);

  000c0	8b 06		 mov	 eax, DWORD PTR [esi]
  000c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c4	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR _matProj$[ebp]
  000ca	52		 push	 edx
  000cb	6a 03		 push	 3
  000cd	50		 push	 eax
  000ce	ff 91 b4 00 00
	00		 call	 DWORD PTR [ecx+180]

; 337  :             m_pDevice->GetTransform(D3DTS_WORLD,&matWorld);

  000d4	8b 06		 mov	 eax, DWORD PTR [esi]
  000d6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d8	8d 55 90	 lea	 edx, DWORD PTR _matWorld$[ebp]
  000db	52		 push	 edx
  000dc	bb 00 01 00 00	 mov	 ebx, 256		; 00000100H
  000e1	53		 push	 ebx
  000e2	50		 push	 eax
  000e3	ff 91 b4 00 00
	00		 call	 DWORD PTR [ecx+180]

; 338  : 
; 339  :             //D3DXMatrixMultiply(&matTot, &matWorld,&matView);
; 340  :             D3DXMatrixMultiply(&matTot,&matView,&matProj);

  000e9	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _matProj$[ebp]
  000ef	50		 push	 eax
  000f0	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _matView$[ebp]
  000f6	50		 push	 eax
  000f7	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _matTot$[ebp]
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 341  :             pfxShowNormals->SetMatrix("mTot", &matTot);                       

  00103	8b 07		 mov	 eax, DWORD PTR [edi]
  00105	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _matTot$[ebp]
  0010b	51		 push	 ecx
  0010c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04BEMIBDAE@mTot?$AA@
  00111	57		 push	 edi
  00112	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 342  : 
; 343  :             m_pDevice->GetTransform(D3DTS_WORLD,&matWorld);

  00118	8b 06		 mov	 eax, DWORD PTR [esi]
  0011a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011c	8d 55 90	 lea	 edx, DWORD PTR _matWorld$[ebp]
  0011f	52		 push	 edx
  00120	53		 push	 ebx
  00121	50		 push	 eax
  00122	ff 91 b4 00 00
	00		 call	 DWORD PTR [ecx+180]

; 344  :             pfxShowNormals->SetMatrix("mWd1", &matWorld);                       

  00128	8b 07		 mov	 eax, DWORD PTR [edi]
  0012a	8d 4d 90	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  0012d	51		 push	 ecx
  0012e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04IHCGOIEL@mWd1?$AA@
  00133	57		 push	 edi
  00134	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 345  : 
; 346  :             m_pDevice->GetTransform(D3DTS_WORLD1,&matWorld);

  0013a	8b 06		 mov	 eax, DWORD PTR [esi]
  0013c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013e	8d 55 90	 lea	 edx, DWORD PTR _matWorld$[ebp]
  00141	52		 push	 edx
  00142	68 01 01 00 00	 push	 257			; 00000101H
  00147	50		 push	 eax
  00148	ff 91 b4 00 00
	00		 call	 DWORD PTR [ecx+180]

; 347  :             pfxShowNormals->SetMatrix("mWd2", &matWorld);                       

  0014e	8b 07		 mov	 eax, DWORD PTR [edi]
  00150	8d 4d 90	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  00153	51		 push	 ecx
  00154	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04KMALLLII@mWd2?$AA@
  00159	57		 push	 edi
  0015a	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 348  : 
; 349  :             m_pDevice->GetTransform(D3DTS_WORLD2,&matWorld);

  00160	8b 06		 mov	 eax, DWORD PTR [esi]
  00162	8b 08		 mov	 ecx, DWORD PTR [eax]
  00164	8d 55 90	 lea	 edx, DWORD PTR _matWorld$[ebp]
  00167	52		 push	 edx
  00168	68 02 01 00 00	 push	 258			; 00000102H
  0016d	50		 push	 eax
  0016e	ff 91 b4 00 00
	00		 call	 DWORD PTR [ecx+180]

; 350  :             pfxShowNormals->SetMatrix("mWd3", &matWorld);                       

  00174	8b 07		 mov	 eax, DWORD PTR [edi]
  00176	8d 4d 90	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  00179	51		 push	 ecx
  0017a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04LFBAIKMJ@mWd3?$AA@
  0017f	57		 push	 edi
  00180	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 351  : 
; 352  :             m_pDevice->GetTransform(D3DTS_WORLD3,&matWorld);

  00186	8b 06		 mov	 eax, DWORD PTR [esi]
  00188	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018a	8d 55 90	 lea	 edx, DWORD PTR _matWorld$[ebp]
  0018d	52		 push	 edx
  0018e	68 03 01 00 00	 push	 259			; 00000103H
  00193	50		 push	 eax
  00194	ff 91 b4 00 00
	00		 call	 DWORD PTR [ecx+180]

; 353  :             pfxShowNormals->SetMatrix("mWd4", &matWorld);                       

  0019a	8b 07		 mov	 eax, DWORD PTR [edi]
  0019c	8d 4d 90	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  0019f	51		 push	 ecx
  001a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PKFBBMAO@mWd4?$AA@
  001a5	57		 push	 edi
  001a6	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 354  : 
; 355  :         }
; 356  :         else

  001ac	e9 86 00 00 00	 jmp	 $L56411
$L56404:

; 357  :         {
; 358  :             dwFVF = INDEXSKINNEDFVF;
; 359  :             pfxCurrent = pfxShowNormals;
; 360  :             cBytesPerVertex = INDEXSKINNEDFVFSTRIDE;
; 361  :             pfxShowNormals->SetTechnique(pfxShowNormals->GetTechnique(1));

  001b1	6a 01		 push	 1
  001b3	57		 push	 edi
  001b4	c7 45 14 1e 80
	00 00		 mov	 DWORD PTR _dwFVF$[ebp], 32798 ; 0000801eH
  001bb	c7 45 f8 2c 00
	00 00		 mov	 DWORD PTR _cBytesPerVertex$[ebp], 44 ; 0000002cH
  001c2	ff 53 30	 call	 DWORD PTR [ebx+48]
  001c5	50		 push	 eax
  001c6	57		 push	 edi
  001c7	ff 93 f0 00 00
	00		 call	 DWORD PTR [ebx+240]

; 362  : 
; 363  :             m_pDevice->GetTransform(D3DTS_VIEW,&matView);

  001cd	8b 06		 mov	 eax, DWORD PTR [esi]
  001cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d1	8d 95 10 ff ff
	ff		 lea	 edx, DWORD PTR _matView$[ebp]
  001d7	52		 push	 edx
  001d8	6a 02		 push	 2
  001da	50		 push	 eax
  001db	ff 91 b4 00 00
	00		 call	 DWORD PTR [ecx+180]

; 364  :             m_pDevice->GetTransform(D3DTS_PROJECTION,&matProj);

  001e1	8b 06		 mov	 eax, DWORD PTR [esi]
  001e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e5	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR _matProj$[ebp]
  001eb	52		 push	 edx
  001ec	6a 03		 push	 3
  001ee	50		 push	 eax
  001ef	ff 91 b4 00 00
	00		 call	 DWORD PTR [ecx+180]

; 365  : 
; 366  :             D3DXMatrixMultiply(&matTot,&matView,&matProj);

  001f5	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _matProj$[ebp]
  001fb	50		 push	 eax
  001fc	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _matView$[ebp]
  00202	50		 push	 eax
  00203	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _matTot$[ebp]
  00209	50		 push	 eax
  0020a	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 367  :             pfxShowNormals->SetMatrix("mTot", &matTot);                       

  0020f	8b 07		 mov	 eax, DWORD PTR [edi]
  00211	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _matTot$[ebp]
  00217	51		 push	 ecx
  00218	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04BEMIBDAE@mTot?$AA@
  0021d	57		 push	 edi
  0021e	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 368  : 
; 369  :             pfxShowNormals->SetMatrixArray("mWorlds", rgmIndexedMatrices, 28);

  00224	8b 07		 mov	 eax, DWORD PTR [edi]
  00226	6a 1c		 push	 28			; 0000001cH
  00228	ff 75 1c	 push	 DWORD PTR _rgmIndexedMatrices$[ebp]
  0022b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07HHMNENJH@mWorlds?$AA@
  00230	57		 push	 edi
  00231	ff 90 a0 00 00
	00		 call	 DWORD PTR [eax+160]
$L56411:

; 370  : 
; 371  :             //for (iMatrix = 0; iMatrix < cIndexedMatrices; iMatrix++)
; 372  :             //{
; 373  :               //  pfxShowNormals->SetMatrix(x_rgszMatrix[iMatrix], &rgmIndexedMatrices[iMatrix]);
; 374  :             //}
; 375  :         }
; 376  : 
; 377  :         pfxShowNormals->SetVector("vScl", &vScale);                       

  00237	8b 07		 mov	 eax, DWORD PTR [edi]
  00239	8d 4d d0	 lea	 ecx, DWORD PTR _vScale$[ebp]
  0023c	51		 push	 ecx
  0023d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04BFCOOMBD@vScl?$AA@
  00242	57		 push	 edi
  00243	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 378  :         pfxShowNormals->SetVector("vClr", (D3DXVECTOR4*)&vClr);                       

  00249	8b 07		 mov	 eax, DWORD PTR [edi]
  0024b	8d 4d e0	 lea	 ecx, DWORD PTR _vClr$[ebp]
  0024e	51		 push	 ecx
  0024f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JKCKMDGO@vClr?$AA@
  00254	57		 push	 edi
  00255	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 379  : 
; 380  :         dwSoftwareMode = m_pDevice->GetSoftwareVertexProcessing();

  0025b	8b 06		 mov	 eax, DWORD PTR [esi]
  0025d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0025f	50		 push	 eax
  00260	ff 91 38 01 00
	00		 call	 DWORD PTR [ecx+312]

; 381  :         if (!m_bHWVertexShaders)

  00266	83 7e 14 00	 cmp	 DWORD PTR [esi+20], 0
  0026a	89 45 f0	 mov	 DWORD PTR _dwSoftwareMode$[ebp], eax
  0026d	75 14		 jne	 SHORT $L56416

; 382  :         {
; 383  :             bChangedSWMode = TRUE;
; 384  :             m_pDevice->SetSoftwareVertexProcessing(TRUE);

  0026f	8b 06		 mov	 eax, DWORD PTR [esi]
  00271	8b 10		 mov	 edx, DWORD PTR [eax]
  00273	33 c9		 xor	 ecx, ecx
  00275	41		 inc	 ecx
  00276	51		 push	 ecx
  00277	50		 push	 eax
  00278	89 4d fc	 mov	 DWORD PTR _bChangedSWMode$[ebp], ecx
  0027b	ff 92 34 01 00
	00		 call	 DWORD PTR [edx+308]

; 385  :         }
; 386  :         // if in the wrong mode, then switch
; 387  :         else if (dwSoftwareMode && m_bHWVertexShaders)

  00281	eb 40		 jmp	 SHORT $L56791
$L56416:
  00283	85 c0		 test	 eax, eax
  00285	74 3c		 je	 SHORT $L56791

; 388  :         {
; 389  :             bChangedSWMode = TRUE;
; 390  :             m_pDevice->SetSoftwareVertexProcessing(FALSE);

  00287	8b 06		 mov	 eax, DWORD PTR [esi]
  00289	8b 08		 mov	 ecx, DWORD PTR [eax]
  0028b	6a 00		 push	 0
  0028d	50		 push	 eax
  0028e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bChangedSWMode$[ebp], 1
  00295	ff 91 34 01 00
	00		 call	 DWORD PTR [ecx+308]

; 391  :         }
; 392  :     }
; 393  :     else

  0029b	eb 26		 jmp	 SHORT $L56791
$L56403:

; 394  :     {
; 395  :         pfxCurrent = pfxColor;

  0029d	8b 45 14	 mov	 eax, DWORD PTR _pfxColor$[ebp]

; 396  :         dwFVF = D3DFVF_XYZ;
; 397  :         cBytesPerVertex = 12;
; 398  : 
; 399  :         pfxCurrent->SetVector("vClr", (D3DXVECTOR4*)&vClr);                       

  002a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a2	8d 55 e0	 lea	 edx, DWORD PTR _vClr$[ebp]
  002a5	52		 push	 edx
  002a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JKCKMDGO@vClr?$AA@
  002ab	50		 push	 eax
  002ac	89 45 10	 mov	 DWORD PTR _pfxCurrent$[ebp], eax
  002af	c7 45 14 02 00
	00 00		 mov	 DWORD PTR _dwFVF$[ebp], 2
  002b6	c7 45 f8 0c 00
	00 00		 mov	 DWORD PTR _cBytesPerVertex$[ebp], 12 ; 0000000cH
  002bd	ff 91 88 00 00
	00		 call	 DWORD PTR [ecx+136]
$L56791:

; 400  :     }
; 401  : 
; 402  :     if ((iAttrib < m_caeAttributeTable) && (m_rgaeAttributeTable[iAttrib].AttribId == iAttrib))

  002c3	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  002c6	8b 4d 08	 mov	 ecx, DWORD PTR _iAttrib$[ebp]
  002c9	3b cf		 cmp	 ecx, edi
  002cb	73 0f		 jae	 SHORT $L56421
  002cd	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  002d0	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  002d3	39 0c 82	 cmp	 DWORD PTR [edx+eax*4], ecx
  002d6	75 04		 jne	 SHORT $L56421

; 403  :     {
; 404  :         iSubset = iAttrib;

  002d8	8b c1		 mov	 eax, ecx

; 405  :     }
; 406  :     else

  002da	eb 15		 jmp	 SHORT $L56786
$L56421:

; 407  :     {
; 408  :         // look for the correct attribute table entry to draw
; 409  :         for (iSubset = 0; iSubset < m_caeAttributeTable; iSubset++)

  002dc	33 c0		 xor	 eax, eax
  002de	85 ff		 test	 edi, edi
  002e0	76 0f		 jbe	 SHORT $L56786
  002e2	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
$L56423:

; 410  :         {
; 411  :             if (m_rgaeAttributeTable[iSubset].AttribId == iAttrib)

  002e5	39 0a		 cmp	 DWORD PTR [edx], ecx
  002e7	74 08		 je	 SHORT $L56786
  002e9	40		 inc	 eax
  002ea	83 c2 14	 add	 edx, 20			; 00000014H
  002ed	3b c7		 cmp	 eax, edi
  002ef	72 f4		 jb	 SHORT $L56423
$L56786:

; 412  :             {
; 413  :                 break;
; 414  :             }
; 415  :         }
; 416  :     }
; 417  : 
; 418  :     if (iSubset < m_caeAttributeTable)

  002f1	3b c7		 cmp	 eax, edi
  002f3	0f 83 da 00 00
	00		 jae	 $L56794

; 419  :     {
; 420  :         if (m_rgaeAttributeTable[iSubset].VertexCount > 0)

  002f9	8d 1c 80	 lea	 ebx, DWORD PTR [eax+eax*4]
  002fc	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  002ff	c1 e3 02	 shl	 ebx, 2
  00302	83 7c 03 10 00	 cmp	 DWORD PTR [ebx+eax+16], 0
  00307	0f 86 c6 00 00
	00		 jbe	 $L56794

; 421  :         {
; 422  :             pfxCurrent->Begin(&cPasses, 0);

  0030d	8b 7d 10	 mov	 edi, DWORD PTR _pfxCurrent$[ebp]
  00310	8b 07		 mov	 eax, DWORD PTR [edi]
  00312	6a 00		 push	 0
  00314	8d 4d f4	 lea	 ecx, DWORD PTR _cPasses$[ebp]
  00317	51		 push	 ecx
  00318	57		 push	 edi
  00319	ff 90 04 01 00
	00		 call	 DWORD PTR [eax+260]

; 423  : 
; 424  :             for (iPass = 0; iPass < cPasses; iPass++)

  0031f	83 65 18 00	 and	 DWORD PTR _iPass$[ebp], 0
  00323	83 7d f4 00	 cmp	 DWORD PTR _cPasses$[ebp], 0
  00327	0f 86 9d 00 00
	00		 jbe	 $L56431
$L56429:

; 425  :             {
; 426  :                 m_pDevice->SetFVF(dwFVF);

  0032d	8b 06		 mov	 eax, DWORD PTR [esi]
  0032f	ff 75 14	 push	 DWORD PTR _dwFVF$[ebp]
  00332	8b 08		 mov	 ecx, DWORD PTR [eax]
  00334	50		 push	 eax
  00335	ff 91 64 01 00
	00		 call	 DWORD PTR [ecx+356]

; 427  : 
; 428  :                 pfxCurrent->BeginPass(iPass);

  0033b	ff 75 18	 push	 DWORD PTR _iPass$[ebp]
  0033e	8b 07		 mov	 eax, DWORD PTR [edi]
  00340	57		 push	 edi
  00341	ff 90 08 01 00
	00		 call	 DWORD PTR [eax+264]

; 429  : 
; 430  :                 m_pDevice->SetStreamSource(0, m_pVertexBuffer, 0, cBytesPerVertex);

  00347	ff 75 f8	 push	 DWORD PTR _cBytesPerVertex$[ebp]
  0034a	8b 06		 mov	 eax, DWORD PTR [esi]
  0034c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0034e	6a 00		 push	 0
  00350	ff 76 04	 push	 DWORD PTR [esi+4]
  00353	6a 00		 push	 0
  00355	50		 push	 eax
  00356	ff 91 90 01 00
	00		 call	 DWORD PTR [ecx+400]

; 431  : 
; 432  :                 if (iVertex == UNUSED32)

  0035c	8b 4d 0c	 mov	 ecx, DWORD PTR _iVertex$[ebp]
  0035f	83 f9 ff	 cmp	 ecx, -1
  00362	0f 85 88 00 00
	00		 jne	 $L56432

; 433  :                 {
; 434  :                     iVertexStart = m_rgaeAttributeTable[iSubset].VertexStart;

  00368	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0036b	03 c3		 add	 eax, ebx
  0036d	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]

; 435  :                     cLines = m_rgaeAttributeTable[iSubset].VertexCount;

  00370	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 436  : 
; 437  :                     while (cLines > 0)

  00373	85 c0		 test	 eax, eax
  00375	89 45 08	 mov	 DWORD PTR _cLines$[ebp], eax
  00378	76 35		 jbe	 SHORT $L56793
$L56434:

; 438  :                     {
; 439  :                         cLinesCur = min(cLines, (0xffff / 2));

  0037a	8b 4d 08	 mov	 ecx, DWORD PTR _cLines$[ebp]
  0037d	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00382	3b c8		 cmp	 ecx, eax
  00384	89 4d 1c	 mov	 DWORD PTR _cLinesCur$[ebp], ecx
  00387	72 03		 jb	 SHORT $L56762
  00389	89 45 1c	 mov	 DWORD PTR _cLinesCur$[ebp], eax
$L56762:

; 440  : 
; 441  :                         hr = m_pDevice->DrawPrimitive(D3DPT_LINELIST, 
; 442  :                                                      iVertexStart * 2, 
; 443  :                                                      cLinesCur);

  0038c	ff 75 1c	 push	 DWORD PTR _cLinesCur$[ebp]
  0038f	8b 06		 mov	 eax, DWORD PTR [esi]
  00391	8b 08		 mov	 ecx, DWORD PTR [eax]
  00393	8d 14 3f	 lea	 edx, DWORD PTR [edi+edi]
  00396	52		 push	 edx
  00397	6a 02		 push	 2
  00399	50		 push	 eax
  0039a	ff 91 44 01 00
	00		 call	 DWORD PTR [ecx+324]

; 444  :                         if (FAILED(hr))

  003a0	85 c0		 test	 eax, eax
  003a2	7c 45		 jl	 SHORT $L56383

; 445  :                             return hr;
; 446  : 
; 447  :                         iVertexStart += cLinesCur * 2;

  003a4	8b 45 1c	 mov	 eax, DWORD PTR _cLinesCur$[ebp]

; 448  :                         cLines -= cLinesCur;

  003a7	29 45 08	 sub	 DWORD PTR _cLines$[ebp], eax
  003aa	8d 3c 47	 lea	 edi, DWORD PTR [edi+eax*2]
  003ad	75 cb		 jne	 SHORT $L56434
$L56793:

; 449  :                     }
; 450  :                 }
; 451  :                 else

  003af	8b 7d 10	 mov	 edi, DWORD PTR _pfxCurrent$[ebp]
$L56438:

; 455  :                 }
; 456  : 
; 457  :                 pfxCurrent->EndPass();

  003b2	8b 07		 mov	 eax, DWORD PTR [edi]
  003b4	57		 push	 edi
  003b5	ff 90 10 01 00
	00		 call	 DWORD PTR [eax+272]
  003bb	ff 45 18	 inc	 DWORD PTR _iPass$[ebp]
  003be	8b 45 18	 mov	 eax, DWORD PTR _iPass$[ebp]
  003c1	3b 45 f4	 cmp	 eax, DWORD PTR _cPasses$[ebp]
  003c4	0f 82 63 ff ff
	ff		 jb	 $L56429
$L56431:

; 458  :             }
; 459  : 
; 460  :             pfxCurrent->End();

  003ca	8b 07		 mov	 eax, DWORD PTR [edi]
  003cc	57		 push	 edi
  003cd	ff 90 14 01 00
	00		 call	 DWORD PTR [eax+276]
$L56794:

; 461  : 
; 462  :         }
; 463  :     }
; 464  : 
; 465  :     if (bChangedSWMode)

  003d3	83 7d fc 00	 cmp	 DWORD PTR _bChangedSWMode$[ebp], 0
  003d7	74 0e		 je	 SHORT $L56439

; 466  :     {
; 467  :         m_pDevice->SetSoftwareVertexProcessing(dwSoftwareMode);

  003d9	8b 36		 mov	 esi, DWORD PTR [esi]
  003db	ff 75 f0	 push	 DWORD PTR _dwSoftwareMode$[ebp]
  003de	8b 06		 mov	 eax, DWORD PTR [esi]
  003e0	56		 push	 esi
  003e1	ff 90 34 01 00
	00		 call	 DWORD PTR [eax+308]
$L56439:

; 468  :     }
; 469  : 
; 470  :     return S_OK;

  003e7	33 c0		 xor	 eax, eax
$L56383:
  003e9	5f		 pop	 edi
  003ea	5e		 pop	 esi
  003eb	5b		 pop	 ebx

; 471  : }

  003ec	c9		 leave
  003ed	c2 1c 00	 ret	 28			; 0000001cH
$L56432:

; 452  :                 {
; 453  :                     hr = m_pDevice->DrawPrimitive(D3DPT_LINELIST, 
; 454  :                                                  iVertex * 2, 1);

  003f0	8b 06		 mov	 eax, DWORD PTR [esi]
  003f2	8b 10		 mov	 edx, DWORD PTR [eax]
  003f4	6a 01		 push	 1
  003f6	03 c9		 add	 ecx, ecx
  003f8	51		 push	 ecx
  003f9	6a 02		 push	 2
  003fb	50		 push	 eax
  003fc	ff 92 44 01 00
	00		 call	 DWORD PTR [edx+324]
  00402	eb ae		 jmp	 SHORT $L56438
?Draw@CShowNormals@@QAEJKKPAUID3DXEffect@@0KPAUD3DXMATRIX@@K@Z ENDP ; CShowNormals::Draw
_TEXT	ENDS
END
