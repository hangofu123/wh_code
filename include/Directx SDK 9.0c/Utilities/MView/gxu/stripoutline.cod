; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.4035 

	TITLE	.\stripoutline.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04IHCGOIEL@mWd1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04KMALLLII@mWd2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LFBAIKMJ@mWd3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04PKFBBMAO@mWd4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04ODEKCNEP@mWd5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04MIGHHOIM@mWd6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04NBHMEPMN@mWd7?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04FGOEFDAC@mWd8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04EPPPGCED@mWd9?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DOMPIIAD@mWd10?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05CHNELJEC@mWd11?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MPJOKIB@mWd12?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05BFOCNLMA@mWd13?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05FKKDENAH@mWd14?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05EDLIHMEG@mWd15?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05GIJFCPIF@mWd16?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HBIOBOME@mWd17?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PGBGACAL@mWd18?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05OPANDDEK@mWd19?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DMIJDGFK@mWd20?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05CFJCAHBL@mWd21?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05OLPFENI@mWd22?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05BHKEGFJJ@mWd23?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05FIOFPDFO@mWd24?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05EBPOMCBP@mWd25?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05GKNDJBNM@mWd26?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HDMIKAJN@mWd27?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PEFALMFC@mWd28?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BEMIBDAE@mTot?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07HHMNENJH@mWorlds?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04JKCKMDGO@vClr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CStripOutline@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CStripOutline@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BConnected@@YA_NPAI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIPAE2AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendSkinnedMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendIndexSkinnedMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendIndexSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CStripOutline@@QAEJPAUID3DXBaseMesh@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@CStripOutline@@QAEJPAUIDirect3DDevice9@@KPAUID3DXEffect@@1KPAUD3DXMATRIX@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateEmptyOutline@CStripOutline@@AAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CD3DXCrackDecl1@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PxyzwGetTexCoord@DXCrackFVF@@QAEPAUD3DXVECTOR4@@PAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PfGetWeights@CD3DXCrackDecl1@@QAEPAMPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CWeights@CD3DXCrackDecl1@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PfGetWeights@DXCrackFVF@@QAEPAMPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CWeights@DXCrackFVF@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetArrayElem@DXCrackFVF@@QAEPAEPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_0D3DXVECTOR3@@QAEAAU0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetArrayElem@CD3DXCrackDecl1@@QAEPAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DXCrackFVF@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04IHCGOIEL@mWd1?$AA@			; `string'
PUBLIC	??_C@_04KMALLLII@mWd2?$AA@			; `string'
PUBLIC	??_C@_04LFBAIKMJ@mWd3?$AA@			; `string'
PUBLIC	??_C@_04PKFBBMAO@mWd4?$AA@			; `string'
PUBLIC	??_C@_04ODEKCNEP@mWd5?$AA@			; `string'
PUBLIC	??_C@_04MIGHHOIM@mWd6?$AA@			; `string'
PUBLIC	??_C@_04NBHMEPMN@mWd7?$AA@			; `string'
PUBLIC	??_C@_04FGOEFDAC@mWd8?$AA@			; `string'
PUBLIC	??_C@_04EPPPGCED@mWd9?$AA@			; `string'
PUBLIC	??_C@_05DOMPIIAD@mWd10?$AA@			; `string'
PUBLIC	??_C@_05CHNELJEC@mWd11?$AA@			; `string'
PUBLIC	??_C@_05MPJOKIB@mWd12?$AA@			; `string'
PUBLIC	??_C@_05BFOCNLMA@mWd13?$AA@			; `string'
PUBLIC	??_C@_05FKKDENAH@mWd14?$AA@			; `string'
PUBLIC	??_C@_05EDLIHMEG@mWd15?$AA@			; `string'
PUBLIC	??_C@_05GIJFCPIF@mWd16?$AA@			; `string'
PUBLIC	??_C@_05HBIOBOME@mWd17?$AA@			; `string'
PUBLIC	??_C@_05PGBGACAL@mWd18?$AA@			; `string'
PUBLIC	??_C@_05OPANDDEK@mWd19?$AA@			; `string'
PUBLIC	??_C@_05DMIJDGFK@mWd20?$AA@			; `string'
PUBLIC	??_C@_05CFJCAHBL@mWd21?$AA@			; `string'
PUBLIC	??_C@_05OLPFENI@mWd22?$AA@			; `string'
PUBLIC	??_C@_05BHKEGFJJ@mWd23?$AA@			; `string'
PUBLIC	??_C@_05FIOFPDFO@mWd24?$AA@			; `string'
PUBLIC	??_C@_05EBPOMCBP@mWd25?$AA@			; `string'
PUBLIC	??_C@_05GKNDJBNM@mWd26?$AA@			; `string'
PUBLIC	??_C@_05HDMIKAJN@mWd27?$AA@			; `string'
PUBLIC	??_C@_05PEFALMFC@mWd28?$AA@			; `string'
;	COMDAT ??_C@_04IHCGOIEL@mWd1?$AA@
CONST	SEGMENT
??_C@_04IHCGOIEL@mWd1?$AA@ DB 'mWd1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KMALLLII@mWd2?$AA@
CONST	SEGMENT
??_C@_04KMALLLII@mWd2?$AA@ DB 'mWd2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LFBAIKMJ@mWd3?$AA@
CONST	SEGMENT
??_C@_04LFBAIKMJ@mWd3?$AA@ DB 'mWd3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PKFBBMAO@mWd4?$AA@
CONST	SEGMENT
??_C@_04PKFBBMAO@mWd4?$AA@ DB 'mWd4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ODEKCNEP@mWd5?$AA@
CONST	SEGMENT
??_C@_04ODEKCNEP@mWd5?$AA@ DB 'mWd5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MIGHHOIM@mWd6?$AA@
CONST	SEGMENT
??_C@_04MIGHHOIM@mWd6?$AA@ DB 'mWd6', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NBHMEPMN@mWd7?$AA@
CONST	SEGMENT
??_C@_04NBHMEPMN@mWd7?$AA@ DB 'mWd7', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FGOEFDAC@mWd8?$AA@
CONST	SEGMENT
??_C@_04FGOEFDAC@mWd8?$AA@ DB 'mWd8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EPPPGCED@mWd9?$AA@
CONST	SEGMENT
??_C@_04EPPPGCED@mWd9?$AA@ DB 'mWd9', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DOMPIIAD@mWd10?$AA@
CONST	SEGMENT
??_C@_05DOMPIIAD@mWd10?$AA@ DB 'mWd10', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CHNELJEC@mWd11?$AA@
CONST	SEGMENT
??_C@_05CHNELJEC@mWd11?$AA@ DB 'mWd11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPJOKIB@mWd12?$AA@
CONST	SEGMENT
??_C@_05MPJOKIB@mWd12?$AA@ DB 'mWd12', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BFOCNLMA@mWd13?$AA@
CONST	SEGMENT
??_C@_05BFOCNLMA@mWd13?$AA@ DB 'mWd13', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKKDENAH@mWd14?$AA@
CONST	SEGMENT
??_C@_05FKKDENAH@mWd14?$AA@ DB 'mWd14', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EDLIHMEG@mWd15?$AA@
CONST	SEGMENT
??_C@_05EDLIHMEG@mWd15?$AA@ DB 'mWd15', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GIJFCPIF@mWd16?$AA@
CONST	SEGMENT
??_C@_05GIJFCPIF@mWd16?$AA@ DB 'mWd16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HBIOBOME@mWd17?$AA@
CONST	SEGMENT
??_C@_05HBIOBOME@mWd17?$AA@ DB 'mWd17', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PGBGACAL@mWd18?$AA@
CONST	SEGMENT
??_C@_05PGBGACAL@mWd18?$AA@ DB 'mWd18', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OPANDDEK@mWd19?$AA@
CONST	SEGMENT
??_C@_05OPANDDEK@mWd19?$AA@ DB 'mWd19', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DMIJDGFK@mWd20?$AA@
CONST	SEGMENT
??_C@_05DMIJDGFK@mWd20?$AA@ DB 'mWd20', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFJCAHBL@mWd21?$AA@
CONST	SEGMENT
??_C@_05CFJCAHBL@mWd21?$AA@ DB 'mWd21', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OLPFENI@mWd22?$AA@
CONST	SEGMENT
??_C@_05OLPFENI@mWd22?$AA@ DB 'mWd22', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BHKEGFJJ@mWd23?$AA@
CONST	SEGMENT
??_C@_05BHKEGFJJ@mWd23?$AA@ DB 'mWd23', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FIOFPDFO@mWd24?$AA@
CONST	SEGMENT
??_C@_05FIOFPDFO@mWd24?$AA@ DB 'mWd24', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EBPOMCBP@mWd25?$AA@
CONST	SEGMENT
??_C@_05EBPOMCBP@mWd25?$AA@ DB 'mWd25', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GKNDJBNM@mWd26?$AA@
CONST	SEGMENT
??_C@_05GKNDJBNM@mWd26?$AA@ DB 'mWd26', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDMIKAJN@mWd27?$AA@
CONST	SEGMENT
??_C@_05HDMIKAJN@mWd27?$AA@ DB 'mWd27', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PEFALMFC@mWd28?$AA@
CONST	SEGMENT
??_C@_05PEFALMFC@mWd28?$AA@ DB 'mWd28', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_x_rgszMatrix DD FLAT:??_C@_04IHCGOIEL@mWd1?$AA@
	DD	FLAT:??_C@_04KMALLLII@mWd2?$AA@
	DD	FLAT:??_C@_04LFBAIKMJ@mWd3?$AA@
	DD	FLAT:??_C@_04PKFBBMAO@mWd4?$AA@
	DD	FLAT:??_C@_04ODEKCNEP@mWd5?$AA@
	DD	FLAT:??_C@_04MIGHHOIM@mWd6?$AA@
	DD	FLAT:??_C@_04NBHMEPMN@mWd7?$AA@
	DD	FLAT:??_C@_04FGOEFDAC@mWd8?$AA@
	DD	FLAT:??_C@_04EPPPGCED@mWd9?$AA@
	DD	FLAT:??_C@_05DOMPIIAD@mWd10?$AA@
	DD	FLAT:??_C@_05CHNELJEC@mWd11?$AA@
	DD	FLAT:??_C@_05MPJOKIB@mWd12?$AA@
	DD	FLAT:??_C@_05BFOCNLMA@mWd13?$AA@
	DD	FLAT:??_C@_05FKKDENAH@mWd14?$AA@
	DD	FLAT:??_C@_05EDLIHMEG@mWd15?$AA@
	DD	FLAT:??_C@_05GIJFCPIF@mWd16?$AA@
	DD	FLAT:??_C@_05HBIOBOME@mWd17?$AA@
	DD	FLAT:??_C@_05PGBGACAL@mWd18?$AA@
	DD	FLAT:??_C@_05OPANDDEK@mWd19?$AA@
	DD	FLAT:??_C@_05DMIJDGFK@mWd20?$AA@
	DD	FLAT:??_C@_05CFJCAHBL@mWd21?$AA@
	DD	FLAT:??_C@_05OLPFENI@mWd22?$AA@
	DD	FLAT:??_C@_05BHKEGFJJ@mWd23?$AA@
	DD	FLAT:??_C@_05FIOFPDFO@mWd24?$AA@
	DD	FLAT:??_C@_05EBPOMCBP@mWd25?$AA@
	DD	FLAT:??_C@_05GKNDJBNM@mWd26?$AA@
	DD	FLAT:??_C@_05HDMIKAJN@mWd27?$AA@
	DD	FLAT:??_C@_05PEFALMFC@mWd28?$AA@
_DATA	ENDS
CONST	SEGMENT
_x_rgdwTexCoordSize DD 08H
	DD	0cH
	DD	010H
	DD	04H
CONST	ENDS
PUBLIC	??1CStripOutline@@QAE@XZ			; CStripOutline::~CStripOutline
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\stripoutline.cpp
;	COMDAT ??1CStripOutline@@QAE@XZ
_TEXT	SEGMENT
??1CStripOutline@@QAE@XZ PROC NEAR			; CStripOutline::~CStripOutline, COMDAT
; _this$ = ecx

; 63   : }

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 59   : {

  00003	8b f1		 mov	 esi, ecx

; 60   :     GXRELEASE(m_pVertexBuffer);

  00005	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00008	85 c0		 test	 eax, eax
  0000a	74 0a		 je	 SHORT $L56307
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	50		 push	 eax
  0000f	ff 51 08	 call	 DWORD PTR [ecx+8]
  00012	83 66 4c 00	 and	 DWORD PTR [esi+76], 0
$L56307:

; 61   :     GXRELEASE(m_pDecl);

  00016	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  00019	85 c0		 test	 eax, eax
  0001b	74 0a		 je	 SHORT $L56311
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	50		 push	 eax
  00020	ff 51 08	 call	 DWORD PTR [ecx+8]
  00023	83 66 50 00	 and	 DWORD PTR [esi+80], 0
$L56311:

; 62   :     delete []m_rgaeAttributeTable;

  00027	ff 76 54	 push	 DWORD PTR [esi+84]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	5e		 pop	 esi

; 63   : }

  00031	c3		 ret	 0
??1CStripOutline@@QAE@XZ ENDP				; CStripOutline::~CStripOutline
_TEXT	ENDS
PUBLIC	?BConnected@@YA_NPAI0@Z				; BConnected
; Function compile flags: /Ogs
;	COMDAT ?BConnected@@YA_NPAI0@Z
_TEXT	SEGMENT
_pwFace1$ = 8						; size = 4
_pwFace2$ = 12						; size = 4
?BConnected@@YA_NPAI0@Z PROC NEAR			; BConnected, COMDAT

; 88   : }

  00000	8b ff		 npad	 2

; 66   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 67   :     UINT cSharedPoints;
; 68   :     UINT iPoint1;
; 69   :     UINT iPoint2;
; 70   : 
; 71   :     cSharedPoints = 0;

  00006	33 f6		 xor	 esi, esi
  00008	57		 push	 edi

; 72   :     for (iPoint1 = 0; iPoint1 < 3; iPoint1++)

  00009	33 d2		 xor	 edx, edx
$L56322:

; 73   :     {
; 74   :         for (iPoint2 = 0; iPoint2 < 3; iPoint2++)
; 75   :         {
; 76   :             if (pwFace1[iPoint1] == pwFace2[iPoint2])

  0000b	8b 45 08	 mov	 eax, DWORD PTR _pwFace1$[ebp]
  0000e	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00011	33 c9		 xor	 ecx, ecx
$L56325:
  00013	8b 7d 0c	 mov	 edi, DWORD PTR _pwFace2$[ebp]
  00016	3b 04 8f	 cmp	 eax, DWORD PTR [edi+ecx*4]
  00019	74 08		 je	 SHORT $L56812
  0001b	41		 inc	 ecx
  0001c	83 f9 03	 cmp	 ecx, 3
  0001f	72 f2		 jb	 SHORT $L56325
  00021	eb 01		 jmp	 SHORT $L56323
$L56812:

; 77   :             {
; 78   :                 cSharedPoints += 1;

  00023	46		 inc	 esi
$L56323:

; 72   :     for (iPoint1 = 0; iPoint1 < 3; iPoint1++)

  00024	42		 inc	 edx
  00025	83 fa 03	 cmp	 edx, 3
  00028	72 e1		 jb	 SHORT $L56322

; 79   : 
; 80   :                 break;
; 81   :             }
; 82   :         }
; 83   :     }
; 84   : 
; 85   :     GXASSERT(cSharedPoints <= 3);
; 86   : 
; 87   :     return cSharedPoints >= 2;

  0002a	83 fe 02	 cmp	 esi, 2
  0002d	1b c0		 sbb	 eax, eax
  0002f	5f		 pop	 edi
  00030	40		 inc	 eax
  00031	5e		 pop	 esi

; 88   : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?BConnected@@YA_NPAI0@Z ENDP				; BConnected
_TEXT	ENDS
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC NEAR				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 315  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
EXTRN	__fltused:NEAR
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 308  : }

  00000	8b ff		 npad	 2

; 304  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx

; 305  :     x = fx;

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _fx$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 306  :     y = fy;

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _fy$[ebp]
  0000f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 307  :     z = fz;

  00012	8b 4d 10	 mov	 ecx, DWORD PTR _fz$[ebp]
  00015	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 308  : }

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z			; D3DXVECTOR3::operator+=
; Function compile flags: /Ogs
;	COMDAT ??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z PROC NEAR		; D3DXVECTOR3::operator+=, COMDAT
; _this$ = ecx

; 332  :     return *this;
; 333  : }

  00000	8b ff		 npad	 2

; 328  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx

; 329  :     x += v.x;

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0000a	d9 01		 fld	 DWORD PTR [ecx]
  0000c	d8 00		 fadd	 DWORD PTR [eax]
  0000e	d9 18		 fstp	 DWORD PTR [eax]

; 330  :     y += v.y;

  00010	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00013	d8 40 04	 fadd	 DWORD PTR [eax+4]
  00016	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 331  :     z += v.z;

  00019	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0001c	d8 40 08	 fadd	 DWORD PTR [eax+8]
  0001f	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 332  :     return *this;
; 333  : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+=
_TEXT	ENDS
PUBLIC	??_0D3DXVECTOR3@@QAEAAU0@M@Z			; D3DXVECTOR3::operator/=
; Function compile flags: /Ogs
;	COMDAT ??_0D3DXVECTOR3@@QAEAAU0@M@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
??_0D3DXVECTOR3@@QAEAAU0@M@Z PROC NEAR			; D3DXVECTOR3::operator/=, COMDAT
; _this$ = ecx

; 360  :     return *this;
; 361  : }

  00000	8b ff		 npad	 2

; 355  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 356  :     FLOAT fInv = 1.0f / f;

  00005	d9 e8		 fld1
  00007	8b c1		 mov	 eax, ecx
  00009	d8 75 08	 fdiv	 DWORD PTR _f$[ebp]

; 357  :     x *= fInv;

  0000c	d9 c0		 fld	 ST(0)
  0000e	d8 08		 fmul	 DWORD PTR [eax]
  00010	d9 18		 fstp	 DWORD PTR [eax]

; 358  :     y *= fInv;

  00012	d9 c0		 fld	 ST(0)
  00014	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00017	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 359  :     z *= fInv;

  0001a	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001d	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 360  :     return *this;
; 361  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_0D3DXVECTOR3@@QAEAAU0@M@Z ENDP			; D3DXVECTOR3::operator/=
_TEXT	ENDS
PUBLIC	?CreateEmptyOutline@CStripOutline@@AAEJXZ	; CStripOutline::CreateEmptyOutline
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\stripoutline.cpp
;	COMDAT ?CreateEmptyOutline@CStripOutline@@AAEJXZ
_TEXT	SEGMENT
?CreateEmptyOutline@CStripOutline@@AAEJXZ PROC NEAR	; CStripOutline::CreateEmptyOutline, COMDAT
; _this$ = ecx

; 919  : }

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 908  : {

  00003	8b f1		 mov	 esi, ecx

; 909  :     GXRELEASE(m_pVertexBuffer);

  00005	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	3b c7		 cmp	 eax, edi
  0000d	74 09		 je	 SHORT $L56732
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	50		 push	 eax
  00012	ff 51 08	 call	 DWORD PTR [ecx+8]
  00015	89 7e 4c	 mov	 DWORD PTR [esi+76], edi
$L56732:

; 910  :     m_caeAttributeTable = 0;
; 911  :     delete []m_rgaeAttributeTable;

  00018	ff 76 54	 push	 DWORD PTR [esi+84]
  0001b	89 7e 58	 mov	 DWORD PTR [esi+88], edi
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	59		 pop	 ecx

; 912  :     m_rgaeAttributeTable = NULL;

  00024	89 7e 54	 mov	 DWORD PTR [esi+84], edi

; 913  : 
; 914  :     m_cLines = 0;

  00027	89 7e 5c	 mov	 DWORD PTR [esi+92], edi

; 915  :     m_cVertices = 0;

  0002a	89 7e 60	 mov	 DWORD PTR [esi+96], edi

; 916  :     m_bSkinning = FALSE;

  0002d	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  00030	5f		 pop	 edi

; 917  : 
; 918  :     return S_OK;

  00031	33 c0		 xor	 eax, eax
  00033	5e		 pop	 esi

; 919  : }

  00034	c3		 ret	 0
?CreateEmptyOutline@CStripOutline@@AAEJXZ ENDP		; CStripOutline::CreateEmptyOutline
_TEXT	ENDS
PUBLIC	__real@3b808081
PUBLIC	??0D3DXCOLOR@@QAE@K@Z				; D3DXCOLOR::D3DXCOLOR
;	COMDAT __real@3b808081
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.inl
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
; Function compile flags: /Ogs
CONST	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@K@Z
_TEXT	SEGMENT
tv186 = 8						; size = 4
tv185 = 8						; size = 4
tv184 = 8						; size = 4
tv183 = 8						; size = 4
_dw$ = 8						; size = 4
??0D3DXCOLOR@@QAE@K@Z PROC NEAR				; D3DXCOLOR::D3DXCOLOR, COMDAT
; _this$ = ecx

; 1352 : }

  00000	8b ff		 npad	 2

; 1346 : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1347 :     CONST FLOAT f = 1.0f / 255.0f;
; 1348 :     r = f * (FLOAT) (unsigned char) (dw >> 16);

  00005	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3b808081
  0000b	8b c1		 mov	 eax, ecx
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _dw$[ebp]
  00010	8b d1		 mov	 edx, ecx
  00012	c1 ea 10	 shr	 edx, 16			; 00000010H
  00015	0f b6 d2	 movzx	 edx, dl
  00018	89 55 08	 mov	 DWORD PTR tv186[ebp], edx

; 1349 :     g = f * (FLOAT) (unsigned char) (dw >>  8);

  0001b	8b d1		 mov	 edx, ecx
  0001d	c1 ea 08	 shr	 edx, 8
  00020	db 45 08	 fild	 DWORD PTR tv186[ebp]
  00023	0f b6 d2	 movzx	 edx, dl
  00026	d8 c9		 fmul	 ST(0), ST(1)
  00028	89 55 08	 mov	 DWORD PTR tv185[ebp], edx

; 1350 :     b = f * (FLOAT) (unsigned char) (dw >>  0);

  0002b	0f b6 d1	 movzx	 edx, cl
  0002e	d9 18		 fstp	 DWORD PTR [eax]
  00030	db 45 08	 fild	 DWORD PTR tv185[ebp]
  00033	89 55 08	 mov	 DWORD PTR tv184[ebp], edx

; 1351 :     a = f * (FLOAT) (unsigned char) (dw >> 24);

  00036	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00039	d8 c9		 fmul	 ST(0), ST(1)
  0003b	d9 58 04	 fstp	 DWORD PTR [eax+4]
  0003e	db 45 08	 fild	 DWORD PTR tv184[ebp]
  00041	89 4d 08	 mov	 DWORD PTR tv183[ebp], ecx
  00044	d8 c9		 fmul	 ST(0), ST(1)
  00046	d9 58 08	 fstp	 DWORD PTR [eax+8]
  00049	db 45 08	 fild	 DWORD PTR tv183[ebp]
  0004c	d8 c9		 fmul	 ST(0), ST(1)
  0004e	d9 58 0c	 fstp	 DWORD PTR [eax+12]
  00051	dd d8		 fstp	 ST(0)

; 1352 : }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
??0D3DXCOLOR@@QAE@K@Z ENDP				; D3DXCOLOR::D3DXCOLOR
_TEXT	ENDS
PUBLIC	?CWeights@DXCrackFVF@@QAEKXZ			; DXCrackFVF::CWeights
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\gxcrackfvf.h
;	COMDAT ?CWeights@DXCrackFVF@@QAEKXZ
_TEXT	SEGMENT
?CWeights@DXCrackFVF@@QAEKXZ PROC NEAR			; DXCrackFVF::CWeights, COMDAT
; _this$ = ecx

; 76   :     inline DWORD        CWeights()      { return m_cWeights; }

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	c3		 ret	 0
?CWeights@DXCrackFVF@@QAEKXZ ENDP			; DXCrackFVF::CWeights
_TEXT	ENDS
PUBLIC	??0DXCrackFVF@@QAE@K@Z				; DXCrackFVF::DXCrackFVF
; Function compile flags: /Ogs
;	COMDAT ??0DXCrackFVF@@QAE@K@Z
_TEXT	SEGMENT
_dwFVF$ = 8						; size = 4
??0DXCrackFVF@@QAE@K@Z PROC NEAR			; DXCrackFVF::DXCrackFVF, COMDAT
; _this$ = ecx

; 192  : }

  00000	8b ff		 npad	 2

; 115  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx
  00007	53		 push	 ebx
  00008	8b 5d 08	 mov	 ebx, DWORD PTR _dwFVF$[ebp]
  0000b	56		 push	 esi

; 116  :     DWORD oCur = 0;
; 117  :     DWORD dwPosition;
; 118  :     DWORD dwTexCoordInfo;
; 119  :     DWORD iTexCoord;
; 120  :     DWORD dwTexCoordSize;
; 121  :     m_oTex[0] = 0;
; 122  : 
; 123  :     dwPosition = dwFVF & D3DFVF_POSITION_MASK;

  0000c	8b d3		 mov	 edx, ebx
  0000e	57		 push	 edi
  0000f	33 ff		 xor	 edi, edi
  00011	81 e2 0e 40 00
	00		 and	 edx, 16398		; 0000400eH
  00017	33 c9		 xor	 ecx, ecx

; 124  : 
; 125  :     if (dwPosition == D3DFVF_XYZ)

  00019	83 fa 02	 cmp	 edx, 2
  0001c	8d 70 18	 lea	 esi, DWORD PTR [eax+24]
  0001f	89 18		 mov	 DWORD PTR [eax], ebx
  00021	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00024	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00027	89 78 10	 mov	 DWORD PTR [eax+16], edi
  0002a	89 78 14	 mov	 DWORD PTR [eax+20], edi
  0002d	89 78 38	 mov	 DWORD PTR [eax+56], edi
  00030	89 78 3c	 mov	 DWORD PTR [eax+60], edi
  00033	89 3e		 mov	 DWORD PTR [esi], edi
  00035	75 05		 jne	 SHORT $L55537

; 126  :     {
; 127  :         oCur += 3 * sizeof(float);

  00037	6a 0c		 push	 12			; 0000000cH
$L56835:
  00039	59		 pop	 ecx

; 128  :     }
; 129  :     else if (dwPosition == D3DFVF_XYZRHW)

  0003a	eb 1d		 jmp	 SHORT $L56832
$L55537:
  0003c	83 fa 04	 cmp	 edx, 4
  0003f	75 04		 jne	 SHORT $L55540

; 130  :     {
; 131  :         oCur += 4 * sizeof(float);

  00041	6a 10		 push	 16			; 00000010H

; 132  :     }
; 133  :     else if (dwPosition >= D3DFVF_XYZB1)

  00043	eb f4		 jmp	 SHORT $L56835
$L55540:
  00045	83 fa 06	 cmp	 edx, 6
  00048	72 0f		 jb	 SHORT $L56832

; 134  :     {
; 135  :         m_cWeights = (dwPosition >> 1) - 2;

  0004a	d1 ea		 shr	 edx, 1
  0004c	8d 4a fe	 lea	 ecx, DWORD PTR [edx-2]
  0004f	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 136  :         oCur += (3 + m_cWeights) * sizeof(float);

  00052	8d 0c 8d 0c 00
	00 00		 lea	 ecx, DWORD PTR [ecx*4+12]
$L56832:

; 137  :     }
; 138  : 
; 139  :     if ( dwFVF & D3DFVF_NORMAL )

  00059	f6 c3 10	 test	 bl, 16			; 00000010H
  0005c	74 06		 je	 SHORT $L55545

; 140  :     {
; 141  :         m_oNormal = oCur;

  0005e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 142  :         oCur += 3 * sizeof(float);

  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
$L55545:

; 143  :     }
; 144  : 
; 145  :     if ( dwFVF & D3DFVF_PSIZE )

  00064	f6 c3 20	 test	 bl, 32			; 00000020H
  00067	74 06		 je	 SHORT $L56833

; 146  :     {
; 147  :         m_oPointSize = oCur;

  00069	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 148  :         oCur += sizeof(float);

  0006c	83 c1 04	 add	 ecx, 4
$L56833:

; 149  :     }
; 150  : 
; 151  :     if ( dwFVF & D3DFVF_DIFFUSE )

  0006f	f6 c3 40	 test	 bl, 64			; 00000040H
  00072	74 06		 je	 SHORT $L56834

; 152  :     {
; 153  :         m_oDiffuse = oCur;

  00074	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 154  :         oCur += sizeof(D3DCOLOR);

  00077	83 c1 04	 add	 ecx, 4
$L56834:

; 155  :     }
; 156  : 
; 157  :     if ( dwFVF & D3DFVF_SPECULAR )

  0007a	84 db		 test	 bl, bl
  0007c	79 06		 jns	 SHORT $L55551

; 158  :     {
; 159  :         m_oSpecular = oCur;

  0007e	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 160  :         oCur += sizeof(D3DCOLOR);

  00081	83 c1 04	 add	 ecx, 4
$L55551:

; 161  :     }
; 162  : 
; 163  :     if ( dwFVF & D3DFVF_TEXCOUNT_MASK )

  00084	f6 c7 0f	 test	 bh, 15			; 0000000fH
  00087	74 3d		 je	 SHORT $L55557

; 164  :     {
; 165  :         m_oTex[0] = oCur;
; 166  : 
; 167  :         // only one tu/tv set currently supported
; 168  : 
; 169  :         m_cTexCoords = ((dwFVF & D3DFVF_TEXCOUNT_MASK)>>D3DFVF_TEXCOUNT_SHIFT);

  00089	8b d3		 mov	 edx, ebx
  0008b	c1 ea 08	 shr	 edx, 8
  0008e	83 e2 0f	 and	 edx, 15			; 0000000fH

; 170  : 
; 171  :         if(m_cTexCoords > 8)

  00091	83 fa 08	 cmp	 edx, 8
  00094	89 0e		 mov	 DWORD PTR [esi], ecx
  00096	89 50 3c	 mov	 DWORD PTR [eax+60], edx
  00099	76 07		 jbe	 SHORT $L55554

; 172  :             m_cTexCoords = 8;

  0009b	c7 40 3c 08 00
	00 00		 mov	 DWORD PTR [eax+60], 8
$L55554:

; 173  : 
; 174  :         // all 2d, then go quick route
; 175  :         //if ((dwFVF & 0xffff0000) == 0)
; 176  :         //{
; 177  :             //oCur += sizeof(float) * 2 * m_cTexCoords;
; 178  :         //}
; 179  :         //else
; 180  :         {
; 181  :             dwTexCoordSize = (dwFVF & 0xffff0000) >> 16;

  000a2	c1 eb 10	 shr	 ebx, 16			; 00000010H

; 182  :             for (iTexCoord = 0; iTexCoord < m_cTexCoords; iTexCoord++)

  000a5	33 d2		 xor	 edx, edx
  000a7	39 78 3c	 cmp	 DWORD PTR [eax+60], edi
  000aa	76 1a		 jbe	 SHORT $L55557
$L55555:

; 183  :             {
; 184  :                 m_oTex[iTexCoord] = oCur;
; 185  :                 oCur += x_rgdwTexCoordSize[dwTexCoordSize & 0x3];

  000ac	8b fb		 mov	 edi, ebx
  000ae	83 e7 03	 and	 edi, 3
  000b1	89 0e		 mov	 DWORD PTR [esi], ecx
  000b3	03 0c bd 00 00
	00 00		 add	 ecx, DWORD PTR _x_rgdwTexCoordSize[edi*4]

; 186  :                 dwTexCoordSize = dwTexCoordSize >> 2;

  000ba	c1 eb 02	 shr	 ebx, 2
  000bd	42		 inc	 edx
  000be	83 c6 04	 add	 esi, 4
  000c1	3b 50 3c	 cmp	 edx, DWORD PTR [eax+60]
  000c4	72 e6		 jb	 SHORT $L55555
$L55557:
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi

; 187  :             }
; 188  :         }
; 189  :     }
; 190  : 
; 191  :     m_cBytesPerVertex = oCur;

  000c8	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000cb	5b		 pop	 ebx

; 192  : }

  000cc	5d		 pop	 ebp
  000cd	c2 04 00	 ret	 4
??0DXCrackFVF@@QAE@K@Z ENDP				; DXCrackFVF::DXCrackFVF
_TEXT	ENDS
PUBLIC	?GetArrayElem@DXCrackFVF@@QAEPAEPAXK@Z		; DXCrackFVF::GetArrayElem
; Function compile flags: /Ogs
;	COMDAT ?GetArrayElem@DXCrackFVF@@QAEPAEPAXK@Z
_TEXT	SEGMENT
_pvPoints$ = 8						; size = 4
_iElem$ = 12						; size = 4
?GetArrayElem@DXCrackFVF@@QAEPAEPAXK@Z PROC NEAR	; DXCrackFVF::GetArrayElem, COMDAT
; _this$ = ecx

; 202  : }

  00000	8b ff		 npad	 2

; 200  : { 

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 201  :     return ((PBYTE)pvPoints + (iElem * m_cBytesPerVertex)); 

  00005	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00008	0f af 45 0c	 imul	 eax, DWORD PTR _iElem$[ebp]
  0000c	03 45 08	 add	 eax, DWORD PTR _pvPoints$[ebp]

; 202  : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?GetArrayElem@DXCrackFVF@@QAEPAEPAXK@Z ENDP		; DXCrackFVF::GetArrayElem
_TEXT	ENDS
PUBLIC	?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetPosition
; Function compile flags: /Ogs
;	COMDAT ?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_pvPos$ = 12						; size = 4
?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z PROC NEAR ; DXCrackFVF::SetPosition, COMDAT
; _this$ = ecx

; 211  : }

  00000	8b ff		 npad	 2

; 209  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 210  :     memcpy(pvPoint, pvPos, sizeof(D3DXVECTOR3));

  00006	8b 75 0c	 mov	 esi, DWORD PTR _pvPos$[ebp]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _pvPoint$[ebp]
  0000d	a5		 movsd
  0000e	a5		 movsd
  0000f	a5		 movsd
  00010	5f		 pop	 edi
  00011	5e		 pop	 esi

; 211  : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ENDP	; DXCrackFVF::SetPosition
_TEXT	ENDS
PUBLIC	?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord
; Function compile flags: /Ogs
;	COMDAT ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_iTexCoord$ = 12					; size = 4
_pvTexCoord$ = 16					; size = 4
?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z PROC NEAR ; DXCrackFVF::SetTexCoord, COMDAT
; _this$ = ecx

; 296  :     }
; 297  : }

  00000	8b ff		 npad	 2

; 292  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 293  :     if (iTexCoord < m_cTexCoords)

  00005	8b 45 0c	 mov	 eax, DWORD PTR _iTexCoord$[ebp]
  00008	3b 41 3c	 cmp	 eax, DWORD PTR [ecx+60]
  0000b	73 11		 jae	 SHORT $L55625
  0000d	56		 push	 esi

; 294  :     {
; 295  :         memcpy(((PBYTE)pvPoint) + m_oTex[iTexCoord], pvTexCoord, sizeof(D3DXVECTOR3));

  0000e	8b 75 10	 mov	 esi, DWORD PTR _pvTexCoord$[ebp]
  00011	57		 push	 edi
  00012	8b 7c 81 18	 mov	 edi, DWORD PTR [ecx+eax*4+24]
  00016	03 7d 08	 add	 edi, DWORD PTR _pvPoint$[ebp]
  00019	a5		 movsd
  0001a	a5		 movsd
  0001b	a5		 movsd
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
$L55625:

; 296  :     }
; 297  : }

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ENDP ; DXCrackFVF::SetTexCoord
_TEXT	ENDS
PUBLIC	?PxyzwGetTexCoord@DXCrackFVF@@QAEPAUD3DXVECTOR4@@PAXI@Z ; DXCrackFVF::PxyzwGetTexCoord
; Function compile flags: /Ogs
;	COMDAT ?PxyzwGetTexCoord@DXCrackFVF@@QAEPAUD3DXVECTOR4@@PAXI@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_index$ = 12						; size = 4
?PxyzwGetTexCoord@DXCrackFVF@@QAEPAUD3DXVECTOR4@@PAXI@Z PROC NEAR ; DXCrackFVF::PxyzwGetTexCoord, COMDAT
; _this$ = ecx

; 446  : }

  00000	8b ff		 npad	 2

; 444  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 445  :     return (D3DXVECTOR4*) (((PBYTE)pvPoint) + m_oTex[index]);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  00008	8b 44 81 18	 mov	 eax, DWORD PTR [ecx+eax*4+24]
  0000c	03 45 08	 add	 eax, DWORD PTR _pvPoint$[ebp]

; 446  : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?PxyzwGetTexCoord@DXCrackFVF@@QAEPAUD3DXVECTOR4@@PAXI@Z ENDP ; DXCrackFVF::PxyzwGetTexCoord
_TEXT	ENDS
PUBLIC	?PfGetWeights@DXCrackFVF@@QAEPAMPAX@Z		; DXCrackFVF::PfGetWeights
; Function compile flags: /Ogs
;	COMDAT ?PfGetWeights@DXCrackFVF@@QAEPAMPAX@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
?PfGetWeights@DXCrackFVF@@QAEPAMPAX@Z PROC NEAR		; DXCrackFVF::PfGetWeights, COMDAT
; _this$ = ecx

; 455  : }

  00000	8b ff		 npad	 2

; 453  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 454  :     return (float*)(((PBYTE)pvPoint) + sizeof(D3DXVECTOR3));

  00005	8b 45 08	 mov	 eax, DWORD PTR _pvPoint$[ebp]
  00008	83 c0 0c	 add	 eax, 12			; 0000000cH

; 455  : }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?PfGetWeights@DXCrackFVF@@QAEPAMPAX@Z ENDP		; DXCrackFVF::PfGetWeights
_TEXT	ENDS
PUBLIC	?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ	; CD3DXCrackDecl1::BIndexedWeights
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\crackdecl.h
;	COMDAT ?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ
_TEXT	SEGMENT
?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ PROC NEAR	; CD3DXCrackDecl1::BIndexedWeights, COMDAT
; _this$ = ecx

; 184  :     BOOL BIndexedWeights()                           { return pIndexElement != NULL; }

  00000	33 c0		 xor	 eax, eax
  00002	39 81 90 00 00
	00		 cmp	 DWORD PTR [ecx+144], eax
  00008	0f 95 c0	 setne	 al
  0000b	c3		 ret	 0
?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ ENDP		; CD3DXCrackDecl1::BIndexedWeights
_TEXT	ENDS
PUBLIC	?CWeights@CD3DXCrackDecl1@@QAEHXZ		; CD3DXCrackDecl1::CWeights
; Function compile flags: /Ogs
;	COMDAT ?CWeights@CD3DXCrackDecl1@@QAEHXZ
_TEXT	SEGMENT
?CWeights@CD3DXCrackDecl1@@QAEHXZ PROC NEAR		; CD3DXCrackDecl1::CWeights, COMDAT
; _this$ = ecx

; 190  :     BOOL CWeights()                                  { return pWeightElement == NULL ? 0 : (pWeightElement->Type - D3DDECLTYPE_FLOAT1) + 1; }

  00000	8b 81 8c 00 00
	00		 mov	 eax, DWORD PTR [ecx+140]
  00006	85 c0		 test	 eax, eax
  00008	75 01		 jne	 SHORT $L56844
  0000a	c3		 ret	 0
$L56844:
  0000b	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0000f	40		 inc	 eax
  00010	c3		 ret	 0
?CWeights@CD3DXCrackDecl1@@QAEHXZ ENDP			; CD3DXCrackDecl1::CWeights
_TEXT	ENDS
PUBLIC	?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z ; CD3DXCrackDecl1::PvGetPosition
; Function compile flags: /Ogs
;	COMDAT ?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z PROC NEAR ; CD3DXCrackDecl1::PvGetPosition, COMDAT
; _this$ = ecx

; 192  :     LPD3DXVECTOR3 PvGetPosition(PBYTE pvPoint)       { return (LPD3DXVECTOR3)(pvPoint + pPositionElement->Offset); }

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 81 88 00 00
	00		 mov	 eax, DWORD PTR [ecx+136]
  0000b	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  0000f	03 45 08	 add	 eax, DWORD PTR _pvPoint$[ebp]
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z ENDP ; CD3DXCrackDecl1::PvGetPosition
_TEXT	ENDS
PUBLIC	?PfGetWeights@CD3DXCrackDecl1@@QAEPAMPAE@Z	; CD3DXCrackDecl1::PfGetWeights
; Function compile flags: /Ogs
;	COMDAT ?PfGetWeights@CD3DXCrackDecl1@@QAEPAMPAE@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
?PfGetWeights@CD3DXCrackDecl1@@QAEPAMPAE@Z PROC NEAR	; CD3DXCrackDecl1::PfGetWeights, COMDAT
; _this$ = ecx

; 194  :     FLOAT *PfGetWeights(PBYTE pvPoint)               { return (FLOAT*)(pvPoint + pWeightElement->Offset); }

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 81 8c 00 00
	00		 mov	 eax, DWORD PTR [ecx+140]
  0000b	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  0000f	03 45 08	 add	 eax, DWORD PTR _pvPoint$[ebp]
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?PfGetWeights@CD3DXCrackDecl1@@QAEPAMPAE@Z ENDP		; CD3DXCrackDecl1::PfGetWeights
_TEXT	ENDS
PUBLIC	?GetArrayElem@CD3DXCrackDecl1@@QAEPAEPAEI@Z	; CD3DXCrackDecl1::GetArrayElem
; Function compile flags: /Ogs
;	COMDAT ?GetArrayElem@CD3DXCrackDecl1@@QAEPAEPAEI@Z
_TEXT	SEGMENT
_pvPoints$ = 8						; size = 4
_iVertex$ = 12						; size = 4
?GetArrayElem@CD3DXCrackDecl1@@QAEPAEPAEI@Z PROC NEAR	; CD3DXCrackDecl1::GetArrayElem, COMDAT
; _this$ = ecx

; 223  :     PBYTE GetArrayElem(PBYTE pvPoints, UINT iVertex) { return pvPoints + m_cBytesPerVertex * iVertex; }

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 81 c0 00 00
	00		 mov	 eax, DWORD PTR [ecx+192]
  0000b	0f af 45 0c	 imul	 eax, DWORD PTR _iVertex$[ebp]
  0000f	03 45 08	 add	 eax, DWORD PTR _pvPoints$[ebp]
  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?GetArrayElem@CD3DXCrackDecl1@@QAEPAEPAEI@Z ENDP	; CD3DXCrackDecl1::GetArrayElem
_TEXT	ENDS
PUBLIC	??0CD3DXCrackDecl1@@QAE@XZ			; CD3DXCrackDecl1::CD3DXCrackDecl1
EXTRN	??0CD3DXCrackDecl@@QAE@XZ:NEAR			; CD3DXCrackDecl::CD3DXCrackDecl
; Function compile flags: /Ogs
;	COMDAT ??0CD3DXCrackDecl1@@QAE@XZ
_TEXT	SEGMENT
??0CD3DXCrackDecl1@@QAE@XZ PROC NEAR			; CD3DXCrackDecl1::CD3DXCrackDecl1, COMDAT
; _this$ = ecx

; 254  :         }

  00000	8b ff		 npad	 2
  00002	56		 push	 esi
  00003	57		 push	 edi

; 252  :         {

  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??0CD3DXCrackDecl@@QAE@XZ ; CD3DXCrackDecl::CD3DXCrackDecl
  0000b	33 c0		 xor	 eax, eax

; 253  :         memset(rgpTextureElements, 0, sizeof(LPD3DVERTEXELEMENT9) * 8);

  0000d	6a 08		 push	 8
  0000f	59		 pop	 ecx
  00010	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00016	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax
  0001c	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  00022	89 86 94 00 00
	00		 mov	 DWORD PTR [esi+148], eax
  00028	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax
  0002e	89 86 9c 00 00
	00		 mov	 DWORD PTR [esi+156], eax
  00034	8d be a0 00 00
	00		 lea	 edi, DWORD PTR [esi+160]
  0003a	f3 ab		 rep stosd
  0003c	5f		 pop	 edi

; 254  :         }

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	c3		 ret	 0
??0CD3DXCrackDecl1@@QAE@XZ ENDP				; CD3DXCrackDecl1::CD3DXCrackDecl1
_TEXT	ENDS
PUBLIC	?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z ; CD3DXCrackDecl1::SetDeclaration
EXTRN	_D3DXGetDeclVertexSize@8:NEAR
EXTRN	?SetDeclaration@CD3DXCrackDecl@@QAEJPBU_D3DVERTEXELEMENT9@@@Z:NEAR ; CD3DXCrackDecl::SetDeclaration
; Function compile flags: /Ogs
;	COMDAT ?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z
_TEXT	SEGMENT
_pElementsNew$ = 8					; size = 4
?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z PROC NEAR ; CD3DXCrackDecl1::SetDeclaration, COMDAT
; _this$ = ecx

; 355  :     }

  00000	8b ff		 npad	 2

; 270  :     {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 271  :         CONST D3DVERTEXELEMENT9 *pPlace;
; 272  : 
; 273  :         CD3DXCrackDecl::SetDeclaration(pElementsNew);

  00006	ff 75 08	 push	 DWORD PTR _pElementsNew$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?SetDeclaration@CD3DXCrackDecl@@QAEJPBU_D3DVERTEXELEMENT9@@@Z ; CD3DXCrackDecl::SetDeclaration

; 274  : 
; 275  : #ifdef DEBUG
; 276  :         // this class only works for single stream data types
; 277  :         pPlace = pElementsNew;
; 278  :         while(pPlace->Stream != 0xFF)
; 279  :         {
; 280  :             GXASSERT(pPlace->Stream == 0);
; 281  :             pPlace++;
; 282  :         }
; 283  : #endif
; 284  :         // should be pointing into local copy of declaration
; 285  :         pPlace = pElements;

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	e9 c9 00 00 00	 jmp	 $L56855
$L56019:

; 288  :         {
; 289  :             if (pPlace->UsageIndex == 0 || pPlace->Usage == D3DDECLUSAGE_TEXCOORD || 
; 290  :                 pPlace->Usage == D3DDECLUSAGE_COLOR )

  00017	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0001a	84 d2		 test	 dl, dl
  0001c	74 11		 je	 SHORT $L56022
  0001e	8a 48 06	 mov	 cl, BYTE PTR [eax+6]
  00021	80 f9 05	 cmp	 cl, 5
  00024	74 09		 je	 SHORT $L56022
  00026	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  00029	0f 85 ae 00 00
	00		 jne	 $L56028
$L56022:

; 291  :             {
; 292  :                 switch (pPlace->Usage)

  0002f	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00033	83 e9 00	 sub	 ecx, 0
  00036	0f 84 95 00 00
	00		 je	 $L56027
  0003c	49		 dec	 ecx
  0003d	0f 84 80 00 00
	00		 je	 $L56029
  00043	49		 dec	 ecx
  00044	74 68		 je	 SHORT $L56031
  00046	49		 dec	 ecx
  00047	74 57		 je	 SHORT $L56034
  00049	49		 dec	 ecx
  0004a	49		 dec	 ecx
  0004b	74 3c		 je	 SHORT $L56044
  0004d	83 e9 05	 sub	 ecx, 5
  00050	0f 85 87 00 00
	00		 jne	 $L56028

; 321  : 
; 322  :                 case D3DDECLUSAGE_COLOR:
; 323  :                     if (pPlace->UsageIndex == 0)

  00056	84 d2		 test	 dl, dl
  00058	75 15		 jne	 SHORT $L56037

; 324  :                     {
; 325  :                         if ((pPlace->Type == D3DDECLTYPE_FLOAT4) || (pPlace->Type == D3DDECLTYPE_D3DCOLOR))

  0005a	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  0005d	80 f9 03	 cmp	 cl, 3
  00060	74 05		 je	 SHORT $L56039
  00062	80 f9 04	 cmp	 cl, 4
  00065	75 76		 jne	 SHORT $L56028
$L56039:

; 326  :                         {
; 327  :                             pDiffuseElement = pPlace;

  00067	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax

; 328  :                         }
; 329  :                     }
; 330  :                     else

  0006d	eb 6e		 jmp	 SHORT $L56028
$L56037:

; 331  :                     if (pPlace->UsageIndex == 1)

  0006f	80 fa 01	 cmp	 dl, 1
  00072	75 69		 jne	 SHORT $L56028

; 332  :                     {
; 333  :                         if ((pPlace->Type == D3DDECLTYPE_FLOAT4) || (pPlace->Type == D3DDECLTYPE_D3DCOLOR))

  00074	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  00077	80 f9 03	 cmp	 cl, 3
  0007a	74 05		 je	 SHORT $L56043
  0007c	80 f9 04	 cmp	 cl, 4
  0007f	75 5c		 jne	 SHORT $L56028
$L56043:

; 334  :                         {
; 335  :                             pSpecularElement = pPlace;

  00081	89 86 9c 00 00
	00		 mov	 DWORD PTR [esi+156], eax

; 336  :                         }
; 337  :                     }
; 338  :                     break;

  00087	eb 54		 jmp	 SHORT $L56028
$L56044:

; 339  : 
; 340  :                 case D3DDECLUSAGE_TEXCOORD:
; 341  :                     if ((pPlace->Type >= D3DDECLTYPE_FLOAT1) && (pPlace->Type <= D3DDECLTYPE_FLOAT4) && (pPlace->UsageIndex < 8))

  00089	80 78 04 03	 cmp	 BYTE PTR [eax+4], 3
  0008d	77 4e		 ja	 SHORT $L56028
  0008f	80 fa 08	 cmp	 dl, 8
  00092	73 49		 jae	 SHORT $L56028

; 342  :                     {
; 343  :                         rgpTextureElements[pPlace->UsageIndex] = pPlace;

  00094	0f b6 ca	 movzx	 ecx, dl
  00097	89 84 8e a0 00
	00 00		 mov	 DWORD PTR [esi+ecx*4+160], eax

; 344  :                     }
; 345  :                     break;

  0009e	eb 3d		 jmp	 SHORT $L56028
$L56034:

; 314  : 
; 315  :                 case D3DDECLUSAGE_NORMAL:
; 316  :                     if (pPlace->Type == D3DDECLTYPE_FLOAT3)

  000a0	80 78 04 02	 cmp	 BYTE PTR [eax+4], 2
  000a4	75 37		 jne	 SHORT $L56028

; 317  :                     {
; 318  :                         pNormalElement = pPlace;

  000a6	89 86 94 00 00
	00		 mov	 DWORD PTR [esi+148], eax

; 319  :                     }
; 320  :                     break;

  000ac	eb 2f		 jmp	 SHORT $L56028
$L56031:

; 307  : 
; 308  :                 case D3DDECLUSAGE_BLENDINDICES:
; 309  :                     if ((pPlace->Type == D3DDECLTYPE_UBYTE4) || (pPlace->Type == D3DDECLTYPE_D3DCOLOR))

  000ae	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  000b1	80 f9 05	 cmp	 cl, 5
  000b4	74 05		 je	 SHORT $L56033
  000b6	80 f9 04	 cmp	 cl, 4
  000b9	75 22		 jne	 SHORT $L56028
$L56033:

; 310  :                     {
; 311  :                         pIndexElement = pPlace;

  000bb	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax

; 312  :                     }
; 313  :                     break;

  000c1	eb 1a		 jmp	 SHORT $L56028
$L56029:

; 298  :                     }
; 299  :                     break;
; 300  : 
; 301  :                 case D3DDECLUSAGE_BLENDWEIGHT:
; 302  :                     if ((pPlace->Type >= D3DDECLTYPE_FLOAT1) && (pPlace->Type <= D3DDECLTYPE_FLOAT4))

  000c3	80 78 04 03	 cmp	 BYTE PTR [eax+4], 3
  000c7	77 14		 ja	 SHORT $L56028

; 303  :                     {
; 304  :                         pWeightElement = pPlace;

  000c9	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax

; 305  :                     }
; 306  :                     break;

  000cf	eb 0c		 jmp	 SHORT $L56028
$L56027:

; 293  :                 {
; 294  :                 case D3DDECLUSAGE_POSITION:
; 295  :                     if (pPlace->Type == D3DDECLTYPE_FLOAT3)

  000d1	80 78 04 02	 cmp	 BYTE PTR [eax+4], 2
  000d5	75 06		 jne	 SHORT $L56028

; 296  :                     {
; 297  :                         pPositionElement = pPlace;

  000d7	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
$L56028:

; 346  :                 }
; 347  :             }
; 348  : 
; 349  :             pPlace++;

  000dd	83 c0 08	 add	 eax, 8
$L56855:

; 286  : 
; 287  :         while(pPlace->Stream != 0xFF)

  000e0	66 81 38 ff 00	 cmp	 WORD PTR [eax], 255	; 000000ffH
  000e5	0f 85 2c ff ff
	ff		 jne	 $L56019

; 350  :         }
; 351  : 
; 352  :         m_cBytesPerVertex = D3DXGetDeclVertexSize(pElements,0);

  000eb	6a 00		 push	 0
  000ed	ff 36		 push	 DWORD PTR [esi]
  000ef	e8 00 00 00 00	 call	 _D3DXGetDeclVertexSize@8
  000f4	89 86 c0 00 00
	00		 mov	 DWORD PTR [esi+192], eax

; 353  : 
; 354  :         return S_OK;

  000fa	33 c0		 xor	 eax, eax
  000fc	5e		 pop	 esi

; 355  :     }

  000fd	5d		 pop	 ebp
  000fe	c2 04 00	 ret	 4
?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z ENDP ; CD3DXCrackDecl1::SetDeclaration
_TEXT	ENDS
PUBLIC	??0CStripOutline@@QAE@XZ			; CStripOutline::CStripOutline
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\stripoutline.cpp
;	COMDAT ??0CStripOutline@@QAE@XZ
_TEXT	SEGMENT
??0CStripOutline@@QAE@XZ PROC NEAR			; CStripOutline::CStripOutline, COMDAT
; _this$ = ecx

; 56   : }

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 55   : {

  00003	6a 02		 push	 2
  00005	8b f1		 mov	 esi, ecx
  00007	e8 00 00 00 00	 call	 ??0DXCrackFVF@@QAE@K@Z	; DXCrackFVF::DXCrackFVF
  0000c	33 c0		 xor	 eax, eax
  0000e	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00011	89 46 44	 mov	 DWORD PTR [esi+68], eax
  00014	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00017	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  0001a	89 46 50	 mov	 DWORD PTR [esi+80], eax
  0001d	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00020	89 46 58	 mov	 DWORD PTR [esi+88], eax
  00023	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00026	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 56   : }

  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	c3		 ret	 0
??0CStripOutline@@QAE@XZ ENDP				; CStripOutline::CStripOutline
_TEXT	ENDS
PUBLIC	__real@3eaaaaab
PUBLIC	?AppendPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIPAE2AAI@Z ; CStripOutline::AppendPoint
;	COMDAT __real@3eaaaaab
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\gxcrackfvf.h
CONST	SEGMENT
__real@3eaaaaab DD 03eaaaaabr			; 0.333333
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\stripoutline.cpp
CONST	ENDS
;	COMDAT ?AppendPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIPAE2AAI@Z
_TEXT	SEGMENT
_vTemp$ = -12						; size = 12
_cdMesh$ = 8						; size = 4
_pwFace$ = 12						; size = 4
_pvMeshPoints$ = 16					; size = 4
_pvLinePoints$ = 20					; size = 4
_iCurPoint$ = 24					; size = 4
?AppendPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIPAE2AAI@Z PROC NEAR ; CStripOutline::AppendPoint, COMDAT
; _this$ = ecx

; 117  : }

  00000	8b ff		 npad	 2

; 99   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 100  :     D3DXVECTOR3 vTemp(0,0,0);
; 101  :     UINT iPoint;
; 102  :     PVOID pvPoint;
; 103  : 
; 104  :     for (iPoint = 0; iPoint < 3; iPoint++)

  00008	8b 45 08	 mov	 eax, DWORD PTR _cdMesh$[ebp]
  0000b	d9 ee		 fldz
  0000d	56		 push	 esi
  0000e	d9 ee		 fldz
  00010	8b b0 c0 00 00
	00		 mov	 esi, DWORD PTR [eax+192]
  00016	d9 5d f8	 fstp	 DWORD PTR _vTemp$[ebp+4]

; 105  :     {
; 106  :         pvPoint = cdMesh.GetArrayElem((PBYTE)pvMeshPoints, pwFace[iPoint]);
; 107  :         vTemp += *cdMesh.PvGetPosition((PBYTE)pvPoint);
; 108  :     }
; 109  : 
; 110  :     vTemp /= 3.0f;
; 111  : 
; 112  :     pvPoint = m_cfvf.GetArrayElem(pvLinePoints, iCurPoint);
; 113  : 
; 114  :     m_cfvf.SetPosition(pvPoint, (D3DXVECTOR3*)&vTemp);
; 115  : 
; 116  :     iCurPoint += 1;

  00019	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [eax+136]
  0001f	d9 ee		 fldz
  00021	57		 push	 edi
  00022	0f b7 78 02	 movzx	 edi, WORD PTR [eax+2]
  00026	33 d2		 xor	 edx, edx
$L56341:
  00028	8b 45 0c	 mov	 eax, DWORD PTR _pwFace$[ebp]
  0002b	d9 c1		 fld	 ST(1)
  0002d	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00030	0f af c6	 imul	 eax, esi
  00033	03 c7		 add	 eax, edi
  00035	03 45 10	 add	 eax, DWORD PTR _pvMeshPoints$[ebp]
  00038	42		 inc	 edx
  00039	83 fa 03	 cmp	 edx, 3
  0003c	d8 00		 fadd	 DWORD PTR [eax]
  0003e	dd da		 fstp	 ST(2)
  00040	d9 45 f8	 fld	 DWORD PTR _vTemp$[ebp+4]
  00043	d8 40 04	 fadd	 DWORD PTR [eax+4]
  00046	d9 5d f8	 fstp	 DWORD PTR _vTemp$[ebp+4]
  00049	d9 c0		 fld	 ST(0)
  0004b	d8 40 08	 fadd	 DWORD PTR [eax+8]
  0004e	dd d9		 fstp	 ST(1)
  00050	72 d6		 jb	 SHORT $L56341
  00052	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3eaaaaab
  00058	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  0005b	8b 45 18	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  0005e	d9 c2		 fld	 ST(2)
  00060	0f af 38	 imul	 edi, DWORD PTR [eax]
  00063	d8 c9		 fmul	 ST(0), ST(1)
  00065	d9 5d f4	 fstp	 DWORD PTR _vTemp$[ebp]
  00068	d9 45 f8	 fld	 DWORD PTR _vTemp$[ebp+4]
  0006b	d8 c9		 fmul	 ST(0), ST(1)
  0006d	03 7d 14	 add	 edi, DWORD PTR _pvLinePoints$[ebp]
  00070	d9 5d f8	 fstp	 DWORD PTR _vTemp$[ebp+4]
  00073	d9 c1		 fld	 ST(1)
  00075	8d 75 f4	 lea	 esi, DWORD PTR _vTemp$[ebp]
  00078	d8 c9		 fmul	 ST(0), ST(1)
  0007a	d9 5d fc	 fstp	 DWORD PTR _vTemp$[ebp+8]
  0007d	a5		 movsd
  0007e	a5		 movsd
  0007f	dd d8		 fstp	 ST(0)
  00081	dd d8		 fstp	 ST(0)
  00083	dd d8		 fstp	 ST(0)
  00085	a5		 movsd
  00086	ff 00		 inc	 DWORD PTR [eax]
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi

; 117  : }

  0008a	c9		 leave
  0008b	c2 14 00	 ret	 20			; 00000014H
?AppendPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIPAE2AAI@Z ENDP ; CStripOutline::AppendPoint
_TEXT	ENDS
PUBLIC	__real@3f000000
PUBLIC	?AppendMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z ; CStripOutline::AppendMidpoint
;	COMDAT __real@3f000000
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\gxcrackfvf.h
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\stripoutline.cpp
CONST	ENDS
;	COMDAT ?AppendMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z
_TEXT	SEGMENT
_vTemp$ = -12						; size = 12
_cdMesh$ = 8						; size = 4
_pwFace1$ = 12						; size = 4
_pwFace2$ = 16						; size = 4
_pvMeshPoints$ = 20					; size = 4
_pvLinePoints$ = 24					; size = 4
_iCurPoint$ = 28					; size = 4
?AppendMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z PROC NEAR ; CStripOutline::AppendMidpoint, COMDAT
; _this$ = ecx

; 158  : }

  00000	8b ff		 npad	 2

; 129  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	53		 push	 ebx

; 130  :     D3DXVECTOR3 vTemp(0,0,0);

  00009	d9 ee		 fldz
  0000b	56		 push	 esi
  0000c	d9 ee		 fldz

; 131  :     UINT iPoint1;
; 132  :     UINT iPoint2;
; 133  :     PVOID pvPoint;
; 134  : 
; 135  :     GXASSERT(BConnected(pwFace1, pwFace2));
; 136  : 
; 137  :     for (iPoint1 = 0; iPoint1 < 3; iPoint1++)

  0000e	8b 75 08	 mov	 esi, DWORD PTR _cdMesh$[ebp]
  00011	d9 5d f8	 fstp	 DWORD PTR _vTemp$[ebp+4]
  00014	57		 push	 edi
  00015	d9 ee		 fldz
  00017	33 ff		 xor	 edi, edi
$L56917:

; 138  :     {
; 139  :         for (iPoint2 = 0; iPoint2 < 3; iPoint2++)
; 140  :         {
; 141  :             if (pwFace1[iPoint1] == pwFace2[iPoint2])

  00019	8b 45 0c	 mov	 eax, DWORD PTR _pwFace1$[ebp]
  0001c	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  0001f	33 d2		 xor	 edx, edx
$L56364:
  00021	8b 5d 10	 mov	 ebx, DWORD PTR _pwFace2$[ebp]
  00024	3b 04 93	 cmp	 eax, DWORD PTR [ebx+edx*4]
  00027	74 08		 je	 SHORT $L56912
  00029	42		 inc	 edx
  0002a	83 fa 03	 cmp	 edx, 3
  0002d	72 f2		 jb	 SHORT $L56364
  0002f	eb 2e		 jmp	 SHORT $L56362
$L56912:

; 142  :             {
; 143  :                 pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[iPoint1]);

  00031	8b 96 c0 00 00
	00		 mov	 edx, DWORD PTR [esi+192]

; 144  :                 vTemp += *cdMesh.PvGetPosition((PBYTE)pvPoint);

  00037	d9 c1		 fld	 ST(1)
  00039	0f af d0	 imul	 edx, eax
  0003c	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  00042	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]

; 145  : 
; 146  :                 break;
; 147  :             }
; 148  :         }
; 149  :     }
; 150  : 
; 151  :     vTemp /= 2.0f;
; 152  : 
; 153  :     pvPoint = m_cfvf.GetArrayElem(pvLinePoints, iCurPoint);
; 154  : 
; 155  :     m_cfvf.SetPosition(pvPoint, (D3DXVECTOR3*)&vTemp);
; 156  : 
; 157  :     iCurPoint += 1;

  00046	03 55 14	 add	 edx, DWORD PTR _pvMeshPoints$[ebp]
  00049	03 c2		 add	 eax, edx
  0004b	d8 00		 fadd	 DWORD PTR [eax]
  0004d	dd da		 fstp	 ST(2)
  0004f	d9 45 f8	 fld	 DWORD PTR _vTemp$[ebp+4]
  00052	d8 40 04	 fadd	 DWORD PTR [eax+4]
  00055	d9 5d f8	 fstp	 DWORD PTR _vTemp$[ebp+4]
  00058	d9 c0		 fld	 ST(0)
  0005a	d8 40 08	 fadd	 DWORD PTR [eax+8]
  0005d	dd d9		 fstp	 ST(1)
$L56362:
  0005f	47		 inc	 edi
  00060	83 ff 03	 cmp	 edi, 3
  00063	72 b4		 jb	 SHORT $L56917
  00065	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000
  0006b	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  0006e	8b 45 1c	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  00071	d9 c2		 fld	 ST(2)
  00073	0f af 38	 imul	 edi, DWORD PTR [eax]
  00076	d8 c9		 fmul	 ST(0), ST(1)
  00078	d9 5d f4	 fstp	 DWORD PTR _vTemp$[ebp]
  0007b	d9 45 f8	 fld	 DWORD PTR _vTemp$[ebp+4]
  0007e	d8 c9		 fmul	 ST(0), ST(1)
  00080	03 7d 18	 add	 edi, DWORD PTR _pvLinePoints$[ebp]
  00083	d9 5d f8	 fstp	 DWORD PTR _vTemp$[ebp+4]
  00086	d9 c1		 fld	 ST(1)
  00088	8d 75 f4	 lea	 esi, DWORD PTR _vTemp$[ebp]
  0008b	d8 c9		 fmul	 ST(0), ST(1)
  0008d	d9 5d fc	 fstp	 DWORD PTR _vTemp$[ebp+8]
  00090	a5		 movsd
  00091	a5		 movsd
  00092	dd d8		 fstp	 ST(0)
  00094	dd d8		 fstp	 ST(0)
  00096	dd d8		 fstp	 ST(0)
  00098	a5		 movsd
  00099	ff 00		 inc	 DWORD PTR [eax]
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx

; 158  : }

  0009e	c9		 leave
  0009f	c2 18 00	 ret	 24			; 00000018H
?AppendMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z ENDP ; CStripOutline::AppendMidpoint
_TEXT	ENDS
PUBLIC	?AppendSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z ; CStripOutline::AppendSkinnedPoint
EXTRN	?CopyWeights@@YAXPAMK0K@Z:NEAR			; CopyWeights
; Function compile flags: /Ogs
;	COMDAT ?AppendSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z
_TEXT	SEGMENT
_vAvg$ = -16						; size = 12
_this$ = -4						; size = 4
_cdMesh$ = 8						; size = 4
_pwFace1$ = 12						; size = 4
_iEdge$ = 16						; size = 4
_pvMeshPoints$ = 20					; size = 4
_pvDestPoint$ = 24					; size = 4
_pvLinePoints$ = 24					; size = 4
_iCurPoint$ = 28					; size = 4
?AppendSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z PROC NEAR ; CStripOutline::AppendSkinnedPoint, COMDAT
; _this$ = ecx

; 249  : }

  00000	8b ff		 npad	 2

; 210  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 211  :     PBYTE pvDestPoint;
; 212  :     PBYTE pvPoint;
; 213  :     D3DXVECTOR3 vAvg(1.0f/3.0f,1.0f/3.0f,1.0f/3.0f);
; 214  : 
; 215  :     pvDestPoint = m_cfvf.GetArrayElem(pvLinePoints, iCurPoint);

  00008	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3eaaaaab
  00011	8b 45 1c	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  00014	d9 55 f0	 fst	 DWORD PTR _vAvg$[ebp]
  00017	0f af 10	 imul	 edx, DWORD PTR [eax]
  0001a	d9 55 f4	 fst	 DWORD PTR _vAvg$[ebp+4]
  0001d	d9 5d f8	 fstp	 DWORD PTR _vAvg$[ebp+8]

; 216  : 
; 217  :     // Point 0 - first point on edge shared with another triangle
; 218  :     pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[iEdge]);

  00020	8b 45 0c	 mov	 eax, DWORD PTR _pwFace1$[ebp]
  00023	03 55 18	 add	 edx, DWORD PTR _pvLinePoints$[ebp]
  00026	53		 push	 ebx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR _cdMesh$[ebp]
  0002a	56		 push	 esi
  0002b	8b 75 10	 mov	 esi, DWORD PTR _iEdge$[ebp]
  0002e	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00031	0f af 83 c0 00
	00 00		 imul	 eax, DWORD PTR [ebx+192]

; 219  : 
; 220  :     // first position goes in standard position spot
; 221  :     m_cfvf.SetPosition(pvDestPoint, cdMesh.PvGetPosition(pvPoint));

  00038	8b b3 88 00 00
	00		 mov	 esi, DWORD PTR [ebx+136]
  0003e	0f b7 76 02	 movzx	 esi, WORD PTR [esi+2]
  00042	03 45 14	 add	 eax, DWORD PTR _pvMeshPoints$[ebp]
  00045	57		 push	 edi
  00046	03 f0		 add	 esi, eax
  00048	8b fa		 mov	 edi, edx
  0004a	a5		 movsd
  0004b	a5		 movsd
  0004c	a5		 movsd

; 222  : 
; 223  :     // first set of weights go in standard spot - expand to standard length
; 224  :     CopyWeights(cdMesh.PfGetWeights(pvPoint), cdMesh.CWeights(), m_cfvf.PfGetWeights(pvDestPoint), m_cfvf.CWeights());

  0004d	8b 71 38	 mov	 esi, DWORD PTR [ecx+56]
  00050	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00053	8b 8b 8c 00 00
	00		 mov	 ecx, DWORD PTR [ebx+140]
  00059	85 c9		 test	 ecx, ecx
  0005b	89 55 18	 mov	 DWORD PTR _pvDestPoint$[ebp], edx
  0005e	75 04		 jne	 SHORT $L56946
  00060	33 ff		 xor	 edi, edi
  00062	eb 05		 jmp	 SHORT $L56947
$L56946:
  00064	0f b6 79 04	 movzx	 edi, BYTE PTR [ecx+4]
  00068	47		 inc	 edi
$L56947:
  00069	0f b7 49 02	 movzx	 ecx, WORD PTR [ecx+2]
  0006d	56		 push	 esi
  0006e	83 c2 0c	 add	 edx, 12			; 0000000cH
  00071	52		 push	 edx
  00072	03 c8		 add	 ecx, eax
  00074	57		 push	 edi
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?CopyWeights@@YAXPAMK0K@Z ; CopyWeights

; 225  : 
; 226  :     // Point 1 - other point on edge shared with another triangle
; 227  :     pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[(iEdge+1)%3]);

  0007b	8b 45 10	 mov	 eax, DWORD PTR _iEdge$[ebp]
  0007e	83 c4 10	 add	 esp, 16			; 00000010H
  00081	6a 03		 push	 3
  00083	40		 inc	 eax
  00084	59		 pop	 ecx
  00085	33 d2		 xor	 edx, edx
  00087	f7 f1		 div	 ecx
  00089	8b 45 0c	 mov	 eax, DWORD PTR _pwFace1$[ebp]

; 228  : 
; 229  :     // second position goes in first texture coord
; 230  :     m_cfvf.SetTexCoord(pvDestPoint, 0, cdMesh.PvGetPosition(pvPoint));

  0008c	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  0008f	8b cf		 mov	 ecx, edi
  00091	8b 34 90	 mov	 esi, DWORD PTR [eax+edx*4]
  00094	0f af b3 c0 00
	00 00		 imul	 esi, DWORD PTR [ebx+192]
  0009b	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [ebx+136]
  000a1	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  000a5	03 75 14	 add	 esi, DWORD PTR _pvMeshPoints$[ebp]
  000a8	03 c6		 add	 eax, esi
  000aa	50		 push	 eax
  000ab	6a 00		 push	 0
  000ad	ff 75 18	 push	 DWORD PTR _pvDestPoint$[ebp]
  000b0	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord

; 231  : 
; 232  :     // second set of weights go in second texture coord- expand to standard length
; 233  :     CopyWeights(cdMesh.PfGetWeights(pvPoint), cdMesh.CWeights(), (float*)m_cfvf.PxyzwGetTexCoord(pvDestPoint, 1), m_cfvf.CWeights());

  000b5	8b 83 8c 00 00
	00		 mov	 eax, DWORD PTR [ebx+140]
  000bb	85 c0		 test	 eax, eax
  000bd	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  000c0	75 04		 jne	 SHORT $L56969
  000c2	33 d2		 xor	 edx, edx
  000c4	eb 05		 jmp	 SHORT $L56970
$L56969:
  000c6	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  000ca	42		 inc	 edx
$L56970:
  000cb	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  000cf	51		 push	 ecx
  000d0	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  000d3	03 4d 18	 add	 ecx, DWORD PTR _pvDestPoint$[ebp]
  000d6	03 c6		 add	 eax, esi
  000d8	51		 push	 ecx
  000d9	52		 push	 edx
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 ?CopyWeights@@YAXPAMK0K@Z ; CopyWeights

; 234  : 
; 235  :     // Point 2 - point NOT on edge shared with another triangle
; 236  :     pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[(iEdge+2)%3]);

  000e0	8b 45 10	 mov	 eax, DWORD PTR _iEdge$[ebp]
  000e3	83 c4 10	 add	 esp, 16			; 00000010H
  000e6	6a 03		 push	 3
  000e8	83 c0 02	 add	 eax, 2
  000eb	59		 pop	 ecx
  000ec	33 d2		 xor	 edx, edx
  000ee	f7 f1		 div	 ecx
  000f0	8b 45 0c	 mov	 eax, DWORD PTR _pwFace1$[ebp]

; 237  : 
; 238  :     // third position goes in the third texture coordinate
; 239  :     m_cfvf.SetTexCoord(pvDestPoint, 2, cdMesh.PvGetPosition(pvPoint));

  000f3	8b cf		 mov	 ecx, edi
  000f5	8b 34 90	 mov	 esi, DWORD PTR [eax+edx*4]
  000f8	0f af b3 c0 00
	00 00		 imul	 esi, DWORD PTR [ebx+192]
  000ff	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [ebx+136]
  00105	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  00109	03 75 14	 add	 esi, DWORD PTR _pvMeshPoints$[ebp]
  0010c	03 c6		 add	 eax, esi
  0010e	50		 push	 eax
  0010f	6a 02		 push	 2
  00111	ff 75 18	 push	 DWORD PTR _pvDestPoint$[ebp]
  00114	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord

; 240  : 
; 241  :     // third set of weights go in fourth texture coord- expand to standard length
; 242  :     CopyWeights(cdMesh.PfGetWeights(pvPoint), cdMesh.CWeights(), (float*)m_cfvf.PxyzwGetTexCoord(pvDestPoint, 3), m_cfvf.CWeights());

  00119	8b 9b 8c 00 00
	00		 mov	 ebx, DWORD PTR [ebx+140]
  0011f	85 db		 test	 ebx, ebx
  00121	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00124	75 04		 jne	 SHORT $L56993
  00126	33 c9		 xor	 ecx, ecx
  00128	eb 05		 jmp	 SHORT $L56994
$L56993:
  0012a	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  0012e	41		 inc	 ecx
$L56994:
  0012f	50		 push	 eax
  00130	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00133	03 45 18	 add	 eax, DWORD PTR _pvDestPoint$[ebp]
  00136	50		 push	 eax
  00137	0f b7 43 02	 movzx	 eax, WORD PTR [ebx+2]
  0013b	51		 push	 ecx
  0013c	03 c6		 add	 eax, esi
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 ?CopyWeights@@YAXPAMK0K@Z ; CopyWeights
  00144	83 c4 10	 add	 esp, 16			; 00000010H

; 243  : 
; 244  : 
; 245  :     // the third position should be added in
; 246  :     m_cfvf.SetTexCoord(pvDestPoint, 4, &vAvg);

  00147	8d 45 f0	 lea	 eax, DWORD PTR _vAvg$[ebp]
  0014a	50		 push	 eax
  0014b	6a 04		 push	 4
  0014d	ff 75 18	 push	 DWORD PTR _pvDestPoint$[ebp]
  00150	8b cf		 mov	 ecx, edi
  00152	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord

; 247  : 
; 248  :     iCurPoint += 1;

  00157	8b 45 1c	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  0015a	ff 00		 inc	 DWORD PTR [eax]
  0015c	5f		 pop	 edi
  0015d	5e		 pop	 esi
  0015e	5b		 pop	 ebx

; 249  : }

  0015f	c9		 leave
  00160	c2 18 00	 ret	 24			; 00000018H
?AppendSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z ENDP ; CStripOutline::AppendSkinnedPoint
_TEXT	ENDS
PUBLIC	?AppendIndexSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z ; CStripOutline::AppendIndexSkinnedPoint
EXTRN	?CopyIndexedWeights@@YAXPAMK0K@Z:NEAR		; CopyIndexedWeights
; Function compile flags: /Ogs
;	COMDAT ?AppendIndexSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z
_TEXT	SEGMENT
_vAvg$ = -16						; size = 12
_this$ = -4						; size = 4
_cdMesh$ = 8						; size = 4
_pwFace1$ = 12						; size = 4
_iEdge$ = 16						; size = 4
_pvMeshPoints$ = 20					; size = 4
_pvDestPoint$ = 24					; size = 4
_pvLinePoints$ = 24					; size = 4
_iCurPoint$ = 28					; size = 4
?AppendIndexSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z PROC NEAR ; CStripOutline::AppendIndexSkinnedPoint, COMDAT
; _this$ = ecx

; 340  : }

  00000	8b ff		 npad	 2

; 301  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 302  :     PBYTE pvDestPoint;
; 303  :     PBYTE pvPoint;
; 304  :     D3DXVECTOR3 vAvg(1.0f/3.0f,1.0f/3.0f,1.0f/3.0f);
; 305  : 
; 306  :     pvDestPoint = m_cfvf.GetArrayElem(pvLinePoints, iCurPoint);

  00008	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3eaaaaab
  00011	8b 45 1c	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  00014	d9 55 f0	 fst	 DWORD PTR _vAvg$[ebp]
  00017	0f af 10	 imul	 edx, DWORD PTR [eax]
  0001a	d9 55 f4	 fst	 DWORD PTR _vAvg$[ebp+4]
  0001d	d9 5d f8	 fstp	 DWORD PTR _vAvg$[ebp+8]

; 307  : 
; 308  :     // Point 0 - first point on edge shared with another triangle
; 309  :     pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[iEdge]);

  00020	8b 45 0c	 mov	 eax, DWORD PTR _pwFace1$[ebp]
  00023	03 55 18	 add	 edx, DWORD PTR _pvLinePoints$[ebp]
  00026	53		 push	 ebx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR _cdMesh$[ebp]
  0002a	56		 push	 esi
  0002b	8b 75 10	 mov	 esi, DWORD PTR _iEdge$[ebp]
  0002e	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00031	0f af 83 c0 00
	00 00		 imul	 eax, DWORD PTR [ebx+192]

; 310  : 
; 311  :     // first position goes in standard position spot
; 312  :     m_cfvf.SetPosition(pvDestPoint, cdMesh.PvGetPosition(pvPoint));

  00038	8b b3 88 00 00
	00		 mov	 esi, DWORD PTR [ebx+136]
  0003e	0f b7 76 02	 movzx	 esi, WORD PTR [esi+2]
  00042	03 45 14	 add	 eax, DWORD PTR _pvMeshPoints$[ebp]
  00045	57		 push	 edi
  00046	03 f0		 add	 esi, eax
  00048	8b fa		 mov	 edi, edx
  0004a	a5		 movsd
  0004b	a5		 movsd
  0004c	a5		 movsd

; 313  : 
; 314  :     // first set of weights go in standard spot - expand to standard length
; 315  :     CopyIndexedWeights(cdMesh.PfGetWeights(pvPoint), cdMesh.CWeights() + 1, m_cfvf.PfGetWeights(pvDestPoint), m_cfvf.CWeights());

  0004d	8b 79 38	 mov	 edi, DWORD PTR [ecx+56]
  00050	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00053	8b 8b 8c 00 00
	00		 mov	 ecx, DWORD PTR [ebx+140]
  00059	85 c9		 test	 ecx, ecx
  0005b	89 55 18	 mov	 DWORD PTR _pvDestPoint$[ebp], edx
  0005e	75 04		 jne	 SHORT $L57027
  00060	33 f6		 xor	 esi, esi
  00062	eb 05		 jmp	 SHORT $L57028
$L57027:
  00064	0f b6 71 04	 movzx	 esi, BYTE PTR [ecx+4]
  00068	46		 inc	 esi
$L57028:
  00069	0f b7 49 02	 movzx	 ecx, WORD PTR [ecx+2]
  0006d	57		 push	 edi
  0006e	83 c2 0c	 add	 edx, 12			; 0000000cH
  00071	52		 push	 edx
  00072	46		 inc	 esi
  00073	03 c8		 add	 ecx, eax
  00075	56		 push	 esi
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 ?CopyIndexedWeights@@YAXPAMK0K@Z ; CopyIndexedWeights

; 316  : 
; 317  :     // Point 1 - other point on edge shared with another triangle
; 318  :     pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[(iEdge+1)%3]);

  0007c	8b 45 10	 mov	 eax, DWORD PTR _iEdge$[ebp]
  0007f	83 c4 10	 add	 esp, 16			; 00000010H
  00082	6a 03		 push	 3
  00084	40		 inc	 eax
  00085	59		 pop	 ecx
  00086	33 d2		 xor	 edx, edx
  00088	f7 f1		 div	 ecx
  0008a	8b 45 0c	 mov	 eax, DWORD PTR _pwFace1$[ebp]

; 319  : 
; 320  :     // second position goes in first texture coord
; 321  :     m_cfvf.SetTexCoord(pvDestPoint, 0, cdMesh.PvGetPosition(pvPoint));

  0008d	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  00090	8b cf		 mov	 ecx, edi
  00092	8b 34 90	 mov	 esi, DWORD PTR [eax+edx*4]
  00095	0f af b3 c0 00
	00 00		 imul	 esi, DWORD PTR [ebx+192]
  0009c	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [ebx+136]
  000a2	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  000a6	03 75 14	 add	 esi, DWORD PTR _pvMeshPoints$[ebp]
  000a9	03 c6		 add	 eax, esi
  000ab	50		 push	 eax
  000ac	6a 00		 push	 0
  000ae	ff 75 18	 push	 DWORD PTR _pvDestPoint$[ebp]
  000b1	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord

; 322  : 
; 323  :     // second set of weights go in second texture coord- expand to standard length
; 324  :     CopyIndexedWeights(cdMesh.PfGetWeights(pvPoint), cdMesh.CWeights() + 1, (float*)m_cfvf.PxyzwGetTexCoord(pvDestPoint, 1), m_cfvf.CWeights());

  000b6	8b 83 8c 00 00
	00		 mov	 eax, DWORD PTR [ebx+140]
  000bc	85 c0		 test	 eax, eax
  000be	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  000c1	75 04		 jne	 SHORT $L57050
  000c3	33 c9		 xor	 ecx, ecx
  000c5	eb 05		 jmp	 SHORT $L57051
$L57050:
  000c7	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000cb	41		 inc	 ecx
$L57051:
  000cc	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  000d0	52		 push	 edx
  000d1	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  000d4	03 55 18	 add	 edx, DWORD PTR _pvDestPoint$[ebp]
  000d7	41		 inc	 ecx
  000d8	52		 push	 edx
  000d9	51		 push	 ecx
  000da	03 c6		 add	 eax, esi
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 ?CopyIndexedWeights@@YAXPAMK0K@Z ; CopyIndexedWeights

; 325  : 
; 326  :     // Point 2 - point NOT on edge shared with another triangle
; 327  :     pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[(iEdge+2)%3]);

  000e2	8b 45 10	 mov	 eax, DWORD PTR _iEdge$[ebp]
  000e5	83 c4 10	 add	 esp, 16			; 00000010H
  000e8	6a 03		 push	 3
  000ea	83 c0 02	 add	 eax, 2
  000ed	59		 pop	 ecx
  000ee	33 d2		 xor	 edx, edx
  000f0	f7 f1		 div	 ecx
  000f2	8b 45 0c	 mov	 eax, DWORD PTR _pwFace1$[ebp]
  000f5	8b 34 90	 mov	 esi, DWORD PTR [eax+edx*4]
  000f8	0f af b3 c0 00
	00 00		 imul	 esi, DWORD PTR [ebx+192]

; 328  : 
; 329  :     // third position goes in the third texture coordinate
; 330  :     m_cfvf.SetTexCoord(pvDestPoint, 3, cdMesh.PvGetPosition(pvPoint));

  000ff	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [ebx+136]
  00105	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  00109	03 75 14	 add	 esi, DWORD PTR _pvMeshPoints$[ebp]
  0010c	03 c6		 add	 eax, esi
  0010e	50		 push	 eax
  0010f	51		 push	 ecx
  00110	ff 75 18	 push	 DWORD PTR _pvDestPoint$[ebp]
  00113	8b cf		 mov	 ecx, edi
  00115	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord

; 331  : 
; 332  :     // third set of weights go in fourth texture coord- expand to standard length
; 333  :     CopyIndexedWeights(cdMesh.PfGetWeights(pvPoint), cdMesh.CWeights() + 1, (float*)m_cfvf.PxyzwGetTexCoord(pvDestPoint, 4), m_cfvf.CWeights());

  0011a	8b 9b 8c 00 00
	00		 mov	 ebx, DWORD PTR [ebx+140]
  00120	85 db		 test	 ebx, ebx
  00122	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00125	75 04		 jne	 SHORT $L57073
  00127	33 c9		 xor	 ecx, ecx
  00129	eb 05		 jmp	 SHORT $L57074
$L57073:
  0012b	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  0012f	41		 inc	 ecx
$L57074:
  00130	50		 push	 eax
  00131	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00134	03 45 18	 add	 eax, DWORD PTR _pvDestPoint$[ebp]
  00137	41		 inc	 ecx
  00138	50		 push	 eax
  00139	0f b7 43 02	 movzx	 eax, WORD PTR [ebx+2]
  0013d	51		 push	 ecx
  0013e	03 c6		 add	 eax, esi
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 ?CopyIndexedWeights@@YAXPAMK0K@Z ; CopyIndexedWeights
  00146	83 c4 10	 add	 esp, 16			; 00000010H

; 334  : 
; 335  : 
; 336  :     // the third position should be added in
; 337  :     m_cfvf.SetTexCoord(pvDestPoint, 6, &vAvg);

  00149	8d 45 f0	 lea	 eax, DWORD PTR _vAvg$[ebp]
  0014c	50		 push	 eax
  0014d	6a 06		 push	 6
  0014f	ff 75 18	 push	 DWORD PTR _pvDestPoint$[ebp]
  00152	8b cf		 mov	 ecx, edi
  00154	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord

; 338  : 
; 339  :     iCurPoint += 1;

  00159	8b 45 1c	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  0015c	ff 00		 inc	 DWORD PTR [eax]
  0015e	5f		 pop	 edi
  0015f	5e		 pop	 esi
  00160	5b		 pop	 ebx

; 340  : }

  00161	c9		 leave
  00162	c2 18 00	 ret	 24			; 00000018H
?AppendIndexSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z ENDP ; CStripOutline::AppendIndexSkinnedPoint
_TEXT	ENDS
PUBLIC	??_C@_04BEMIBDAE@mTot?$AA@			; `string'
PUBLIC	??_C@_07HHMNENJH@mWorlds?$AA@			; `string'
PUBLIC	??_C@_04JKCKMDGO@vClr?$AA@			; `string'
PUBLIC	?Draw@CStripOutline@@QAEJPAUIDirect3DDevice9@@KPAUID3DXEffect@@1KPAUD3DXMATRIX@@K@Z ; CStripOutline::Draw
EXTRN	_D3DXMatrixMultiply@12:NEAR
;	COMDAT ??_C@_04BEMIBDAE@mTot?$AA@
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.inl
CONST	SEGMENT
??_C@_04BEMIBDAE@mTot?$AA@ DB 'mTot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HHMNENJH@mWorlds?$AA@
CONST	SEGMENT
??_C@_07HHMNENJH@mWorlds?$AA@ DB 'mWorlds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JKCKMDGO@vClr?$AA@
CONST	SEGMENT
??_C@_04JKCKMDGO@vClr?$AA@ DB 'vClr', 00H		; `string'
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\stripoutline.cpp
CONST	ENDS
;	COMDAT ?Draw@CStripOutline@@QAEJPAUIDirect3DDevice9@@KPAUID3DXEffect@@1KPAUD3DXMATRIX@@K@Z
_TEXT	SEGMENT
_matTot$ = -280						; size = 64
_matProj$ = -216					; size = 64
_matView$ = -152					; size = 64
_matWorld$ = -88					; size = 64
_vClr$ = -24						; size = 16
_dwSoftwareMode$ = -8					; size = 4
_bChangedSWMode$ = -4					; size = 4
_cPasses$ = 8						; size = 4
_pDevice$ = 8						; size = 4
_iAttrib$ = 12						; size = 4
_pfxCurrent$ = 16					; size = 4
_pfxSkinnedAdjacency$ = 16				; size = 4
tv532 = 20						; size = 4
_pfxColor$ = 20						; size = 4
tv648 = 24						; size = 4
tv647 = 24						; size = 4
tv646 = 24						; size = 4
tv645 = 24						; size = 4
tv472 = 24						; size = 4
_iVertexStart$56716 = 24				; size = 4
_iMatrix$ = 24						; size = 4
_dwColor$ = 24						; size = 4
tv681 = 28						; size = 4
_cLinesCur$ = 28					; size = 4
_rgmIndexedMatrices$ = 28				; size = 4
_iPass$ = 32						; size = 4
_cIndexedMatrices$ = 32					; size = 4
?Draw@CStripOutline@@QAEJPAUIDirect3DDevice9@@KPAUID3DXEffect@@1KPAUD3DXMATRIX@@K@Z PROC NEAR ; CStripOutline::Draw, COMDAT
; _this$ = ecx

; 904  : }

  00000	8b ff		 npad	 2

; 754  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H

; 755  :     HRESULT hr;
; 756  :     LPD3DXEFFECT pfxCurrent;
; 757  :     DWORD dwFVF;
; 758  :     UINT iPass;
; 759  :     UINT cPasses;
; 760  :     DWORD cBytesPerVertex;
; 761  :     D3DXMATRIX matWorld;
; 762  :     D3DXMATRIX matView;
; 763  :     D3DXMATRIX matProj;
; 764  :     D3DXMATRIX matTot;
; 765  :     D3DXCOLOR vClr(dwColor);

  0000b	8b 45 18	 mov	 eax, DWORD PTR _dwColor$[ebp]
  0000e	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3b808081
  00014	53		 push	 ebx
  00015	8b d9		 mov	 ebx, ecx
  00017	8b c8		 mov	 ecx, eax
  00019	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0001c	0f b6 c9	 movzx	 ecx, cl
  0001f	89 4d 18	 mov	 DWORD PTR tv648[ebp], ecx
  00022	8b c8		 mov	 ecx, eax
  00024	c1 e9 08	 shr	 ecx, 8
  00027	db 45 18	 fild	 DWORD PTR tv648[ebp]
  0002a	0f b6 c9	 movzx	 ecx, cl
  0002d	d8 c9		 fmul	 ST(0), ST(1)
  0002f	89 4d 18	 mov	 DWORD PTR tv647[ebp], ecx
  00032	0f b6 c8	 movzx	 ecx, al
  00035	d9 5d e8	 fstp	 DWORD PTR _vClr$[ebp]
  00038	db 45 18	 fild	 DWORD PTR tv647[ebp]
  0003b	89 4d 18	 mov	 DWORD PTR tv646[ebp], ecx
  0003e	c1 e8 18	 shr	 eax, 24			; 00000018H
  00041	56		 push	 esi
  00042	d8 c9		 fmul	 ST(0), ST(1)

; 766  :     DWORD cLines;
; 767  :     DWORD cLinesCur;
; 768  :     DWORD iVertexStart;
; 769  : 	BOOL  dwSoftwareMode;
; 770  :     BOOL bChangedSWMode = FALSE;
; 771  :     DWORD iMatrix;
; 772  :     DWORD iSubset;
; 773  : 
; 774  :     if (m_bSkinning)

  00044	8b 75 08	 mov	 esi, DWORD PTR _pDevice$[ebp]
  00047	57		 push	 edi
  00048	d9 5d ec	 fstp	 DWORD PTR _vClr$[ebp+4]
  0004b	db 45 18	 fild	 DWORD PTR tv646[ebp]
  0004e	89 45 18	 mov	 DWORD PTR tv645[ebp], eax
  00051	33 c0		 xor	 eax, eax
  00053	39 43 40	 cmp	 DWORD PTR [ebx+64], eax
  00056	d8 c9		 fmul	 ST(0), ST(1)
  00058	89 45 fc	 mov	 DWORD PTR _bChangedSWMode$[ebp], eax
  0005b	d9 5d f0	 fstp	 DWORD PTR _vClr$[ebp+8]
  0005e	db 45 18	 fild	 DWORD PTR tv645[ebp]
  00061	d8 c9		 fmul	 ST(0), ST(1)
  00063	d9 5d f4	 fstp	 DWORD PTR _vClr$[ebp+12]
  00066	dd d8		 fstp	 ST(0)
  00068	0f 84 1a 02 00
	00		 je	 $L56689

; 775  :     {
; 776  :         if (!m_bIndexSkinning)
; 777  :         {
; 778  :             // non-indexed skinning setup
; 779  :             pfxCurrent = pfxSkinnedAdjacency;

  0006e	8b 7d 10	 mov	 edi, DWORD PTR _pfxSkinnedAdjacency$[ebp]
  00071	39 43 44	 cmp	 DWORD PTR [ebx+68], eax

; 780  :             pfxSkinnedAdjacency->SetTechnique(pfxSkinnedAdjacency->GetTechnique(0));

  00074	8b 07		 mov	 eax, DWORD PTR [edi]
  00076	89 7d 10	 mov	 DWORD PTR _pfxCurrent$[ebp], edi
  00079	89 45 18	 mov	 DWORD PTR tv472[ebp], eax
  0007c	0f 85 0b 01 00
	00		 jne	 $L56690
  00082	6a 00		 push	 0
  00084	57		 push	 edi
  00085	ff 50 30	 call	 DWORD PTR [eax+48]
  00088	50		 push	 eax
  00089	8b 45 18	 mov	 eax, DWORD PTR tv472[ebp]
  0008c	57		 push	 edi
  0008d	ff 90 f0 00 00
	00		 call	 DWORD PTR [eax+240]

; 781  : 
; 782  :             pDevice->GetTransform(D3DTS_VIEW,&matView);

  00093	8b 06		 mov	 eax, DWORD PTR [esi]
  00095	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _matView$[ebp]
  0009b	51		 push	 ecx
  0009c	6a 02		 push	 2
  0009e	56		 push	 esi
  0009f	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 783  :             pDevice->GetTransform(D3DTS_PROJECTION,&matProj);

  000a5	8b 06		 mov	 eax, DWORD PTR [esi]
  000a7	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _matProj$[ebp]
  000ad	51		 push	 ecx
  000ae	6a 03		 push	 3
  000b0	56		 push	 esi
  000b1	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 784  :             pDevice->GetTransform(D3DTS_WORLD,&matWorld);

  000b7	8b 06		 mov	 eax, DWORD PTR [esi]
  000b9	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  000bc	51		 push	 ecx
  000bd	68 00 01 00 00	 push	 256			; 00000100H
  000c2	56		 push	 esi
  000c3	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 785  : 
; 786  :             D3DXMatrixMultiply(&matTot,&matView,&matProj);

  000c9	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _matProj$[ebp]
  000cf	50		 push	 eax
  000d0	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _matView$[ebp]
  000d6	50		 push	 eax
  000d7	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _matTot$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 787  :             pfxSkinnedAdjacency->SetMatrix("mTot", &matTot);                       

  000e3	8b 07		 mov	 eax, DWORD PTR [edi]
  000e5	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _matTot$[ebp]
  000eb	51		 push	 ecx
  000ec	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04BEMIBDAE@mTot?$AA@
  000f1	57		 push	 edi
  000f2	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 788  : 
; 789  :             pDevice->GetTransform(D3DTS_WORLD,&matWorld);

  000f8	8b 06		 mov	 eax, DWORD PTR [esi]
  000fa	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  000fd	51		 push	 ecx
  000fe	68 00 01 00 00	 push	 256			; 00000100H
  00103	56		 push	 esi
  00104	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 790  :             pfxSkinnedAdjacency->SetMatrix("mWd1", &matWorld);                       

  0010a	8b 07		 mov	 eax, DWORD PTR [edi]
  0010c	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  0010f	51		 push	 ecx
  00110	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04IHCGOIEL@mWd1?$AA@
  00115	57		 push	 edi
  00116	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 791  : 
; 792  :             pDevice->GetTransform(D3DTS_WORLD1,&matWorld);

  0011c	8b 06		 mov	 eax, DWORD PTR [esi]
  0011e	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  00121	51		 push	 ecx
  00122	68 01 01 00 00	 push	 257			; 00000101H
  00127	56		 push	 esi
  00128	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 793  :             pfxSkinnedAdjacency->SetMatrix("mWd2", &matWorld);                       

  0012e	8b 07		 mov	 eax, DWORD PTR [edi]
  00130	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  00133	51		 push	 ecx
  00134	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04KMALLLII@mWd2?$AA@
  00139	57		 push	 edi
  0013a	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 794  : 
; 795  :             pDevice->GetTransform(D3DTS_WORLD2,&matWorld);

  00140	8b 06		 mov	 eax, DWORD PTR [esi]
  00142	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  00145	51		 push	 ecx
  00146	68 02 01 00 00	 push	 258			; 00000102H
  0014b	56		 push	 esi
  0014c	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 796  :             pfxSkinnedAdjacency->SetMatrix("mWd3", &matWorld);                       

  00152	8b 07		 mov	 eax, DWORD PTR [edi]
  00154	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  00157	51		 push	 ecx
  00158	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04LFBAIKMJ@mWd3?$AA@
  0015d	57		 push	 edi
  0015e	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 797  : 
; 798  :             pDevice->GetTransform(D3DTS_WORLD3,&matWorld);

  00164	8b 06		 mov	 eax, DWORD PTR [esi]
  00166	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  00169	51		 push	 ecx
  0016a	68 03 01 00 00	 push	 259			; 00000103H
  0016f	56		 push	 esi
  00170	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 799  :             pfxSkinnedAdjacency->SetMatrix("mWd4", &matWorld);        

  00176	8b 07		 mov	 eax, DWORD PTR [edi]
  00178	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  0017b	51		 push	 ecx
  0017c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PKFBBMAO@mWd4?$AA@
  00181	57		 push	 edi
  00182	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 800  :         }        
; 801  :         else  // indexed skinning setup

  00188	e9 ad 00 00 00	 jmp	 $L56701
$L56690:

; 802  :         {
; 803  :             pfxCurrent = pfxSkinnedAdjacency;
; 804  :             pfxSkinnedAdjacency->SetTechnique(pfxSkinnedAdjacency->GetTechnique(1));

  0018d	6a 01		 push	 1
  0018f	57		 push	 edi
  00190	ff 50 30	 call	 DWORD PTR [eax+48]
  00193	50		 push	 eax
  00194	8b 45 18	 mov	 eax, DWORD PTR tv472[ebp]
  00197	57		 push	 edi
  00198	ff 90 f0 00 00
	00		 call	 DWORD PTR [eax+240]

; 805  : 
; 806  :             pDevice->GetTransform(D3DTS_VIEW,&matView);

  0019e	8b 06		 mov	 eax, DWORD PTR [esi]
  001a0	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _matView$[ebp]
  001a6	51		 push	 ecx
  001a7	6a 02		 push	 2
  001a9	56		 push	 esi
  001aa	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 807  :             pDevice->GetTransform(D3DTS_PROJECTION,&matProj);

  001b0	8b 06		 mov	 eax, DWORD PTR [esi]
  001b2	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _matProj$[ebp]
  001b8	51		 push	 ecx
  001b9	6a 03		 push	 3
  001bb	56		 push	 esi
  001bc	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 808  : 
; 809  :             D3DXMatrixMultiply(&matTot,&matView,&matProj);

  001c2	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _matProj$[ebp]
  001c8	50		 push	 eax
  001c9	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _matView$[ebp]
  001cf	50		 push	 eax
  001d0	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _matTot$[ebp]
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 810  :             pfxSkinnedAdjacency->SetMatrix("mTot", &matTot);                       

  001dc	8b 07		 mov	 eax, DWORD PTR [edi]
  001de	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _matTot$[ebp]
  001e4	51		 push	 ecx
  001e5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04BEMIBDAE@mTot?$AA@
  001ea	57		 push	 edi
  001eb	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 811  : 
; 812  :             pfxSkinnedAdjacency->SetMatrixArray("mWorlds", rgmIndexedMatrices, cIndexedMatrices);

  001f1	ff 75 20	 push	 DWORD PTR _cIndexedMatrices$[ebp]
  001f4	8b 07		 mov	 eax, DWORD PTR [edi]
  001f6	ff 75 1c	 push	 DWORD PTR _rgmIndexedMatrices$[ebp]
  001f9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07HHMNENJH@mWorlds?$AA@
  001fe	57		 push	 edi
  001ff	ff 90 a0 00 00
	00		 call	 DWORD PTR [eax+160]

; 813  : 
; 814  :             for (iMatrix = 0; iMatrix < cIndexedMatrices; iMatrix++)

  00205	83 65 18 00	 and	 DWORD PTR _iMatrix$[ebp], 0
  00209	83 7d 20 00	 cmp	 DWORD PTR _cIndexedMatrices$[ebp], 0
  0020d	76 2b		 jbe	 SHORT $L56701
  0020f	8b 45 1c	 mov	 eax, DWORD PTR _rgmIndexedMatrices$[ebp]
  00212	89 45 1c	 mov	 DWORD PTR tv681[ebp], eax
$L57107:

; 815  :             {
; 816  :                 pfxSkinnedAdjacency->SetMatrix(x_rgszMatrix[iMatrix], &rgmIndexedMatrices[iMatrix]);

  00215	ff 75 1c	 push	 DWORD PTR tv681[ebp]
  00218	8b 4d 18	 mov	 ecx, DWORD PTR _iMatrix$[ebp]
  0021b	ff 34 8d 00 00
	00 00		 push	 DWORD PTR _x_rgszMatrix[ecx*4]
  00222	8b 07		 mov	 eax, DWORD PTR [edi]
  00224	57		 push	 edi
  00225	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]
  0022b	ff 45 18	 inc	 DWORD PTR _iMatrix$[ebp]
  0022e	8b 45 18	 mov	 eax, DWORD PTR _iMatrix$[ebp]
  00231	83 45 1c 40	 add	 DWORD PTR tv681[ebp], 64 ; 00000040H
  00235	3b 45 20	 cmp	 eax, DWORD PTR _cIndexedMatrices$[ebp]
  00238	72 db		 jb	 SHORT $L57107
$L56701:

; 817  :             }
; 818  :         }
; 819  : 
; 820  :         pfxSkinnedAdjacency->SetVector("vClr", (D3DXVECTOR4*)&vClr);                       

  0023a	8b 07		 mov	 eax, DWORD PTR [edi]
  0023c	8d 4d e8	 lea	 ecx, DWORD PTR _vClr$[ebp]
  0023f	51		 push	 ecx
  00240	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JKCKMDGO@vClr?$AA@
  00245	57		 push	 edi
  00246	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 821  : 
; 822  :         dwSoftwareMode = pDevice->GetSoftwareVertexProcessing();

  0024c	8b 06		 mov	 eax, DWORD PTR [esi]
  0024e	56		 push	 esi
  0024f	ff 90 38 01 00
	00		 call	 DWORD PTR [eax+312]

; 823  :         if (!m_bHWVertexShaders)

  00255	83 7b 48 00	 cmp	 DWORD PTR [ebx+72], 0
  00259	89 45 f8	 mov	 DWORD PTR _dwSoftwareMode$[ebp], eax
  0025c	75 12		 jne	 SHORT $L56704

; 824  :         {
; 825  :             bChangedSWMode = TRUE;
; 826  :             pDevice->SetSoftwareVertexProcessing(TRUE);

  0025e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00260	33 c0		 xor	 eax, eax
  00262	40		 inc	 eax
  00263	50		 push	 eax
  00264	56		 push	 esi
  00265	89 45 fc	 mov	 DWORD PTR _bChangedSWMode$[ebp], eax
  00268	ff 91 34 01 00
	00		 call	 DWORD PTR [ecx+308]

; 827  :         }
; 828  :         // if in the wrong mode, then switch
; 829  :         else if (dwSoftwareMode && m_bHWVertexShaders)

  0026e	eb 30		 jmp	 SHORT $L57108
$L56704:
  00270	85 c0		 test	 eax, eax
  00272	74 2c		 je	 SHORT $L57108

; 830  :         {
; 831  :             bChangedSWMode = TRUE;
; 832  :             pDevice->SetSoftwareVertexProcessing(FALSE);

  00274	8b 06		 mov	 eax, DWORD PTR [esi]
  00276	6a 00		 push	 0
  00278	56		 push	 esi
  00279	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bChangedSWMode$[ebp], 1
  00280	ff 90 34 01 00
	00		 call	 DWORD PTR [eax+308]

; 833  :         }
; 834  :     }
; 835  :     else

  00286	eb 18		 jmp	 SHORT $L57108
$L56689:

; 836  :     {
; 837  :         pfxCurrent = pfxColor;

  00288	8b 45 14	 mov	 eax, DWORD PTR _pfxColor$[ebp]

; 838  : 
; 839  :         pfxCurrent->SetVector("vClr", (D3DXVECTOR4*)&vClr);                       

  0028b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0028d	8d 55 e8	 lea	 edx, DWORD PTR _vClr$[ebp]
  00290	52		 push	 edx
  00291	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JKCKMDGO@vClr?$AA@
  00296	50		 push	 eax
  00297	89 45 10	 mov	 DWORD PTR _pfxCurrent$[ebp], eax
  0029a	ff 91 88 00 00
	00		 call	 DWORD PTR [ecx+136]
$L57108:

; 840  :     }
; 841  : 
; 842  : 
; 843  :     if ((iAttrib < m_caeAttributeTable) && (m_rgaeAttributeTable[iAttrib].AttribId == iAttrib))

  002a0	8b 7b 58	 mov	 edi, DWORD PTR [ebx+88]
  002a3	8b 4d 0c	 mov	 ecx, DWORD PTR _iAttrib$[ebp]
  002a6	3b cf		 cmp	 ecx, edi
  002a8	73 0f		 jae	 SHORT $L56709
  002aa	8b 53 54	 mov	 edx, DWORD PTR [ebx+84]
  002ad	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  002b0	39 0c 82	 cmp	 DWORD PTR [edx+eax*4], ecx
  002b3	75 04		 jne	 SHORT $L56709

; 844  :     {
; 845  :         iSubset = iAttrib;

  002b5	8b c1		 mov	 eax, ecx

; 846  :     }
; 847  :     else

  002b7	eb 15		 jmp	 SHORT $L57113
$L56709:

; 848  :     {
; 849  :         // look for the correct attribute table entry to draw
; 850  :         for (iSubset = 0; iSubset < m_caeAttributeTable; iSubset++)

  002b9	33 c0		 xor	 eax, eax
  002bb	85 ff		 test	 edi, edi
  002bd	76 0f		 jbe	 SHORT $L57113
  002bf	8b 53 54	 mov	 edx, DWORD PTR [ebx+84]
$L57112:

; 851  :         {
; 852  :             if (m_rgaeAttributeTable[iSubset].AttribId == iAttrib)

  002c2	39 0a		 cmp	 DWORD PTR [edx], ecx
  002c4	74 08		 je	 SHORT $L57113
  002c6	40		 inc	 eax
  002c7	83 c2 14	 add	 edx, 20			; 00000014H
  002ca	3b c7		 cmp	 eax, edi
  002cc	72 f4		 jb	 SHORT $L57112
$L57113:

; 853  :             {
; 854  :                 break;
; 855  :             }
; 856  :         }
; 857  :     }
; 858  : 
; 859  :     if (iSubset < m_caeAttributeTable)

  002ce	3b c7		 cmp	 eax, edi
  002d0	0f 83 d4 00 00
	00		 jae	 $L57111

; 860  :     {
; 861  :         DWORD iVertexStart;
; 862  :         if (m_rgaeAttributeTable[iSubset].FaceCount > 0)

  002d6	8d 3c 80	 lea	 edi, DWORD PTR [eax+eax*4]
  002d9	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  002dc	c1 e7 02	 shl	 edi, 2
  002df	83 7c 07 08 00	 cmp	 DWORD PTR [edi+eax+8], 0
  002e4	89 7d 14	 mov	 DWORD PTR tv532[ebp], edi
  002e7	0f 86 bd 00 00
	00		 jbe	 $L57111

; 863  :         {
; 864  :             pfxCurrent->Begin(&cPasses, 0);

  002ed	8b 45 10	 mov	 eax, DWORD PTR _pfxCurrent$[ebp]
  002f0	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f2	6a 00		 push	 0
  002f4	8d 55 08	 lea	 edx, DWORD PTR _cPasses$[ebp]
  002f7	52		 push	 edx
  002f8	50		 push	 eax
  002f9	ff 91 04 01 00
	00		 call	 DWORD PTR [ecx+260]

; 865  : 
; 866  :             for (iPass = 0; iPass < cPasses; iPass++)

  002ff	83 65 20 00	 and	 DWORD PTR _iPass$[ebp], 0
  00303	83 7d 08 00	 cmp	 DWORD PTR _cPasses$[ebp], 0
  00307	0f 86 91 00 00
	00		 jbe	 $L56720
  0030d	eb 03		 jmp	 SHORT $L56718
$L57109:
  0030f	8b 7d 14	 mov	 edi, DWORD PTR tv532[ebp]
$L56718:

; 867  :             {
; 868  :                 pDevice->SetVertexDeclaration(m_pDecl);

  00312	ff 73 50	 push	 DWORD PTR [ebx+80]
  00315	8b 06		 mov	 eax, DWORD PTR [esi]
  00317	56		 push	 esi
  00318	ff 90 5c 01 00
	00		 call	 DWORD PTR [eax+348]

; 869  : 
; 870  :                 pfxCurrent->BeginPass(iPass);

  0031e	8b 45 10	 mov	 eax, DWORD PTR _pfxCurrent$[ebp]
  00321	ff 75 20	 push	 DWORD PTR _iPass$[ebp]
  00324	8b 08		 mov	 ecx, DWORD PTR [eax]
  00326	50		 push	 eax
  00327	ff 91 08 01 00
	00		 call	 DWORD PTR [ecx+264]

; 871  : 
; 872  :                 pDevice->SetStreamSource(0, m_pVertexBuffer, 0, m_cfvf.m_cBytesPerVertex);

  0032d	ff 73 04	 push	 DWORD PTR [ebx+4]
  00330	8b 06		 mov	 eax, DWORD PTR [esi]
  00332	6a 00		 push	 0
  00334	ff 73 4c	 push	 DWORD PTR [ebx+76]
  00337	6a 00		 push	 0
  00339	56		 push	 esi
  0033a	ff 90 90 01 00
	00		 call	 DWORD PTR [eax+400]

; 873  : 
; 874  :                 iVertexStart = m_rgaeAttributeTable[iSubset].VertexStart;

  00340	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  00343	03 c7		 add	 eax, edi

; 875  :                 cLines = m_rgaeAttributeTable[iSubset].VertexCount / 2;

  00345	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  00348	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0034b	d1 ef		 shr	 edi, 1
  0034d	eb 2f		 jmp	 SHORT $L57114
$L56722:

; 878  :                 {
; 879  :                     cLinesCur = min(cLines, (0xffff / 2));

  0034f	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00354	3b f8		 cmp	 edi, eax
  00356	89 7d 1c	 mov	 DWORD PTR _cLinesCur$[ebp], edi
  00359	72 03		 jb	 SHORT $L57080
  0035b	89 45 1c	 mov	 DWORD PTR _cLinesCur$[ebp], eax
$L57080:

; 880  : 
; 881  :                     hr = pDevice->DrawPrimitive(D3DPT_LINELIST, 
; 882  :                                                  iVertexStart, 
; 883  :                                                  cLinesCur);

  0035e	ff 75 1c	 push	 DWORD PTR _cLinesCur$[ebp]
  00361	8b 06		 mov	 eax, DWORD PTR [esi]
  00363	ff 75 18	 push	 DWORD PTR _iVertexStart$56716[ebp]
  00366	6a 02		 push	 2
  00368	56		 push	 esi
  00369	ff 90 44 01 00
	00		 call	 DWORD PTR [eax+324]

; 884  :                     if (FAILED(hr))

  0036f	85 c0		 test	 eax, eax
  00371	7c 4b		 jl	 SHORT $L56670

; 885  :                         return hr;
; 886  : 
; 887  :                     iVertexStart += cLinesCur * 2;

  00373	8b 45 1c	 mov	 eax, DWORD PTR _cLinesCur$[ebp]
  00376	8b 4d 18	 mov	 ecx, DWORD PTR _iVertexStart$56716[ebp]
  00379	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]

; 888  :                     cLines -= cLinesCur;

  0037c	2b f8		 sub	 edi, eax
$L57114:

; 885  :                         return hr;
; 886  : 
; 887  :                     iVertexStart += cLinesCur * 2;

  0037e	89 4d 18	 mov	 DWORD PTR _iVertexStart$56716[ebp], ecx

; 876  : 
; 877  :                 while (cLines > 0)

  00381	75 cc		 jne	 SHORT $L56722

; 889  :                 }
; 890  : 
; 891  :                 pfxCurrent->EndPass();

  00383	8b 45 10	 mov	 eax, DWORD PTR _pfxCurrent$[ebp]
  00386	8b 08		 mov	 ecx, DWORD PTR [eax]
  00388	50		 push	 eax
  00389	ff 91 10 01 00
	00		 call	 DWORD PTR [ecx+272]
  0038f	ff 45 20	 inc	 DWORD PTR _iPass$[ebp]
  00392	8b 45 20	 mov	 eax, DWORD PTR _iPass$[ebp]
  00395	3b 45 08	 cmp	 eax, DWORD PTR _cPasses$[ebp]
  00398	0f 82 71 ff ff
	ff		 jb	 $L57109
$L56720:

; 892  :             }
; 893  : 
; 894  :             pfxCurrent->End();

  0039e	8b 45 10	 mov	 eax, DWORD PTR _pfxCurrent$[ebp]
  003a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a3	50		 push	 eax
  003a4	ff 91 14 01 00
	00		 call	 DWORD PTR [ecx+276]
$L57111:

; 895  :         }
; 896  :     }
; 897  : 
; 898  :     if (bChangedSWMode)

  003aa	83 7d fc 00	 cmp	 DWORD PTR _bChangedSWMode$[ebp], 0
  003ae	74 0c		 je	 SHORT $L56726

; 899  :     {
; 900  :         pDevice->SetSoftwareVertexProcessing(dwSoftwareMode);

  003b0	ff 75 f8	 push	 DWORD PTR _dwSoftwareMode$[ebp]
  003b3	8b 06		 mov	 eax, DWORD PTR [esi]
  003b5	56		 push	 esi
  003b6	ff 90 34 01 00
	00		 call	 DWORD PTR [eax+308]
$L56726:

; 901  :     }
; 902  : 
; 903  :     return S_OK;

  003bc	33 c0		 xor	 eax, eax
$L56670:
  003be	5f		 pop	 edi
  003bf	5e		 pop	 esi
  003c0	5b		 pop	 ebx

; 904  : }

  003c1	c9		 leave
  003c2	c2 1c 00	 ret	 28			; 0000001cH
?Draw@CStripOutline@@QAEJPAUIDirect3DDevice9@@KPAUID3DXEffect@@1KPAUD3DXMATRIX@@K@Z ENDP ; CStripOutline::Draw
_TEXT	ENDS
PUBLIC	?AppendSkinnedMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z ; CStripOutline::AppendSkinnedMidpoint
; Function compile flags: /Ogs
;	COMDAT ?AppendSkinnedMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z
_TEXT	SEGMENT
_vMidPoint$ = -20					; size = 12
_this$ = -8						; size = 4
_iEdge$ = -4						; size = 4
_cdMesh$ = 8						; size = 4
tv162 = 12						; size = 4
_pwFace1$ = 12						; size = 4
_pwFace2$ = 16						; size = 4
_pvMeshPoints$ = 20					; size = 4
_pvLinePoints$ = 24					; size = 4
_iCurPoint$ = 28					; size = 4
?AppendSkinnedMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z PROC NEAR ; CStripOutline::AppendSkinnedMidpoint, COMDAT
; _this$ = ecx

; 198  : }

  00000	8b ff		 npad	 2

; 170  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 171  :     PBYTE pvDestPoint;
; 172  :     D3DXVECTOR3 vMidPoint(0.5f, 0.5f, 0.0f);

  00008	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000

; 173  :     DWORD iPoint1;
; 174  :     DWORD iPoint2;
; 175  :     DWORD iEdge = UNUSED32;

  0000e	83 4d fc ff	 or	 DWORD PTR _iEdge$[ebp], -1
  00012	d9 55 ec	 fst	 DWORD PTR _vMidPoint$[ebp]
  00015	53		 push	 ebx
  00016	d9 5d f0	 fstp	 DWORD PTR _vMidPoint$[ebp+4]
  00019	56		 push	 esi
  0001a	d9 ee		 fldz
  0001c	57		 push	 edi

; 176  : 
; 177  :     GXASSERT(BConnected(pwFace1, pwFace2));
; 178  : 
; 179  :     // find the edge connecting the two faces
; 180  :     for (iPoint1 = 0; iPoint1 < 3; iPoint1++)

  0001d	8b 7d 0c	 mov	 edi, DWORD PTR _pwFace1$[ebp]
  00020	d9 5d f4	 fstp	 DWORD PTR _vMidPoint$[ebp+8]
  00023	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00026	33 f6		 xor	 esi, esi
$L57127:

; 181  :     {
; 182  :         for (iPoint2 = 0; iPoint2 < 3; iPoint2++)

  00028	33 c9		 xor	 ecx, ecx
$L56388:

; 183  :         {
; 184  :             if ((pwFace1[iPoint1] == pwFace2[(iPoint2+1)%3]) && (pwFace1[(iPoint1+1)%3] == pwFace2[iPoint2]))

  0002a	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0002d	6a 03		 push	 3
  0002f	33 d2		 xor	 edx, edx
  00031	5b		 pop	 ebx
  00032	89 45 0c	 mov	 DWORD PTR tv162[ebp], eax
  00035	f7 f3		 div	 ebx
  00037	8b 04 b7	 mov	 eax, DWORD PTR [edi+esi*4]
  0003a	8b 5d 10	 mov	 ebx, DWORD PTR _pwFace2$[ebp]
  0003d	3b 04 93	 cmp	 eax, DWORD PTR [ebx+edx*4]
  00040	75 15		 jne	 SHORT $L56389
  00042	33 d2		 xor	 edx, edx
  00044	6a 03		 push	 3
  00046	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00049	5b		 pop	 ebx
  0004a	f7 f3		 div	 ebx
  0004c	8b 04 97	 mov	 eax, DWORD PTR [edi+edx*4]
  0004f	8b 55 10	 mov	 edx, DWORD PTR _pwFace2$[ebp]
  00052	3b 04 8a	 cmp	 eax, DWORD PTR [edx+ecx*4]
  00055	74 0a		 je	 SHORT $L57124
$L56389:

; 181  :     {
; 182  :         for (iPoint2 = 0; iPoint2 < 3; iPoint2++)

  00057	8b 4d 0c	 mov	 ecx, DWORD PTR tv162[ebp]
  0005a	83 f9 03	 cmp	 ecx, 3
  0005d	72 cb		 jb	 SHORT $L56388

; 183  :         {
; 184  :             if ((pwFace1[iPoint1] == pwFace2[(iPoint2+1)%3]) && (pwFace1[(iPoint1+1)%3] == pwFace2[iPoint2]))

  0005f	eb 03		 jmp	 SHORT $L56386
$L57124:

; 185  :             {
; 186  :                 iEdge = iPoint1;

  00061	89 75 fc	 mov	 DWORD PTR _iEdge$[ebp], esi
$L56386:

; 176  : 
; 177  :     GXASSERT(BConnected(pwFace1, pwFace2));
; 178  : 
; 179  :     // find the edge connecting the two faces
; 180  :     for (iPoint1 = 0; iPoint1 < 3; iPoint1++)

  00064	46		 inc	 esi
  00065	83 fe 03	 cmp	 esi, 3
  00068	72 be		 jb	 SHORT $L57127

; 187  :                 break;
; 188  :             }
; 189  :         }
; 190  :     }
; 191  : 
; 192  :     pvDestPoint = m_cfvf.GetArrayElem(pvLinePoints, iCurPoint);

  0006a	8b 45 1c	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  0006d	8b 5d f8	 mov	 ebx, DWORD PTR _this$[ebp]
  00070	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00073	0f af 30	 imul	 esi, DWORD PTR [eax]
  00076	03 75 18	 add	 esi, DWORD PTR _pvLinePoints$[ebp]

; 193  : 
; 194  :     AppendSkinnedPoint(cdMesh, pwFace1, iEdge, pvMeshPoints, pvLinePoints, iCurPoint);

  00079	50		 push	 eax
  0007a	ff 75 18	 push	 DWORD PTR _pvLinePoints$[ebp]
  0007d	8b cb		 mov	 ecx, ebx
  0007f	ff 75 14	 push	 DWORD PTR _pvMeshPoints$[ebp]
  00082	ff 75 fc	 push	 DWORD PTR _iEdge$[ebp]
  00085	57		 push	 edi
  00086	ff 75 08	 push	 DWORD PTR _cdMesh$[ebp]
  00089	e8 00 00 00 00	 call	 ?AppendSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z ; CStripOutline::AppendSkinnedPoint

; 195  : 
; 196  :     // the third position should be ignored!
; 197  :     m_cfvf.SetTexCoord(pvDestPoint, 4, &vMidPoint);

  0008e	8d 45 ec	 lea	 eax, DWORD PTR _vMidPoint$[ebp]
  00091	50		 push	 eax
  00092	6a 04		 push	 4
  00094	56		 push	 esi
  00095	8b cb		 mov	 ecx, ebx
  00097	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx

; 198  : }

  0009f	c9		 leave
  000a0	c2 18 00	 ret	 24			; 00000018H
?AppendSkinnedMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z ENDP ; CStripOutline::AppendSkinnedMidpoint
_TEXT	ENDS
PUBLIC	?AppendIndexSkinnedMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z ; CStripOutline::AppendIndexSkinnedMidpoint
; Function compile flags: /Ogs
;	COMDAT ?AppendIndexSkinnedMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z
_TEXT	SEGMENT
_vMidPoint$ = -20					; size = 12
_this$ = -8						; size = 4
_iEdge$ = -4						; size = 4
_cdMesh$ = 8						; size = 4
tv162 = 12						; size = 4
_pwFace1$ = 12						; size = 4
_pwFace2$ = 16						; size = 4
_pvMeshPoints$ = 20					; size = 4
_pvLinePoints$ = 24					; size = 4
_iCurPoint$ = 28					; size = 4
?AppendIndexSkinnedMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z PROC NEAR ; CStripOutline::AppendIndexSkinnedMidpoint, COMDAT
; _this$ = ecx

; 289  : }

  00000	8b ff		 npad	 2

; 261  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 262  :     PBYTE pvDestPoint;
; 263  :     D3DXVECTOR3 vMidPoint(0.5f, 0.5f, 0.0f);

  00008	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000

; 264  :     DWORD iPoint1;
; 265  :     DWORD iPoint2;
; 266  :     DWORD iEdge = UNUSED32;

  0000e	83 4d fc ff	 or	 DWORD PTR _iEdge$[ebp], -1
  00012	d9 55 ec	 fst	 DWORD PTR _vMidPoint$[ebp]
  00015	53		 push	 ebx
  00016	d9 5d f0	 fstp	 DWORD PTR _vMidPoint$[ebp+4]
  00019	56		 push	 esi
  0001a	d9 ee		 fldz
  0001c	57		 push	 edi

; 267  : 
; 268  :     GXASSERT(BConnected(pwFace1, pwFace2));
; 269  : 
; 270  :     // find the edge connecting the two faces
; 271  :     for (iPoint1 = 0; iPoint1 < 3; iPoint1++)

  0001d	8b 7d 0c	 mov	 edi, DWORD PTR _pwFace1$[ebp]
  00020	d9 5d f4	 fstp	 DWORD PTR _vMidPoint$[ebp+8]
  00023	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00026	33 f6		 xor	 esi, esi
$L57140:

; 272  :     {
; 273  :         for (iPoint2 = 0; iPoint2 < 3; iPoint2++)

  00028	33 c9		 xor	 ecx, ecx
$L56424:

; 274  :         {
; 275  :             if ((pwFace1[iPoint1] == pwFace2[(iPoint2+1)%3]) && (pwFace1[(iPoint1+1)%3] == pwFace2[iPoint2]))

  0002a	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0002d	6a 03		 push	 3
  0002f	33 d2		 xor	 edx, edx
  00031	5b		 pop	 ebx
  00032	89 45 0c	 mov	 DWORD PTR tv162[ebp], eax
  00035	f7 f3		 div	 ebx
  00037	8b 04 b7	 mov	 eax, DWORD PTR [edi+esi*4]
  0003a	8b 5d 10	 mov	 ebx, DWORD PTR _pwFace2$[ebp]
  0003d	3b 04 93	 cmp	 eax, DWORD PTR [ebx+edx*4]
  00040	75 15		 jne	 SHORT $L56425
  00042	33 d2		 xor	 edx, edx
  00044	6a 03		 push	 3
  00046	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00049	5b		 pop	 ebx
  0004a	f7 f3		 div	 ebx
  0004c	8b 04 97	 mov	 eax, DWORD PTR [edi+edx*4]
  0004f	8b 55 10	 mov	 edx, DWORD PTR _pwFace2$[ebp]
  00052	3b 04 8a	 cmp	 eax, DWORD PTR [edx+ecx*4]
  00055	74 0a		 je	 SHORT $L57137
$L56425:

; 272  :     {
; 273  :         for (iPoint2 = 0; iPoint2 < 3; iPoint2++)

  00057	8b 4d 0c	 mov	 ecx, DWORD PTR tv162[ebp]
  0005a	83 f9 03	 cmp	 ecx, 3
  0005d	72 cb		 jb	 SHORT $L56424

; 274  :         {
; 275  :             if ((pwFace1[iPoint1] == pwFace2[(iPoint2+1)%3]) && (pwFace1[(iPoint1+1)%3] == pwFace2[iPoint2]))

  0005f	eb 03		 jmp	 SHORT $L56422
$L57137:

; 276  :             {
; 277  :                 iEdge = iPoint1;

  00061	89 75 fc	 mov	 DWORD PTR _iEdge$[ebp], esi
$L56422:

; 267  : 
; 268  :     GXASSERT(BConnected(pwFace1, pwFace2));
; 269  : 
; 270  :     // find the edge connecting the two faces
; 271  :     for (iPoint1 = 0; iPoint1 < 3; iPoint1++)

  00064	46		 inc	 esi
  00065	83 fe 03	 cmp	 esi, 3
  00068	72 be		 jb	 SHORT $L57140

; 278  :                 break;
; 279  :             }
; 280  :         }
; 281  :     }
; 282  : 
; 283  :     pvDestPoint = m_cfvf.GetArrayElem(pvLinePoints, iCurPoint);

  0006a	8b 45 1c	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  0006d	8b 5d f8	 mov	 ebx, DWORD PTR _this$[ebp]
  00070	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00073	0f af 30	 imul	 esi, DWORD PTR [eax]
  00076	03 75 18	 add	 esi, DWORD PTR _pvLinePoints$[ebp]

; 284  : 
; 285  :     AppendIndexSkinnedPoint(cdMesh, pwFace1, iEdge, pvMeshPoints, pvLinePoints, iCurPoint);

  00079	50		 push	 eax
  0007a	ff 75 18	 push	 DWORD PTR _pvLinePoints$[ebp]
  0007d	8b cb		 mov	 ecx, ebx
  0007f	ff 75 14	 push	 DWORD PTR _pvMeshPoints$[ebp]
  00082	ff 75 fc	 push	 DWORD PTR _iEdge$[ebp]
  00085	57		 push	 edi
  00086	ff 75 08	 push	 DWORD PTR _cdMesh$[ebp]
  00089	e8 00 00 00 00	 call	 ?AppendIndexSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z ; CStripOutline::AppendIndexSkinnedPoint

; 286  : 
; 287  :     // the third position should be ignored!
; 288  :     m_cfvf.SetTexCoord(pvDestPoint, 6, &vMidPoint);

  0008e	8d 45 ec	 lea	 eax, DWORD PTR _vMidPoint$[ebp]
  00091	50		 push	 eax
  00092	6a 06		 push	 6
  00094	56		 push	 esi
  00095	8b cb		 mov	 ecx, ebx
  00097	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx

; 289  : }

  0009f	c9		 leave
  000a0	c2 18 00	 ret	 24			; 00000018H
?AppendIndexSkinnedMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z ENDP ; CStripOutline::AppendIndexSkinnedMidpoint
_TEXT	ENDS
PUBLIC	?Init@CStripOutline@@QAEJPAUID3DXBaseMesh@@@Z	; CStripOutline::Init
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_D3DXDeclaratorFromFVF@8:NEAR
; Function compile flags: /Ogs
;	COMDAT ?Init@CStripOutline@@QAEJPAUID3DXBaseMesh@@@Z
_TEXT	SEGMENT
_Caps$ = -1160						; size = 304
_pDecl$ = -856						; size = 520
$T57146 = -336						; size = 64
_cdMesh$ = -272						; size = 196
_cConnections$ = -76					; size = 4
_iattr$ = -72						; size = 4
_rgwFaces$ = -68					; size = 4
tv1394 = -64						; size = 4
_pDevice$ = -60						; size = 4
_pdwFaceCur$ = -56					; size = 4
_cPointsMax$ = -52					; size = 4
_pdwFacePrev$ = -52					; size = 4
_pVBVertices$ = -48					; size = 4
_rgaeAttributeTableMesh$ = -44				; size = 4
_rgiStrips$ = -40					; size = 4
_pibFaces$ = -36					; size = 4
tv1451 = -32						; size = 4
tv1375 = -32						; size = 4
_rgdwFaces$ = -28					; size = 4
_b16BitMesh$ = -21					; size = 1
_iEndOfStrips$ = -20					; size = 4
_pvMeshPoints$ = -16					; size = 4
_pvLinePoints$ = -12					; size = 4
_iCurLine$ = -8						; size = 4
_iFace$ = -8						; size = 4
_cFaces$ = -8						; size = 4
_iStripIndex$ = -4					; size = 4
_hr$ = -4						; size = 4
_iCurPoint$ = 8						; size = 4
_ptmMesh$ = 8						; size = 4
?Init@CStripOutline@@QAEJPAUID3DXBaseMesh@@@Z PROC NEAR	; CStripOutline::Init, COMDAT
; _this$ = ecx

; 733  : }

  00000	8b ff		 npad	 2

; 344  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 88 04 00
	00		 sub	 esp, 1160		; 00000488H
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 345  :     HRESULT hr = S_OK;
; 346  :     DWORD cFaces;
; 347  :     DWORD iFace;
; 348  :     DWORD iEndOfStrips;
; 349  :     UINT *rgiStrips = NULL;

  0000e	33 ff		 xor	 edi, edi
  00010	8b d9		 mov	 ebx, ecx

; 350  :     DWORD cConnections;
; 351  :     DWORD cStrips;
; 352  :     DWORD cPointsMax;
; 353  :     DWORD iStripIndex;
; 354  :     UINT iCurPoint;
; 355  :     DWORD iCurLine;
; 356  :     PBYTE pvLinePoints = NULL;
; 357  :     PBYTE pvMeshPoints = NULL;
; 358  :     LPDIRECT3DVERTEXBUFFER9 pVBVertices = NULL;
; 359  :     LPDIRECT3DINDEXBUFFER9 pibFaces= NULL;
; 360  :     PUINT pdwFaceCur;
; 361  :     PUINT pdwFacePrev;
; 362  :     PUINT rgdwFaces = NULL;
; 363  :     CD3DXCrackDecl1 cdMesh;

  00012	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _cdMesh$[ebp]
  00018	89 7d d8	 mov	 DWORD PTR _rgiStrips$[ebp], edi
  0001b	89 7d f4	 mov	 DWORD PTR _pvLinePoints$[ebp], edi
  0001e	89 7d f0	 mov	 DWORD PTR _pvMeshPoints$[ebp], edi
  00021	89 7d d0	 mov	 DWORD PTR _pVBVertices$[ebp], edi
  00024	89 7d dc	 mov	 DWORD PTR _pibFaces$[ebp], edi
  00027	89 7d e4	 mov	 DWORD PTR _rgdwFaces$[ebp], edi
  0002a	e8 00 00 00 00	 call	 ??0CD3DXCrackDecl1@@QAE@XZ ; CD3DXCrackDecl1::CD3DXCrackDecl1

; 364  :     PWORD rgwFaces = NULL;
; 365  :     bool b16BitMesh;
; 366  :     UINT iIndex;
; 367  :     LPDIRECT3DDEVICE9 pDevice;
; 368  :     D3DXATTRIBUTERANGE *rgaeAttributeTableMesh = NULL;
; 369  :     DWORD iattr;
; 370  :     DWORD cStripsCur;
; 371  :     DWORD cVerticesCur;
; 372  :     DWORD dwFVFAdjVertices;
; 373  :     D3DCAPS9 Caps;
; 374  :     DWORD iFaceEnd;
; 375  :     DWORD iFaceStart;
; 376  :     D3DVERTEXELEMENT9 pDecl[MAX_FVF_DECL_SIZE];
; 377  :     LPD3DVERTEXELEMENT9 pDeclCur;
; 378  : 
; 379  :     hr = CreateEmptyOutline();

  0002f	8b cb		 mov	 ecx, ebx
  00031	89 7d bc	 mov	 DWORD PTR _rgwFaces$[ebp], edi
  00034	89 7d d4	 mov	 DWORD PTR _rgaeAttributeTableMesh$[ebp], edi
  00037	e8 00 00 00 00	 call	 ?CreateEmptyOutline@CStripOutline@@AAEJXZ ; CStripOutline::CreateEmptyOutline

; 380  :     if (FAILED(hr))

  0003c	3b c7		 cmp	 eax, edi
  0003e	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00041	0f 8c 17 06 00
	00		 jl	 $e_Exit$56482

; 381  :         goto e_Exit;
; 382  : 
; 383  : 
; 384  :     if (ptmMesh == NULL)

  00047	8b 75 08	 mov	 esi, DWORD PTR _ptmMesh$[ebp]
  0004a	3b f7		 cmp	 esi, edi
  0004c	0f 84 0c 06 00
	00		 je	 $e_Exit$56482

; 385  :         goto e_Exit;
; 386  : 
; 387  :     ptmMesh->GetDeclaration(pDecl);

  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	8d 8d a8 fc ff
	ff		 lea	 ecx, DWORD PTR _pDecl$[ebp]
  0005a	51		 push	 ecx
  0005b	56		 push	 esi
  0005c	ff 50 1c	 call	 DWORD PTR [eax+28]

; 388  :     cdMesh.SetDeclaration(pDecl);

  0005f	8d 85 a8 fc ff
	ff		 lea	 eax, DWORD PTR _pDecl$[ebp]
  00065	50		 push	 eax
  00066	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _cdMesh$[ebp]
  0006c	e8 00 00 00 00	 call	 ?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z ; CD3DXCrackDecl1::SetDeclaration

; 389  : 
; 390  :     ptmMesh->GetDevice(&pDevice);

  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	8d 4d c4	 lea	 ecx, DWORD PTR _pDevice$[ebp]
  00076	51		 push	 ecx
  00077	56		 push	 esi
  00078	ff 50 28	 call	 DWORD PTR [eax+40]

; 391  :     pDevice->Release();

  0007b	8b 45 c4	 mov	 eax, DWORD PTR _pDevice$[ebp]
  0007e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00080	50		 push	 eax
  00081	ff 51 08	 call	 DWORD PTR [ecx+8]

; 392  : 
; 393  :     pDevice->GetDeviceCaps(&Caps);

  00084	8b 45 c4	 mov	 eax, DWORD PTR _pDevice$[ebp]
  00087	8b 08		 mov	 ecx, DWORD PTR [eax]
  00089	8d 95 78 fb ff
	ff		 lea	 edx, DWORD PTR _Caps$[ebp]
  0008f	52		 push	 edx
  00090	50		 push	 eax
  00091	ff 51 1c	 call	 DWORD PTR [ecx+28]

; 394  :     m_bHWVertexShaders = Caps.VertexShaderVersion >= D3DVS_VERSION(1,1);

  00094	81 bd 3c fc ff
	ff 01 01 fe ff	 cmp	 DWORD PTR _Caps$[ebp+196], -130815 ; fffe0101H

; 395  : 
; 396  :     // is the mesh 16 bit?
; 397  :     b16BitMesh = !(ptmMesh->GetOptions() & D3DXMESH_32BIT);

  0009e	56		 push	 esi
  0009f	1b c0		 sbb	 eax, eax
  000a1	40		 inc	 eax
  000a2	89 43 48	 mov	 DWORD PTR [ebx+72], eax
  000a5	8b 06		 mov	 eax, DWORD PTR [esi]
  000a7	ff 50 24	 call	 DWORD PTR [eax+36]

; 398  : 
; 399  :     hr = ptmMesh->GetAttributeTable(NULL, &m_caeAttributeTable);

  000aa	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000ac	34 ff		 xor	 al, 255			; 000000ffH
  000ae	24 01		 and	 al, 1
  000b0	88 45 eb	 mov	 BYTE PTR _b16BitMesh$[ebp], al
  000b3	8d 43 58	 lea	 eax, DWORD PTR [ebx+88]
  000b6	50		 push	 eax
  000b7	57		 push	 edi
  000b8	56		 push	 esi
  000b9	ff 51 4c	 call	 DWORD PTR [ecx+76]

; 400  :     if (FAILED(hr))

  000bc	3b c7		 cmp	 eax, edi
  000be	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  000c1	0f 8c 97 05 00
	00		 jl	 $e_Exit$56482

; 401  :         goto e_Exit;
; 402  : 
; 403  :     if (m_caeAttributeTable == 0)

  000c7	8b 43 58	 mov	 eax, DWORD PTR [ebx+88]
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 8c 05 00
	00		 je	 $e_Exit$56482

; 404  :     {
; 405  :         // not attribute sorted!  just return for now
; 406  :         goto e_Exit;
; 407  :     }
; 408  : 
; 409  :     rgaeAttributeTableMesh = new D3DXATTRIBUTERANGE[m_caeAttributeTable];

  000d2	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000d5	c1 e0 02	 shl	 eax, 2
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000de	89 45 d4	 mov	 DWORD PTR _rgaeAttributeTableMesh$[ebp], eax

; 410  :     m_rgaeAttributeTable = new D3DXATTRIBUTERANGE[m_caeAttributeTable];

  000e1	8b 43 58	 mov	 eax, DWORD PTR [ebx+88]
  000e4	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000e7	c1 e0 02	 shl	 eax, 2
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 411  :     if ((rgaeAttributeTableMesh == NULL) || (rgaeAttributeTableMesh == NULL))

  000f0	39 7d d4	 cmp	 DWORD PTR _rgaeAttributeTableMesh$[ebp], edi
  000f3	59		 pop	 ecx
  000f4	59		 pop	 ecx
  000f5	89 43 54	 mov	 DWORD PTR [ebx+84], eax
  000f8	0f 84 59 05 00
	00		 je	 $L56496

; 414  :         goto e_Exit;
; 415  :     }
; 416  : 
; 417  :     hr = ptmMesh->GetAttributeTable(rgaeAttributeTableMesh, NULL);

  000fe	57		 push	 edi
  000ff	ff 75 d4	 push	 DWORD PTR _rgaeAttributeTableMesh$[ebp]
  00102	8b c6		 mov	 eax, esi
  00104	8b 08		 mov	 ecx, DWORD PTR [eax]
  00106	50		 push	 eax
  00107	ff 51 4c	 call	 DWORD PTR [ecx+76]

; 418  :     if (FAILED(hr))

  0010a	85 c0		 test	 eax, eax
  0010c	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  0010f	0f 8c 49 05 00
	00		 jl	 $e_Exit$56482

; 419  :         goto e_Exit;
; 420  : 
; 421  :     cFaces = 0;

  00115	33 f6		 xor	 esi, esi

; 422  :     for (iattr = 0; iattr < m_caeAttributeTable; iattr++)

  00117	39 73 58	 cmp	 DWORD PTR [ebx+88], esi
  0011a	89 75 f8	 mov	 DWORD PTR _cFaces$[ebp], esi
  0011d	76 1e		 jbe	 SHORT $L56504
  0011f	8b 45 d4	 mov	 eax, DWORD PTR _rgaeAttributeTableMesh$[ebp]
  00122	8b 53 58	 mov	 edx, DWORD PTR [ebx+88]
  00125	83 c0 04	 add	 eax, 4
$L56502:

; 423  :     {
; 424  :         cFaces = max(cFaces, rgaeAttributeTableMesh[iattr].FaceStart + rgaeAttributeTableMesh[iattr].FaceCount);

  00128	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012b	8b 38		 mov	 edi, DWORD PTR [eax]
  0012d	03 cf		 add	 ecx, edi
  0012f	39 4d f8	 cmp	 DWORD PTR _cFaces$[ebp], ecx
  00132	77 03		 ja	 SHORT $L57145
  00134	89 4d f8	 mov	 DWORD PTR _cFaces$[ebp], ecx
$L57145:

; 422  :     for (iattr = 0; iattr < m_caeAttributeTable; iattr++)

  00137	83 c0 14	 add	 eax, 20			; 00000014H
  0013a	4a		 dec	 edx
  0013b	75 eb		 jne	 SHORT $L56502
$L56504:

; 425  :     }
; 426  : 
; 427  :     if (cdMesh.CWeights() > 0)

  0013d	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _cdMesh$[ebp+140]
  00143	3b c6		 cmp	 eax, esi
  00145	74 25		 je	 SHORT $L56505
  00147	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0014b	40		 inc	 eax
  0014c	3b c6		 cmp	 eax, esi
  0014e	7e 1c		 jle	 SHORT $L56505

; 428  :     {
; 429  :         m_bSkinning = TRUE;

  00150	33 c0		 xor	 eax, eax
  00152	40		 inc	 eax

; 430  : 
; 431  :         if (cdMesh.BIndexedWeights())

  00153	39 75 80	 cmp	 DWORD PTR _cdMesh$[ebp+144], esi
  00156	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  00159	74 0a		 je	 SHORT $L56506

; 432  :         {
; 433  :             dwFVFAdjVertices = INDEXSKINNEDFVF;

  0015b	b9 0e 87 79 1e	 mov	 ecx, 511280910		; 1e79870eH

; 434  :             m_bIndexSkinning = TRUE;

  00160	89 43 44	 mov	 DWORD PTR [ebx+68], eax

; 435  :         }
; 436  :         else

  00163	eb 10		 jmp	 SHORT $L56508
$L56506:

; 437  :         {
; 438  :             dwFVFAdjVertices = SKINNEDFVF;

  00165	b9 0c 05 99 01	 mov	 ecx, 26805516		; 0199050cH

; 439  :             m_bIndexSkinning = FALSE;
; 440  :         }
; 441  :     }
; 442  :     else

  0016a	eb 06		 jmp	 SHORT $L57192
$L56505:

; 443  :     {
; 444  :         dwFVFAdjVertices = D3DFVF_XYZ;

  0016c	6a 02		 push	 2
  0016e	59		 pop	 ecx

; 445  :         m_bSkinning = FALSE;

  0016f	89 73 40	 mov	 DWORD PTR [ebx+64], esi
$L57192:

; 446  :         m_bIndexSkinning = FALSE;

  00172	89 73 44	 mov	 DWORD PTR [ebx+68], esi
$L56508:

; 447  :     }
; 448  :     m_cfvf = DXCrackFVF(dwFVFAdjVertices);

  00175	51		 push	 ecx
  00176	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T57146[ebp]
  0017c	e8 00 00 00 00	 call	 ??0DXCrackFVF@@QAE@K@Z	; DXCrackFVF::DXCrackFVF
  00181	8b f0		 mov	 esi, eax

; 449  : 
; 450  :     // allocate a temporary array to track the triangles to connect with lines
; 451  :     rgiStrips = new UINT[cFaces*2];

  00183	8b 45 f8	 mov	 eax, DWORD PTR _cFaces$[ebp]
  00186	6a 10		 push	 16			; 00000010H
  00188	59		 pop	 ecx
  00189	c1 e0 03	 shl	 eax, 3
  0018c	8b fb		 mov	 edi, ebx
  0018e	50		 push	 eax
  0018f	f3 a5		 rep movsd
  00191	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 452  :     if (rgiStrips == NULL)

  00196	85 c0		 test	 eax, eax
  00198	59		 pop	 ecx
  00199	89 45 d8	 mov	 DWORD PTR _rgiStrips$[ebp], eax

; 693  :     if (FAILED(hr))
; 694  :         goto e_Exit;
; 695  : 
; 696  : e_Exit:

  0019c	0f 84 b5 04 00
	00		 je	 $L56496

; 453  :     {
; 454  :         hr = E_OUTOFMEMORY;
; 455  :         goto e_Exit;
; 456  :     }
; 457  : 
; 458  :     if (b16BitMesh)

  001a2	80 7d eb 00	 cmp	 BYTE PTR _b16BitMesh$[ebp], 0
  001a6	0f 84 84 00 00
	00		 je	 $L56515

; 459  :     {
; 460  :         // allocate a temporary, so that the follow code
; 461  :         //   can work on just 32bit indices
; 462  :         rgdwFaces = new UINT[cFaces*3];

  001ac	8b 7d f8	 mov	 edi, DWORD PTR _cFaces$[ebp]
  001af	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  001b2	c1 e0 02	 shl	 eax, 2
  001b5	50		 push	 eax
  001b6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 463  :         if (rgdwFaces == NULL)

  001bb	85 c0		 test	 eax, eax
  001bd	59		 pop	 ecx
  001be	89 45 e4	 mov	 DWORD PTR _rgdwFaces$[ebp], eax

; 693  :     if (FAILED(hr))
; 694  :         goto e_Exit;
; 695  : 
; 696  : e_Exit:

  001c1	0f 84 90 04 00
	00		 je	 $L56496
  001c7	8b 45 08	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  001ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cc	8d 55 dc	 lea	 edx, DWORD PTR _pibFaces$[ebp]
  001cf	52		 push	 edx
  001d0	50		 push	 eax
  001d1	ff 51 38	 call	 DWORD PTR [ecx+56]
  001d4	85 c0		 test	 eax, eax
  001d6	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  001d9	0f 8c 7f 04 00
	00		 jl	 $e_Exit$56482
  001df	8b 45 dc	 mov	 eax, DWORD PTR _pibFaces$[ebp]
  001e2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e4	68 00 08 00 00	 push	 2048			; 00000800H
  001e9	8d 55 bc	 lea	 edx, DWORD PTR _rgwFaces$[ebp]
  001ec	52		 push	 edx
  001ed	6a 00		 push	 0
  001ef	6a 00		 push	 0
  001f1	50		 push	 eax
  001f2	ff 51 2c	 call	 DWORD PTR [ecx+44]
  001f5	85 c0		 test	 eax, eax
  001f7	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  001fa	0f 8c 5e 04 00
	00		 jl	 $e_Exit$56482
  00200	8d 3c 7f	 lea	 edi, DWORD PTR [edi+edi*2]
  00203	33 c0		 xor	 eax, eax
  00205	85 ff		 test	 edi, edi
  00207	76 60		 jbe	 SHORT $L56539
$L56528:

; 464  :         {
; 465  :             hr = E_OUTOFMEMORY;
; 466  :             goto e_Exit;
; 467  :         }
; 468  : 
; 469  :         // get the index buffer
; 470  :         hr = ptmMesh->GetIndexBuffer(&pibFaces);
; 471  :         if (FAILED(hr))
; 472  :             goto e_Exit;
; 473  : 
; 474  :         hr = pibFaces->Lock(0,0, (PVOID*)&rgwFaces, D3DLOCK_NOSYSLOCK );
; 475  :         if (FAILED(hr))
; 476  :             goto e_Exit;
; 477  : 
; 478  :         // UpConvert from 16 bit to 32 bit
; 479  :         for (iIndex = 0; iIndex < cFaces * 3; iIndex++)
; 480  :         {
; 481  :             if (rgwFaces[iIndex] != UNUSED16)

  00209	8b 4d bc	 mov	 ecx, DWORD PTR _rgwFaces$[ebp]
  0020c	66 8b 0c 41	 mov	 cx, WORD PTR [ecx+eax*2]
  00210	66 81 f9 ff ff	 cmp	 cx, 65535		; 0000ffffH
  00215	74 0b		 je	 SHORT $L56531

; 482  :                 rgdwFaces[iIndex] = rgwFaces[iIndex];

  00217	8b 55 e4	 mov	 edx, DWORD PTR _rgdwFaces$[ebp]
  0021a	0f b7 c9	 movzx	 ecx, cx
  0021d	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx

; 483  :             else

  00220	eb 07		 jmp	 SHORT $L56529
$L56531:

; 484  :                 rgdwFaces[iIndex] = UNUSED32;

  00222	8b 4d e4	 mov	 ecx, DWORD PTR _rgdwFaces$[ebp]
  00225	83 0c 81 ff	 or	 DWORD PTR [ecx+eax*4], -1
$L56529:
  00229	40		 inc	 eax
  0022a	3b c7		 cmp	 eax, edi
  0022c	72 db		 jb	 SHORT $L56528

; 485  :         }
; 486  :     }
; 487  :     else

  0022e	eb 39		 jmp	 SHORT $L56539
$L56515:

; 488  :     {
; 489  :         // get the index buffer
; 490  :         hr = ptmMesh->GetIndexBuffer(&pibFaces);

  00230	8b 45 08	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  00233	8b 08		 mov	 ecx, DWORD PTR [eax]
  00235	8d 55 dc	 lea	 edx, DWORD PTR _pibFaces$[ebp]
  00238	52		 push	 edx
  00239	50		 push	 eax
  0023a	ff 51 38	 call	 DWORD PTR [ecx+56]

; 491  :         if (FAILED(hr))

  0023d	85 c0		 test	 eax, eax
  0023f	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00242	0f 8c 2b 04 00
	00		 jl	 $L57184

; 492  :             goto e_Exit;
; 493  : 
; 494  :         hr = pibFaces->Lock(0,0, (PVOID*)&rgdwFaces, D3DLOCK_NOSYSLOCK );

  00248	8b 45 dc	 mov	 eax, DWORD PTR _pibFaces$[ebp]
  0024b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024d	68 00 08 00 00	 push	 2048			; 00000800H
  00252	8d 55 e4	 lea	 edx, DWORD PTR _rgdwFaces$[ebp]
  00255	52		 push	 edx
  00256	6a 00		 push	 0
  00258	6a 00		 push	 0
  0025a	50		 push	 eax
  0025b	ff 51 2c	 call	 DWORD PTR [ecx+44]

; 495  :         if (FAILED(hr))

  0025e	85 c0		 test	 eax, eax
  00260	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00263	0f 8c 0a 04 00
	00		 jl	 $L57184
$L56539:

; 496  :             goto e_Exit;
; 497  :     }
; 498  : 
; 499  : 
; 500  :     // start out with zero entries in each attribute table
; 501  :             // fixup the rest of the entries after figuring out the counts
; 502  :     for (iattr = 0; iattr < m_caeAttributeTable; iattr++)

  00269	8b 55 d4	 mov	 edx, DWORD PTR _rgaeAttributeTableMesh$[ebp]
  0026c	33 c0		 xor	 eax, eax
  0026e	33 c9		 xor	 ecx, ecx
  00270	39 43 58	 cmp	 DWORD PTR [ebx+88], eax
  00273	76 22		 jbe	 SHORT $L56543
$L57188:

; 503  :     {
; 504  :         m_rgaeAttributeTable[iattr].FaceCount = 0;

  00275	8b 73 54	 mov	 esi, DWORD PTR [ebx+84]
  00278	83 64 06 08 00	 and	 DWORD PTR [esi+eax+8], 0

; 505  :         m_rgaeAttributeTable[iattr].VertexCount = 0;

  0027d	8b 73 54	 mov	 esi, DWORD PTR [ebx+84]
  00280	83 64 06 10 00	 and	 DWORD PTR [esi+eax+16], 0

; 506  : 
; 507  :         m_rgaeAttributeTable[iattr].AttribId = rgaeAttributeTableMesh[iattr].AttribId;

  00285	8b 3c 10	 mov	 edi, DWORD PTR [eax+edx]
  00288	8b 73 54	 mov	 esi, DWORD PTR [ebx+84]
  0028b	89 3c 30	 mov	 DWORD PTR [eax+esi], edi
  0028e	41		 inc	 ecx
  0028f	83 c0 14	 add	 eax, 20			; 00000014H
  00292	3b 4b 58	 cmp	 ecx, DWORD PTR [ebx+88]
  00295	72 de		 jb	 SHORT $L57188
$L56543:

; 508  : 
; 509  :     }
; 510  : 
; 511  :     iEndOfStrips = 0;

  00297	33 c0		 xor	 eax, eax

; 512  :     cConnections = 0;
; 513  :     cStrips = 0;
; 514  : 
; 515  :     for (iattr = 0; iattr < m_caeAttributeTable; iattr++)

  00299	39 43 58	 cmp	 DWORD PTR [ebx+88], eax
  0029c	89 45 ec	 mov	 DWORD PTR _iEndOfStrips$[ebp], eax
  0029f	89 45 b4	 mov	 DWORD PTR _cConnections$[ebp], eax
  002a2	89 45 b8	 mov	 DWORD PTR _iattr$[ebp], eax
  002a5	0f 86 da 00 00
	00		 jbe	 $L56546
  002ab	8d 4a 08	 lea	 ecx, DWORD PTR [edx+8]
  002ae	c7 45 c0 f8 ff
	ff ff		 mov	 DWORD PTR tv1394[ebp], -8 ; fffffff8H
  002b5	29 55 c0	 sub	 DWORD PTR tv1394[ebp], edx
  002b8	89 4d e0	 mov	 DWORD PTR tv1375[ebp], ecx
  002bb	eb 02		 jmp	 SHORT $L56544
$L57191:

; 508  : 
; 509  :     }
; 510  : 
; 511  :     iEndOfStrips = 0;

  002bd	33 c0		 xor	 eax, eax
$L56544:

; 516  :     {
; 517  :         if (rgaeAttributeTableMesh[iattr].FaceCount == 0)

  002bf	8b 4d e0	 mov	 ecx, DWORD PTR tv1375[ebp]
  002c2	39 01		 cmp	 DWORD PTR [ecx], eax
  002c4	0f 84 a8 00 00
	00		 je	 $L56545

; 518  :             continue;
; 519  : 
; 520  :         m_rgaeAttributeTable[iattr].VertexCount = 0;

  002ca	8b 45 c0	 mov	 eax, DWORD PTR tv1394[ebp]
  002cd	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  002d0	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  002d3	83 64 30 10 00	 and	 DWORD PTR [eax+esi+16], 0

; 521  : 
; 522  :         iFaceStart = rgaeAttributeTableMesh[iattr].FaceStart;

  002d8	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 523  :         iFaceEnd = iFaceStart + rgaeAttributeTableMesh[iattr].FaceCount;

  002db	8b 39		 mov	 edi, DWORD PTR [ecx]

; 524  : 
; 525  :         pdwFacePrev = &rgdwFaces[iFaceStart * 3];

  002dd	8b 55 e4	 mov	 edx, DWORD PTR _rgdwFaces$[ebp]
  002e0	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  002e3	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]

; 526  :         pdwFaceCur = pdwFacePrev + 3;
; 527  :         rgiStrips[iEndOfStrips] = iFaceStart;

  002e6	8b 55 ec	 mov	 edx, DWORD PTR _iEndOfStrips$[ebp]
  002e9	89 4d cc	 mov	 DWORD PTR _pdwFacePrev$[ebp], ecx
  002ec	83 c1 0c	 add	 ecx, 12			; 0000000cH
  002ef	03 f8		 add	 edi, eax

; 528  :         iEndOfStrips += 1;

  002f1	ff 45 ec	 inc	 DWORD PTR _iEndOfStrips$[ebp]
  002f4	89 4d c8	 mov	 DWORD PTR _pdwFaceCur$[ebp], ecx
  002f7	8b 4d d8	 mov	 ecx, DWORD PTR _rgiStrips$[ebp]
  002fa	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 529  :         cStrips += 1;
; 530  :         for (iFace = iFaceStart + 1; iFace < iFaceEnd; iFace++)

  002fd	40		 inc	 eax
  002fe	3b c7		 cmp	 eax, edi
  00300	89 45 f8	 mov	 DWORD PTR _iFace$[ebp], eax
  00303	73 60		 jae	 SHORT $L56550
$L56548:

; 531  :         {
; 532  :             // if the part of the same strip, extend the strip
; 533  :             if (BConnected(pdwFaceCur, pdwFacePrev))

  00305	ff 75 cc	 push	 DWORD PTR _pdwFacePrev$[ebp]
  00308	ff 75 c8	 push	 DWORD PTR _pdwFaceCur$[ebp]
  0030b	e8 00 00 00 00	 call	 ?BConnected@@YA_NPAI0@Z	; BConnected
  00310	84 c0		 test	 al, al
  00312	59		 pop	 ecx
  00313	59		 pop	 ecx
  00314	74 28		 je	 SHORT $L56551

; 534  :             {
; 535  :                 rgiStrips[iEndOfStrips] = iFace;

  00316	8b 45 d8	 mov	 eax, DWORD PTR _rgiStrips$[ebp]
  00319	8b 55 ec	 mov	 edx, DWORD PTR _iEndOfStrips$[ebp]
  0031c	8b 4d f8	 mov	 ecx, DWORD PTR _iFace$[ebp]

; 536  :                 iEndOfStrips += 1;

  0031f	ff 45 ec	 inc	 DWORD PTR _iEndOfStrips$[ebp]
  00322	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 537  : 
; 538  :                 m_rgaeAttributeTable[iattr].FaceCount += 2;

  00325	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  00328	8d 44 06 08	 lea	 eax, DWORD PTR [esi+eax+8]
  0032c	83 00 02	 add	 DWORD PTR [eax], 2

; 539  :                 m_rgaeAttributeTable[iattr].VertexCount += 4;

  0032f	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  00332	8d 44 06 10	 lea	 eax, DWORD PTR [esi+eax+16]
  00336	83 00 04	 add	 DWORD PTR [eax], 4

; 540  : 
; 541  :                 // how many faces are connected to another in a strip-like fashion
; 542  :                 cConnections += 1;

  00339	ff 45 b4	 inc	 DWORD PTR _cConnections$[ebp]

; 543  :             }
; 544  :             else // end the strip, and restart a new one with the current face

  0033c	eb 15		 jmp	 SHORT $L56552
$L56551:

; 545  :             {
; 546  :                 rgiStrips[iEndOfStrips] = UNUSED32;

  0033e	8b 45 ec	 mov	 eax, DWORD PTR _iEndOfStrips$[ebp]
  00341	8b 4d d8	 mov	 ecx, DWORD PTR _rgiStrips$[ebp]
  00344	83 0c 81 ff	 or	 DWORD PTR [ecx+eax*4], -1

; 547  :                 iEndOfStrips += 1;
; 548  : 
; 549  : 
; 550  :                 rgiStrips[iEndOfStrips] = iFace;

  00348	8b 55 f8	 mov	 edx, DWORD PTR _iFace$[ebp]
  0034b	40		 inc	 eax
  0034c	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 551  :                 iEndOfStrips += 1;

  0034f	40		 inc	 eax
  00350	89 45 ec	 mov	 DWORD PTR _iEndOfStrips$[ebp], eax
$L56552:

; 552  : 
; 553  :                 cStrips += 1;
; 554  :             }
; 555  : 
; 556  :             // move the current to the previous, then increment the current one
; 557  :             pdwFacePrev = pdwFaceCur;

  00353	8b 45 c8	 mov	 eax, DWORD PTR _pdwFaceCur$[ebp]

; 558  :             pdwFaceCur += 3;

  00356	83 45 c8 0c	 add	 DWORD PTR _pdwFaceCur$[ebp], 12 ; 0000000cH
  0035a	ff 45 f8	 inc	 DWORD PTR _iFace$[ebp]
  0035d	39 7d f8	 cmp	 DWORD PTR _iFace$[ebp], edi
  00360	89 45 cc	 mov	 DWORD PTR _pdwFacePrev$[ebp], eax
  00363	72 a0		 jb	 SHORT $L56548
$L56550:

; 559  :         }
; 560  : 
; 561  :         // for consistency end the last strip
; 562  :         rgiStrips[iEndOfStrips] = UNUSED32;

  00365	8b 4d ec	 mov	 ecx, DWORD PTR _iEndOfStrips$[ebp]
  00368	8b 45 d8	 mov	 eax, DWORD PTR _rgiStrips$[ebp]
  0036b	83 0c 88 ff	 or	 DWORD PTR [eax+ecx*4], -1

; 563  :         iEndOfStrips += 1;

  0036f	ff 45 ec	 inc	 DWORD PTR _iEndOfStrips$[ebp]
$L56545:
  00372	ff 45 b8	 inc	 DWORD PTR _iattr$[ebp]
  00375	8b 45 b8	 mov	 eax, DWORD PTR _iattr$[ebp]
  00378	83 45 e0 14	 add	 DWORD PTR tv1375[ebp], 20 ; 00000014H
  0037c	3b 43 58	 cmp	 eax, DWORD PTR [ebx+88]
  0037f	0f 82 38 ff ff
	ff		 jb	 $L57191
$L56546:

; 564  :     }
; 565  : 
; 566  : 
; 567  :     // start out with zero entries in each attribute table
; 568  :             // fixup the rest of the entries after figuring out the counts
; 569  :     cStripsCur = 0;

  00385	33 ff		 xor	 edi, edi
  00387	33 d2		 xor	 edx, edx

; 570  :     cVerticesCur = 0;

  00389	33 f6		 xor	 esi, esi

; 571  :     for (iattr = 0; iattr < m_caeAttributeTable; iattr++)

  0038b	39 7b 58	 cmp	 DWORD PTR [ebx+88], edi
  0038e	76 24		 jbe	 SHORT $L57187
  00390	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  00393	33 c0		 xor	 eax, eax
$L56553:

; 572  :     {
; 573  :         m_rgaeAttributeTable[iattr].FaceStart = cStripsCur;

  00395	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx

; 574  :         m_rgaeAttributeTable[iattr].VertexStart = cVerticesCur;

  00399	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  0039c	89 74 01 0c	 mov	 DWORD PTR [ecx+eax+12], esi

; 575  : 
; 576  :         cStripsCur += m_rgaeAttributeTable[iattr].FaceCount;

  003a0	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  003a3	03 54 01 08	 add	 edx, DWORD PTR [ecx+eax+8]

; 577  :         cVerticesCur += m_rgaeAttributeTable[iattr].VertexCount;

  003a7	03 74 01 10	 add	 esi, DWORD PTR [ecx+eax+16]
  003ab	47		 inc	 edi
  003ac	83 c0 14	 add	 eax, 20			; 00000014H
  003af	3b 7b 58	 cmp	 edi, DWORD PTR [ebx+88]
  003b2	72 e1		 jb	 SHORT $L56553
$L57187:

; 578  :     }
; 579  : 
; 580  :     cPointsMax = cConnections * 4;

  003b4	8b 45 b4	 mov	 eax, DWORD PTR _cConnections$[ebp]
  003b7	8b c8		 mov	 ecx, eax
  003b9	c1 e1 02	 shl	 ecx, 2

; 581  : 
; 582  :     if (cConnections == 0)

  003bc	85 c0		 test	 eax, eax
  003be	89 4d cc	 mov	 DWORD PTR _cPointsMax$[ebp], ecx
  003c1	0f 84 97 02 00
	00		 je	 $e_Exit$56482

; 583  :         goto e_Exit;
; 584  : 
; 585  :     hr = pDevice->CreateVertexBuffer(m_cfvf.m_cBytesPerVertex * cPointsMax, 
; 586  :                     D3DUSAGE_WRITEONLY|(m_bHWVertexShaders ? 0:D3DUSAGE_SOFTWAREPROCESSING), 
; 587  :                     m_cfvf.m_dwFVF, D3DPOOL_MANAGED, &m_pVertexBuffer, NULL);

  003c7	8b 53 48	 mov	 edx, DWORD PTR [ebx+72]
  003ca	8b 45 c4	 mov	 eax, DWORD PTR _pDevice$[ebp]
  003cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  003cf	f7 da		 neg	 edx
  003d1	6a 00		 push	 0
  003d3	1b d2		 sbb	 edx, edx
  003d5	83 e2 f0	 and	 edx, -16		; fffffff0H
  003d8	8d 7b 4c	 lea	 edi, DWORD PTR [ebx+76]
  003db	57		 push	 edi
  003dc	6a 01		 push	 1
  003de	ff 33		 push	 DWORD PTR [ebx]
  003e0	83 c2 10	 add	 edx, 16			; 00000010H
  003e3	83 ca 08	 or	 edx, 8
  003e6	52		 push	 edx
  003e7	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  003ea	0f af 55 cc	 imul	 edx, DWORD PTR _cPointsMax$[ebp]
  003ee	52		 push	 edx
  003ef	50		 push	 eax
  003f0	ff 51 68	 call	 DWORD PTR [ecx+104]

; 588  :     if (FAILED(hr))

  003f3	85 c0		 test	 eax, eax
  003f5	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  003f8	0f 8c 60 02 00
	00		 jl	 $e_Exit$56482

; 589  :         goto e_Exit;
; 590  : 
; 591  :     hr = m_pVertexBuffer->Lock(0,0, (PVOID*)&pvLinePoints, D3DLOCK_NOSYSLOCK );

  003fe	8b 3f		 mov	 edi, DWORD PTR [edi]
  00400	8b 07		 mov	 eax, DWORD PTR [edi]
  00402	be 00 08 00 00	 mov	 esi, 2048		; 00000800H
  00407	56		 push	 esi
  00408	8d 4d f4	 lea	 ecx, DWORD PTR _pvLinePoints$[ebp]
  0040b	51		 push	 ecx
  0040c	6a 00		 push	 0
  0040e	6a 00		 push	 0
  00410	57		 push	 edi
  00411	ff 50 2c	 call	 DWORD PTR [eax+44]

; 592  :     if (FAILED(hr))

  00414	33 ff		 xor	 edi, edi
  00416	3b c7		 cmp	 eax, edi
  00418	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  0041b	0f 8c 3d 02 00
	00		 jl	 $e_Exit$56482

; 593  :         goto e_Exit;
; 594  : 
; 595  :     hr = ptmMesh->GetVertexBuffer(&pVBVertices);

  00421	8b 45 08	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  00424	8b 08		 mov	 ecx, DWORD PTR [eax]
  00426	8d 55 d0	 lea	 edx, DWORD PTR _pVBVertices$[ebp]
  00429	52		 push	 edx
  0042a	50		 push	 eax
  0042b	ff 51 34	 call	 DWORD PTR [ecx+52]

; 596  :     if (FAILED(hr))

  0042e	3b c7		 cmp	 eax, edi
  00430	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00433	0f 8c 25 02 00
	00		 jl	 $e_Exit$56482

; 597  :         goto e_Exit;
; 598  : 
; 599  :     hr = pVBVertices->Lock(0,0, (PVOID*)&pvMeshPoints, D3DLOCK_NOSYSLOCK );

  00439	8b 45 d0	 mov	 eax, DWORD PTR _pVBVertices$[ebp]
  0043c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0043e	56		 push	 esi
  0043f	8d 55 f0	 lea	 edx, DWORD PTR _pvMeshPoints$[ebp]
  00442	52		 push	 edx
  00443	57		 push	 edi
  00444	57		 push	 edi
  00445	50		 push	 eax
  00446	ff 51 2c	 call	 DWORD PTR [ecx+44]

; 600  :     if (FAILED(hr))

  00449	3b c7		 cmp	 eax, edi
  0044b	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  0044e	0f 8c 0a 02 00
	00		 jl	 $e_Exit$56482

; 601  :         goto e_Exit;
; 602  : 
; 603  : 
; 604  :     iStripIndex = 0;
; 605  :     iCurPoint = 0;
; 606  :     iCurLine = 0;
; 607  :     while (iStripIndex < iEndOfStrips)

  00454	39 7d ec	 cmp	 DWORD PTR _iEndOfStrips$[ebp], edi
  00457	89 7d fc	 mov	 DWORD PTR _iStripIndex$[ebp], edi
  0045a	89 7d 08	 mov	 DWORD PTR _iCurPoint$[ebp], edi
  0045d	89 7d f8	 mov	 DWORD PTR _iCurLine$[ebp], edi
  00460	0f 86 7b 01 00
	00		 jbe	 $L57186
$L56573:

; 608  :     {
; 609  :         iFace = rgiStrips[iStripIndex];

  00466	8b 4d fc	 mov	 ecx, DWORD PTR _iStripIndex$[ebp]
  00469	8b 45 d8	 mov	 eax, DWORD PTR _rgiStrips$[ebp]
  0046c	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 610  :         iStripIndex += 1;

  0046f	ff 45 fc	 inc	 DWORD PTR _iStripIndex$[ebp]

; 611  : 
; 612  :         // for pref reasons, there are a lot of unconnected triangles sometimes
; 613  :         if (iFace == UNUSED32)

  00472	83 f8 ff	 cmp	 eax, -1
  00475	0f 84 58 01 00
	00		 je	 $L57173

; 614  :             continue;
; 615  : 
; 616  :         pdwFacePrev = &rgdwFaces[iFace * 3];

  0047b	8b 4d e4	 mov	 ecx, DWORD PTR _rgdwFaces$[ebp]
  0047e	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00481	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]

; 617  :         if (pdwFacePrev[0] == UNUSED32)

  00484	83 3e ff	 cmp	 DWORD PTR [esi], -1
  00487	0f 84 46 01 00
	00		 je	 $L57173

; 618  :             continue;
; 619  : 
; 620  : 
; 621  :         while(rgiStrips[iStripIndex] != UNUSED32)

  0048d	8b 45 d8	 mov	 eax, DWORD PTR _rgiStrips$[ebp]
  00490	8b 4d fc	 mov	 ecx, DWORD PTR _iStripIndex$[ebp]
  00493	8d 3c 88	 lea	 edi, DWORD PTR [eax+ecx*4]
  00496	83 3f ff	 cmp	 DWORD PTR [edi], -1
  00499	0f 84 34 01 00
	00		 je	 $L57173
  0049f	89 7d e0	 mov	 DWORD PTR tv1451[ebp], edi
$L56578:

; 622  :         {
; 623  :             if (m_bIndexSkinning)

  004a2	83 7b 44 00	 cmp	 DWORD PTR [ebx+68], 0

; 624  :                 AppendIndexSkinnedPoint(cdMesh, pdwFacePrev, 0, pvMeshPoints, pvLinePoints, iCurPoint);

  004a6	8d 45 08	 lea	 eax, DWORD PTR _iCurPoint$[ebp]
  004a9	50		 push	 eax
  004aa	ff 75 f4	 push	 DWORD PTR _pvLinePoints$[ebp]
  004ad	8b cb		 mov	 ecx, ebx
  004af	ff 75 f0	 push	 DWORD PTR _pvMeshPoints$[ebp]
  004b2	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _cdMesh$[ebp]
  004b8	74 0b		 je	 SHORT $L56580
  004ba	6a 00		 push	 0
  004bc	56		 push	 esi
  004bd	50		 push	 eax
  004be	e8 00 00 00 00	 call	 ?AppendIndexSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z ; CStripOutline::AppendIndexSkinnedPoint

; 625  :             else if (m_bSkinning)

  004c3	eb 18		 jmp	 SHORT $L56583
$L56580:
  004c5	83 7b 40 00	 cmp	 DWORD PTR [ebx+64], 0
  004c9	74 0b		 je	 SHORT $L56582

; 626  :                 AppendSkinnedPoint(cdMesh, pdwFacePrev, 0, pvMeshPoints, pvLinePoints, iCurPoint);

  004cb	6a 00		 push	 0
  004cd	56		 push	 esi
  004ce	50		 push	 eax
  004cf	e8 00 00 00 00	 call	 ?AppendSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z ; CStripOutline::AppendSkinnedPoint

; 627  :             else

  004d4	eb 07		 jmp	 SHORT $L56583
$L56582:

; 628  :                 AppendPoint(cdMesh, pdwFacePrev, pvMeshPoints, pvLinePoints, iCurPoint);

  004d6	56		 push	 esi
  004d7	50		 push	 eax
  004d8	e8 00 00 00 00	 call	 ?AppendPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIPAE2AAI@Z ; CStripOutline::AppendPoint
$L56583:

; 629  : 
; 630  :             iFace = rgiStrips[iStripIndex];
; 631  : 
; 632  :             pdwFaceCur = &rgdwFaces[iFace * 3];

  004dd	8b 07		 mov	 eax, DWORD PTR [edi]
  004df	8b 4d e4	 mov	 ecx, DWORD PTR _rgdwFaces$[ebp]
  004e2	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  004e5	8d 3c 81	 lea	 edi, DWORD PTR [ecx+eax*4]

; 633  :             if (pdwFaceCur[0] == UNUSED32)

  004e8	83 3f ff	 cmp	 DWORD PTR [edi], -1
  004eb	0f 84 e2 00 00
	00		 je	 $L57173

; 634  :                 break;
; 635  : 
; 636  :             iCurLine += 1;

  004f1	ff 45 f8	 inc	 DWORD PTR _iCurLine$[ebp]

; 637  : 
; 638  :             if (m_bIndexSkinning)

  004f4	83 7b 44 00	 cmp	 DWORD PTR [ebx+68], 0

; 639  :                 AppendIndexSkinnedMidpoint(cdMesh, pdwFaceCur, pdwFacePrev, pvMeshPoints, pvLinePoints, iCurPoint);

  004f8	8d 45 08	 lea	 eax, DWORD PTR _iCurPoint$[ebp]
  004fb	50		 push	 eax
  004fc	ff 75 f4	 push	 DWORD PTR _pvLinePoints$[ebp]
  004ff	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _cdMesh$[ebp]
  00505	ff 75 f0	 push	 DWORD PTR _pvMeshPoints$[ebp]
  00508	8b cb		 mov	 ecx, ebx
  0050a	56		 push	 esi
  0050b	57		 push	 edi
  0050c	50		 push	 eax
  0050d	74 07		 je	 SHORT $L56585
  0050f	e8 00 00 00 00	 call	 ?AppendIndexSkinnedMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z ; CStripOutline::AppendIndexSkinnedMidpoint

; 640  :             else if (m_bSkinning)

  00514	eb 12		 jmp	 SHORT $L56588
$L56585:
  00516	83 7b 40 00	 cmp	 DWORD PTR [ebx+64], 0
  0051a	74 07		 je	 SHORT $L56587

; 641  :                 AppendSkinnedMidpoint(cdMesh, pdwFaceCur, pdwFacePrev, pvMeshPoints, pvLinePoints, iCurPoint);

  0051c	e8 00 00 00 00	 call	 ?AppendSkinnedMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z ; CStripOutline::AppendSkinnedMidpoint

; 642  :             else

  00521	eb 05		 jmp	 SHORT $L56588
$L56587:

; 643  :                 AppendMidpoint(cdMesh, pdwFaceCur, pdwFacePrev, pvMeshPoints, pvLinePoints, iCurPoint);

  00523	e8 00 00 00 00	 call	 ?AppendMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z ; CStripOutline::AppendMidpoint
$L56588:

; 644  : 
; 645  :             if (m_bIndexSkinning)

  00528	83 7b 44 00	 cmp	 DWORD PTR [ebx+68], 0

; 646  :                 AppendIndexSkinnedMidpoint(cdMesh, pdwFaceCur, pdwFacePrev, pvMeshPoints, pvLinePoints, iCurPoint);

  0052c	8d 45 08	 lea	 eax, DWORD PTR _iCurPoint$[ebp]
  0052f	50		 push	 eax
  00530	ff 75 f4	 push	 DWORD PTR _pvLinePoints$[ebp]
  00533	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _cdMesh$[ebp]
  00539	ff 75 f0	 push	 DWORD PTR _pvMeshPoints$[ebp]
  0053c	8b cb		 mov	 ecx, ebx
  0053e	56		 push	 esi
  0053f	57		 push	 edi
  00540	50		 push	 eax
  00541	74 07		 je	 SHORT $L56589
  00543	e8 00 00 00 00	 call	 ?AppendIndexSkinnedMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z ; CStripOutline::AppendIndexSkinnedMidpoint

; 647  :             else if (m_bSkinning)

  00548	eb 12		 jmp	 SHORT $L56592
$L56589:
  0054a	83 7b 40 00	 cmp	 DWORD PTR [ebx+64], 0
  0054e	74 07		 je	 SHORT $L56591

; 648  :                 AppendSkinnedMidpoint(cdMesh, pdwFaceCur, pdwFacePrev, pvMeshPoints, pvLinePoints, iCurPoint);

  00550	e8 00 00 00 00	 call	 ?AppendSkinnedMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z ; CStripOutline::AppendSkinnedMidpoint

; 649  :             else

  00555	eb 05		 jmp	 SHORT $L56592
$L56591:

; 650  :                 AppendMidpoint(cdMesh, pdwFaceCur, pdwFacePrev, pvMeshPoints, pvLinePoints, iCurPoint);

  00557	e8 00 00 00 00	 call	 ?AppendMidpoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAI1PAE2AAI@Z ; CStripOutline::AppendMidpoint
$L56592:

; 651  : 
; 652  :             iCurLine += 1;

  0055c	ff 45 f8	 inc	 DWORD PTR _iCurLine$[ebp]

; 653  : 
; 654  :             if (m_bIndexSkinning)

  0055f	33 c0		 xor	 eax, eax
  00561	39 43 44	 cmp	 DWORD PTR [ebx+68], eax
  00564	74 1c		 je	 SHORT $L56593

; 655  :                 AppendIndexSkinnedPoint(cdMesh, pdwFaceCur, 0, pvMeshPoints, pvLinePoints, iCurPoint);

  00566	8d 4d 08	 lea	 ecx, DWORD PTR _iCurPoint$[ebp]
  00569	51		 push	 ecx
  0056a	ff 75 f4	 push	 DWORD PTR _pvLinePoints$[ebp]
  0056d	8b cb		 mov	 ecx, ebx
  0056f	ff 75 f0	 push	 DWORD PTR _pvMeshPoints$[ebp]
  00572	50		 push	 eax
  00573	57		 push	 edi
  00574	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _cdMesh$[ebp]
  0057a	50		 push	 eax
  0057b	e8 00 00 00 00	 call	 ?AppendIndexSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z ; CStripOutline::AppendIndexSkinnedPoint

; 656  :             else if (m_bSkinning)

  00580	eb 3a		 jmp	 SHORT $L56596
$L56593:
  00582	39 43 40	 cmp	 DWORD PTR [ebx+64], eax
  00585	74 1c		 je	 SHORT $L56595

; 657  :                 AppendSkinnedPoint(cdMesh, pdwFaceCur, 0, pvMeshPoints, pvLinePoints, iCurPoint);

  00587	8d 4d 08	 lea	 ecx, DWORD PTR _iCurPoint$[ebp]
  0058a	51		 push	 ecx
  0058b	ff 75 f4	 push	 DWORD PTR _pvLinePoints$[ebp]
  0058e	8b cb		 mov	 ecx, ebx
  00590	ff 75 f0	 push	 DWORD PTR _pvMeshPoints$[ebp]
  00593	50		 push	 eax
  00594	57		 push	 edi
  00595	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _cdMesh$[ebp]
  0059b	50		 push	 eax
  0059c	e8 00 00 00 00	 call	 ?AppendSkinnedPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIKPAE2AAI@Z ; CStripOutline::AppendSkinnedPoint

; 658  :             else

  005a1	eb 19		 jmp	 SHORT $L56596
$L56595:

; 659  :                 AppendPoint(cdMesh, pdwFaceCur, pvMeshPoints, pvLinePoints, iCurPoint);

  005a3	8d 45 08	 lea	 eax, DWORD PTR _iCurPoint$[ebp]
  005a6	50		 push	 eax
  005a7	ff 75 f4	 push	 DWORD PTR _pvLinePoints$[ebp]
  005aa	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _cdMesh$[ebp]
  005b0	ff 75 f0	 push	 DWORD PTR _pvMeshPoints$[ebp]
  005b3	8b cb		 mov	 ecx, ebx
  005b5	57		 push	 edi
  005b6	50		 push	 eax
  005b7	e8 00 00 00 00	 call	 ?AppendPoint@CStripOutline@@AAEXAAVCD3DXCrackDecl1@@PAIPAE2AAI@Z ; CStripOutline::AppendPoint
$L56596:

; 660  : 
; 661  :             iStripIndex += 1;

  005bc	83 45 e0 04	 add	 DWORD PTR tv1451[ebp], 4
  005c0	ff 45 fc	 inc	 DWORD PTR _iStripIndex$[ebp]

; 662  : 
; 663  :             pdwFacePrev = pdwFaceCur;

  005c3	8b f7		 mov	 esi, edi
  005c5	8b 7d e0	 mov	 edi, DWORD PTR tv1451[ebp]
  005c8	8b c7		 mov	 eax, edi
  005ca	83 38 ff	 cmp	 DWORD PTR [eax], -1
  005cd	0f 85 cf fe ff
	ff		 jne	 $L56578
$L57173:

; 601  :         goto e_Exit;
; 602  : 
; 603  : 
; 604  :     iStripIndex = 0;
; 605  :     iCurPoint = 0;
; 606  :     iCurLine = 0;
; 607  :     while (iStripIndex < iEndOfStrips)

  005d3	8b 45 ec	 mov	 eax, DWORD PTR _iEndOfStrips$[ebp]
  005d6	39 45 fc	 cmp	 DWORD PTR _iStripIndex$[ebp], eax
  005d9	0f 82 87 fe ff
	ff		 jb	 $L56573
  005df	33 ff		 xor	 edi, edi
$L57186:

; 664  :         }
; 665  :     }
; 666  :     // make sure that the points generated by walking the strips is
; 667  :     //   not greater than what is possible
; 668  :     GXASSERT(iCurPoint == cPointsMax);
; 669  :     GXASSERT(iCurLine == cConnections*2);
; 670  : 
; 671  :     m_cLines = iCurLine;

  005e1	8b 45 f8	 mov	 eax, DWORD PTR _iCurLine$[ebp]
  005e4	89 43 5c	 mov	 DWORD PTR [ebx+92], eax

; 672  :     m_cVertices = cPointsMax;

  005e7	8b 45 cc	 mov	 eax, DWORD PTR _cPointsMax$[ebp]
  005ea	89 43 60	 mov	 DWORD PTR [ebx+96], eax

; 673  : 
; 674  :     // create a vertex declaration, so that we can have D3DCOLOR instead of UBYTE4 for the matrix indices 
; 675  :     hr = D3DXDeclaratorFromFVF(m_cfvf.m_dwFVF, pDecl);

  005ed	8d 85 a8 fc ff
	ff		 lea	 eax, DWORD PTR _pDecl$[ebp]
  005f3	50		 push	 eax
  005f4	ff 33		 push	 DWORD PTR [ebx]
  005f6	e8 00 00 00 00	 call	 _D3DXDeclaratorFromFVF@8

; 676  :     if (FAILED(hr))

  005fb	3b c7		 cmp	 eax, edi
  005fd	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00600	7c 5c		 jl	 SHORT $e_Exit$56482

; 681  :     while (pDeclCur->Stream != 0xff)

  00602	66 81 bd a8 fc
	ff ff ff 00	 cmp	 WORD PTR _pDecl$[ebp], 255 ; 000000ffH
  0060b	74 1f		 je	 SHORT $L56607

; 677  :         goto e_Exit;
; 678  : 
; 679  :     // swap the type of any blendilndices to D3DCOLOR
; 680  :     pDeclCur = pDecl;

  0060d	8d 85 ac fc ff
	ff		 lea	 eax, DWORD PTR _pDecl$[ebp+4]
$L56603:

; 682  :     {
; 683  :         if ((pDeclCur->Usage == D3DDECLUSAGE_BLENDINDICES) || (pDeclCur->Type == D3DDECLTYPE_FLOAT1))

  00613	80 78 02 02	 cmp	 BYTE PTR [eax+2], 2
  00617	74 05		 je	 SHORT $L56606
  00619	80 38 00	 cmp	 BYTE PTR [eax], 0
  0061c	75 03		 jne	 SHORT $L56605
$L56606:

; 684  :         {
; 685  :             //pDeclCur->Type = D3DDECLTYPE_UBYTE4;
; 686  :             pDeclCur->Type = D3DDECLTYPE_D3DCOLOR;

  0061e	c6 00 04	 mov	 BYTE PTR [eax], 4
$L56605:

; 687  :         }
; 688  :         pDeclCur++;

  00621	83 c0 08	 add	 eax, 8
  00624	66 81 78 fc ff
	00		 cmp	 WORD PTR [eax-4], 255	; 000000ffH
  0062a	75 e7		 jne	 SHORT $L56603
$L56607:

; 689  :     }
; 690  : 
; 691  :     GXRELEASE(m_pDecl);

  0062c	8d 7b 50	 lea	 edi, DWORD PTR [ebx+80]
  0062f	8b 07		 mov	 eax, DWORD PTR [edi]
  00631	85 c0		 test	 eax, eax
  00633	74 09		 je	 SHORT $L56608
  00635	8b 08		 mov	 ecx, DWORD PTR [eax]
  00637	50		 push	 eax
  00638	ff 51 08	 call	 DWORD PTR [ecx+8]
  0063b	83 27 00	 and	 DWORD PTR [edi], 0
$L56608:

; 692  :     hr = pDevice->CreateVertexDeclaration(pDecl, &m_pDecl);

  0063e	8b 45 c4	 mov	 eax, DWORD PTR _pDevice$[ebp]
  00641	8b 08		 mov	 ecx, DWORD PTR [eax]
  00643	57		 push	 edi
  00644	8d 95 a8 fc ff
	ff		 lea	 edx, DWORD PTR _pDecl$[ebp]
  0064a	52		 push	 edx
  0064b	50		 push	 eax
  0064c	ff 91 58 01 00
	00		 call	 DWORD PTR [ecx+344]
  00652	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 693  :     if (FAILED(hr))
; 694  :         goto e_Exit;
; 695  : 
; 696  : e_Exit:

  00655	eb 07		 jmp	 SHORT $e_Exit$56482
$L56496:

; 412  :     {
; 413  :         hr = E_OUTOFMEMORY;

  00657	c7 45 fc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$e_Exit$56482:

; 697  :     // if a 16 bit mesh, then rgdwFaces is a temporary array
; 698  :     if (b16BitMesh)

  0065e	80 7d eb 00	 cmp	 BYTE PTR _b16BitMesh$[ebp], 0
  00662	74 0f		 je	 SHORT $L57184

; 699  :     {
; 700  :         delete []rgdwFaces;

  00664	ff 75 e4	 push	 DWORD PTR _rgdwFaces$[ebp]
  00667	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 701  : 
; 702  :         if (rgwFaces != NULL)

  0066c	83 7d bc 00	 cmp	 DWORD PTR _rgwFaces$[ebp], 0
  00670	59		 pop	 ecx

; 703  :         {
; 704  :             pibFaces->Unlock();
; 705  :         }
; 706  :     }
; 707  :     else

  00671	eb 04		 jmp	 SHORT $L57193
$L57184:

; 708  :     {
; 709  :         if (rgdwFaces != NULL)

  00673	83 7d e4 00	 cmp	 DWORD PTR _rgdwFaces$[ebp], 0
$L57193:
  00677	74 09		 je	 SHORT $L56619

; 710  :         {
; 711  :             pibFaces->Unlock();

  00679	8b 45 dc	 mov	 eax, DWORD PTR _pibFaces$[ebp]
  0067c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0067e	50		 push	 eax
  0067f	ff 51 30	 call	 DWORD PTR [ecx+48]
$L56619:

; 712  :         }
; 713  :     }
; 714  :     GXRELEASE(pibFaces);

  00682	8b 45 dc	 mov	 eax, DWORD PTR _pibFaces$[ebp]
  00685	33 f6		 xor	 esi, esi
  00687	3b c6		 cmp	 eax, esi
  00689	74 09		 je	 SHORT $L56620
  0068b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0068d	50		 push	 eax
  0068e	ff 51 08	 call	 DWORD PTR [ecx+8]
  00691	89 75 dc	 mov	 DWORD PTR _pibFaces$[ebp], esi
$L56620:

; 715  : 
; 716  :     if (pvMeshPoints)

  00694	39 75 f0	 cmp	 DWORD PTR _pvMeshPoints$[ebp], esi
  00697	74 09		 je	 SHORT $L56625

; 717  :     {
; 718  :         GXASSERT(pVBVertices != NULL);
; 719  :         pVBVertices->Unlock();

  00699	8b 45 d0	 mov	 eax, DWORD PTR _pVBVertices$[ebp]
  0069c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0069e	50		 push	 eax
  0069f	ff 51 30	 call	 DWORD PTR [ecx+48]
$L56625:

; 720  :     }
; 721  :     GXRELEASE(pVBVertices);

  006a2	8b 45 d0	 mov	 eax, DWORD PTR _pVBVertices$[ebp]
  006a5	3b c6		 cmp	 eax, esi
  006a7	74 09		 je	 SHORT $L56626
  006a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  006ab	50		 push	 eax
  006ac	ff 51 08	 call	 DWORD PTR [ecx+8]
  006af	89 75 d0	 mov	 DWORD PTR _pVBVertices$[ebp], esi
$L56626:

; 722  : 
; 723  :     delete []rgiStrips;

  006b2	ff 75 d8	 push	 DWORD PTR _rgiStrips$[ebp]
  006b5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 724  :     delete []rgaeAttributeTableMesh;

  006ba	ff 75 d4	 push	 DWORD PTR _rgaeAttributeTableMesh$[ebp]
  006bd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 725  : 
; 726  :     if (pvLinePoints != NULL)

  006c2	39 75 f4	 cmp	 DWORD PTR _pvLinePoints$[ebp], esi
  006c5	59		 pop	 ecx
  006c6	59		 pop	 ecx
  006c7	74 09		 je	 SHORT $L56631

; 727  :     {
; 728  :         m_pVertexBuffer->Unlock();

  006c9	8b 5b 4c	 mov	 ebx, DWORD PTR [ebx+76]
  006cc	8b 03		 mov	 eax, DWORD PTR [ebx]
  006ce	53		 push	 ebx
  006cf	ff 50 30	 call	 DWORD PTR [eax+48]
$L56631:

; 729  :         pvLinePoints = NULL;
; 730  :     }
; 731  : 
; 732  :     return hr;

  006d2	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  006d5	5f		 pop	 edi
  006d6	5e		 pop	 esi
  006d7	5b		 pop	 ebx

; 733  : }

  006d8	c9		 leave
  006d9	c2 04 00	 ret	 4
?Init@CStripOutline@@QAEJPAUID3DXBaseMesh@@@Z ENDP	; CStripOutline::Init
_TEXT	ENDS
END
