; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.4035 

	TITLE	.\filestrm.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ?SetSize@CFileStream@@UAGJT_ULARGE_INTEGER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyTo@CFileStream@@UAGJPAUIStream@@T_ULARGE_INTEGER@@PAT3@2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Commit@CFileStream@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Revert@CFileStream@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LockRegion@CFileStream@@UAGJT_ULARGE_INTEGER@@0K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnlockRegion@CFileStream@@UAGJT_ULARGE_INTEGER@@0K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CFileStream@@UAGJPAPAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFileStream@@QAE@PBDHHPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ISequentialStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFileStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CFileStream@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CFileStream@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFileStream@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CFileStream@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Read@CFileStream@@UAGJPAXKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Write@CFileStream@@UAGJPBXKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Seek@CFileStream@@UAGJT_LARGE_INTEGER@@KPAT_ULARGE_INTEGER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Stat@CFileStream@@UAGJPAUtagSTATSTG@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFileStream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	??0IUnknown@@QAE@XZ				; IUnknown::IUnknown
; Function compile flags: /Ogs
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT
??0IUnknown@@QAE@XZ PROC NEAR				; IUnknown::IUnknown, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0IUnknown@@QAE@XZ ENDP				; IUnknown::IUnknown
_TEXT	ENDS
PUBLIC	??1CFileStream@@QAE@XZ				; CFileStream::~CFileStream
PUBLIC	?AddRef@CFileStream@@UAGKXZ			; CFileStream::AddRef
PUBLIC	?Release@CFileStream@@UAGKXZ			; CFileStream::Release
PUBLIC	?QueryInterface@CFileStream@@UAGJABU_GUID@@PAPAX@Z ; CFileStream::QueryInterface
PUBLIC	?Read@CFileStream@@UAGJPAXKPAK@Z		; CFileStream::Read
PUBLIC	?Write@CFileStream@@UAGJPBXKPAK@Z		; CFileStream::Write
PUBLIC	?Seek@CFileStream@@UAGJT_LARGE_INTEGER@@KPAT_ULARGE_INTEGER@@@Z ; CFileStream::Seek
PUBLIC	?Stat@CFileStream@@UAGJPAUtagSTATSTG@@K@Z	; CFileStream::Stat
PUBLIC	?SetSize@CFileStream@@UAGJT_ULARGE_INTEGER@@@Z	; CFileStream::SetSize
PUBLIC	?CopyTo@CFileStream@@UAGJPAUIStream@@T_ULARGE_INTEGER@@PAT3@2@Z ; CFileStream::CopyTo
PUBLIC	?Commit@CFileStream@@UAGJK@Z			; CFileStream::Commit
PUBLIC	?Revert@CFileStream@@UAGJXZ			; CFileStream::Revert
PUBLIC	?LockRegion@CFileStream@@UAGJT_ULARGE_INTEGER@@0K@Z ; CFileStream::LockRegion
PUBLIC	?UnlockRegion@CFileStream@@UAGJT_ULARGE_INTEGER@@0K@Z ; CFileStream::UnlockRegion
PUBLIC	?Clone@CFileStream@@UAGJPAPAUIStream@@@Z	; CFileStream::Clone
PUBLIC	??_7CFileStream@@6B@				; CFileStream::`vftable'
EXTRN	__imp__CloseHandle@4:NEAR
;	COMDAT ??_7CFileStream@@6B@
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\filestrm.cpp
CONST	SEGMENT
??_7CFileStream@@6B@ DD FLAT:?QueryInterface@CFileStream@@UAGJABU_GUID@@PAPAX@Z ; CFileStream::`vftable'
	DD	FLAT:?AddRef@CFileStream@@UAGKXZ
	DD	FLAT:?Release@CFileStream@@UAGKXZ
	DD	FLAT:?Read@CFileStream@@UAGJPAXKPAK@Z
	DD	FLAT:?Write@CFileStream@@UAGJPBXKPAK@Z
	DD	FLAT:?Seek@CFileStream@@UAGJT_LARGE_INTEGER@@KPAT_ULARGE_INTEGER@@@Z
	DD	FLAT:?SetSize@CFileStream@@UAGJT_ULARGE_INTEGER@@@Z
	DD	FLAT:?CopyTo@CFileStream@@UAGJPAUIStream@@T_ULARGE_INTEGER@@PAT3@2@Z
	DD	FLAT:?Commit@CFileStream@@UAGJK@Z
	DD	FLAT:?Revert@CFileStream@@UAGJXZ
	DD	FLAT:?LockRegion@CFileStream@@UAGJT_ULARGE_INTEGER@@0K@Z
	DD	FLAT:?UnlockRegion@CFileStream@@UAGJT_ULARGE_INTEGER@@0K@Z
	DD	FLAT:?Stat@CFileStream@@UAGJPAUtagSTATSTG@@K@Z
	DD	FLAT:?Clone@CFileStream@@UAGJPAPAUIStream@@@Z
; Function compile flags: /Ogs
CONST	ENDS
;	COMDAT ??1CFileStream@@QAE@XZ
_TEXT	SEGMENT
??1CFileStream@@QAE@XZ PROC NEAR			; CFileStream::~CFileStream, COMDAT
; _this$ = ecx

; 38   : 	CloseHandle(m_hfile);

  00000	ff 71 08	 push	 DWORD PTR [ecx+8]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CFileStream@@6B@
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 39   : }

  0000f	c3		 ret	 0
??1CFileStream@@QAE@XZ ENDP				; CFileStream::~CFileStream
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\filestrm.h
_TEXT	ENDS
;	COMDAT ?SetSize@CFileStream@@UAGJT_ULARGE_INTEGER@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_libNewSize$ = 12					; size = 8
?SetSize@CFileStream@@UAGJT_ULARGE_INTEGER@@@Z PROC NEAR ; CFileStream::SetSize, COMDAT

; 44   :     STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize) {return E_NOTIMPL;}

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H
  00005	c2 0c 00	 ret	 12			; 0000000cH
?SetSize@CFileStream@@UAGJT_ULARGE_INTEGER@@@Z ENDP	; CFileStream::SetSize
; Function compile flags: /Ogs
_TEXT	ENDS
;	COMDAT ?CopyTo@CFileStream@@UAGJPAUIStream@@T_ULARGE_INTEGER@@PAT3@2@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pstm$ = 12						; size = 4
_cb$ = 16						; size = 8
_pcbRead$ = 24						; size = 4
_pcbWritten$ = 28					; size = 4
?CopyTo@CFileStream@@UAGJPAUIStream@@T_ULARGE_INTEGER@@PAT3@2@Z PROC NEAR ; CFileStream::CopyTo, COMDAT

; 45   :     STDMETHODIMP CopyTo(IStream __RPC_FAR *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER __RPC_FAR *pcbRead, ULARGE_INTEGER __RPC_FAR *pcbWritten) {return E_NOTIMPL;}

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H
  00005	c2 18 00	 ret	 24			; 00000018H
?CopyTo@CFileStream@@UAGJPAUIStream@@T_ULARGE_INTEGER@@PAT3@2@Z ENDP ; CFileStream::CopyTo
; Function compile flags: /Ogs
_TEXT	ENDS
;	COMDAT ?Commit@CFileStream@@UAGJK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_grfCommitFlags$ = 12					; size = 4
?Commit@CFileStream@@UAGJK@Z PROC NEAR			; CFileStream::Commit, COMDAT

; 46   :     STDMETHODIMP Commit(DWORD grfCommitFlags) {return E_NOTIMPL;}

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H
  00005	c2 08 00	 ret	 8
?Commit@CFileStream@@UAGJK@Z ENDP			; CFileStream::Commit
; Function compile flags: /Ogs
_TEXT	ENDS
;	COMDAT ?Revert@CFileStream@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Revert@CFileStream@@UAGJXZ PROC NEAR			; CFileStream::Revert, COMDAT

; 47   :     STDMETHODIMP Revert(void) {return E_NOTIMPL;}

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H
  00005	c2 04 00	 ret	 4
?Revert@CFileStream@@UAGJXZ ENDP			; CFileStream::Revert
; Function compile flags: /Ogs
_TEXT	ENDS
;	COMDAT ?LockRegion@CFileStream@@UAGJT_ULARGE_INTEGER@@0K@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_libOffset$ = 12					; size = 8
_cb$ = 20						; size = 8
_dwLockType$ = 28					; size = 4
?LockRegion@CFileStream@@UAGJT_ULARGE_INTEGER@@0K@Z PROC NEAR ; CFileStream::LockRegion, COMDAT

; 48   :     STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) {return E_NOTIMPL;}

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H
  00005	c2 18 00	 ret	 24			; 00000018H
?LockRegion@CFileStream@@UAGJT_ULARGE_INTEGER@@0K@Z ENDP ; CFileStream::LockRegion
; Function compile flags: /Ogs
_TEXT	ENDS
;	COMDAT ?UnlockRegion@CFileStream@@UAGJT_ULARGE_INTEGER@@0K@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_libOffset$ = 12					; size = 8
_cb$ = 20						; size = 8
_dwLockType$ = 28					; size = 4
?UnlockRegion@CFileStream@@UAGJT_ULARGE_INTEGER@@0K@Z PROC NEAR ; CFileStream::UnlockRegion, COMDAT

; 49   :     STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) {return E_NOTIMPL;}

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H
  00005	c2 18 00	 ret	 24			; 00000018H
?UnlockRegion@CFileStream@@UAGJT_ULARGE_INTEGER@@0K@Z ENDP ; CFileStream::UnlockRegion
; Function compile flags: /Ogs
_TEXT	ENDS
;	COMDAT ?Clone@CFileStream@@UAGJPAPAUIStream@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_ppstm$ = 12						; size = 4
?Clone@CFileStream@@UAGJPAPAUIStream@@@Z PROC NEAR	; CFileStream::Clone, COMDAT

; 50   :     STDMETHODIMP Clone(IStream __RPC_FAR *__RPC_FAR *ppstm) {return E_NOTIMPL;}

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H
  00005	c2 08 00	 ret	 8
?Clone@CFileStream@@UAGJPAPAUIStream@@@Z ENDP		; CFileStream::Clone
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\filestrm.cpp
_TEXT	ENDS
;	COMDAT ?AddRef@CFileStream@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@CFileStream@@UAGKXZ PROC NEAR			; CFileStream::AddRef, COMDAT

; 44   : }

  00000	8b ff		 npad	 2

; 42   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 43   : 	return m_cRef++;	

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000e	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 44   : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?AddRef@CFileStream@@UAGKXZ ENDP			; CFileStream::AddRef
_TEXT	ENDS
PUBLIC	_IsEqualGUID
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\guiddef.h
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_IsEqualGUID PROC NEAR					; COMDAT

; 162  : }

  00000	8b ff		 npad	 2

; 160  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00006	8b 75 08	 mov	 esi, DWORD PTR _rguid1$[ebp]
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR _rguid2$[ebp]
  0000d	6a 04		 push	 4
  0000f	59		 pop	 ecx
  00010	33 c0		 xor	 eax, eax
  00012	f3 a7		 repe cmpsd
  00014	5f		 pop	 edi
  00015	0f 94 c0	 sete	 al
  00018	5e		 pop	 esi

; 162  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
_IsEqualGUID ENDP
_TEXT	ENDS
PUBLIC	??_GCFileStream@@QAEPAXI@Z			; CFileStream::`scalar deleting destructor'
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogs
;	COMDAT ??_GCFileStream@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCFileStream@@QAEPAXI@Z PROC NEAR			; CFileStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??1CFileStream@@QAE@XZ	; CFileStream::~CFileStream
  0000d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00011	74 07		 je	 SHORT $L56328
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00019	59		 pop	 ecx
$L56328:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCFileStream@@QAEPAXI@Z ENDP				; CFileStream::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	_==
; Function compile flags: /Ogs
;	COMDAT _==
_TEXT	SEGMENT
_guidOne$ = 8						; size = 4
_guidOther$ = 12					; size = 4
_==	PROC NEAR					; COMDAT

; 195  : }

  00000	8b ff		 npad	 2

; 193  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 194  :     return IsEqualGUID(guidOne,guidOther);

  00006	8b 75 08	 mov	 esi, DWORD PTR _guidOne$[ebp]
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR _guidOther$[ebp]
  0000d	6a 04		 push	 4
  0000f	59		 pop	 ecx
  00010	33 c0		 xor	 eax, eax
  00012	f3 a7		 repe cmpsd
  00014	5f		 pop	 edi
  00015	0f 94 c0	 sete	 al
  00018	5e		 pop	 esi

; 195  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
_==	ENDP
_TEXT	ENDS
EXTRN	_IID_IStream:BYTE
EXTRN	_IID_IUnknown:BYTE
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\filestrm.cpp
;	COMDAT ?QueryInterface@CFileStream@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?QueryInterface@CFileStream@@UAGJABU_GUID@@PAPAX@Z PROC NEAR ; CFileStream::QueryInterface, COMDAT

; 67   : }

  00000	8b ff		 npad	 2

; 57   : {	

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 58   : 	*ppv=NULL;

  00005	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  00008	83 20 00	 and	 DWORD PTR [eax], 0
  0000b	56		 push	 esi

; 59   : 	if (riid == IID_IUnknown)

  0000c	8b 75 0c	 mov	 esi, DWORD PTR _riid$[ebp]
  0000f	57		 push	 edi
  00010	6a 04		 push	 4
  00012	59		 pop	 ecx
  00013	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_IID_IUnknown
  00018	33 d2		 xor	 edx, edx
  0001a	f3 a7		 repe cmpsd

; 60   : 		*ppv=(IUnknown*)this;
; 61   : 	else if (riid == IID_IStream)

  0001c	74 11		 je	 SHORT $L56481
  0001e	8b 75 0c	 mov	 esi, DWORD PTR _riid$[ebp]
  00021	6a 04		 push	 4
  00023	59		 pop	 ecx
  00024	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_IID_IStream
  00029	33 d2		 xor	 edx, edx
  0002b	f3 a7		 repe cmpsd
  0002d	75 0f		 jne	 SHORT $L56337
$L56481:

; 62   : 		*ppv=(IStream*)this;

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	89 08		 mov	 DWORD PTR [eax], ecx

; 65   : 	((LPUNKNOWN)*ppv)->AddRef();

  00034	8b 01		 mov	 eax, DWORD PTR [ecx]
  00036	51		 push	 ecx
  00037	ff 50 04	 call	 DWORD PTR [eax+4]

; 66   : 	return NOERROR;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 05		 jmp	 SHORT $L56333
$L56337:

; 63   : 	else
; 64   : 		return E_NOINTERFACE;

  0003e	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
$L56333:
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi

; 67   : }

  00045	5d		 pop	 ebp
  00046	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CFileStream@@UAGJABU_GUID@@PAPAX@Z ENDP	; CFileStream::QueryInterface
_TEXT	ENDS
EXTRN	__imp__ReadFile@20:NEAR
; Function compile flags: /Ogs
;	COMDAT ?Read@CFileStream@@UAGJPAXKPAK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pv$ = 12						; size = 4
_read$ = 16						; size = 4
_cb$ = 16						; size = 4
_pcbRead$ = 20						; size = 4
?Read@CFileStream@@UAGJPAXKPAK@Z PROC NEAR		; CFileStream::Read, COMDAT

; 77   : 		return S_OK;
; 78   : 	else
; 79   : 		return E_FAIL;
; 80   : }

  00000	8b ff		 npad	 2

; 71   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 72   : 	DWORD read;
; 73   : 	BOOL result = ReadFile(m_hfile, pv, cb, &read, NULL);

  00005	6a 00		 push	 0
  00007	8d 45 10	 lea	 eax, DWORD PTR _read$[ebp]
  0000a	50		 push	 eax
  0000b	ff 75 10	 push	 DWORD PTR _cb$[ebp]
  0000e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00011	ff 75 0c	 push	 DWORD PTR _pv$[ebp]
  00014	ff 70 08	 push	 DWORD PTR [eax+8]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20

; 74   : 	if (pcbRead)

  0001d	8b 4d 14	 mov	 ecx, DWORD PTR _pcbRead$[ebp]
  00020	85 c9		 test	 ecx, ecx
  00022	74 05		 je	 SHORT $L56350

; 75   : 		*pcbRead = read;

  00024	8b 55 10	 mov	 edx, DWORD PTR _read$[ebp]
  00027	89 11		 mov	 DWORD PTR [ecx], edx
$L56350:

; 76   : 	if (result)

  00029	f7 d8		 neg	 eax
  0002b	1b c0		 sbb	 eax, eax
  0002d	25 fb bf ff 7f	 and	 eax, 2147467259		; 7fffbffbH
  00032	05 05 40 00 80	 add	 eax, -2147467259	; 80004005H

; 77   : 		return S_OK;
; 78   : 	else
; 79   : 		return E_FAIL;
; 80   : }

  00037	5d		 pop	 ebp
  00038	c2 10 00	 ret	 16			; 00000010H
?Read@CFileStream@@UAGJPAXKPAK@Z ENDP			; CFileStream::Read
_TEXT	ENDS
EXTRN	__imp__WriteFile@20:NEAR
; Function compile flags: /Ogs
;	COMDAT ?Write@CFileStream@@UAGJPBXKPAK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pv$ = 12						; size = 4
_written$ = 16						; size = 4
_cb$ = 16						; size = 4
_pcbWritten$ = 20					; size = 4
?Write@CFileStream@@UAGJPBXKPAK@Z PROC NEAR		; CFileStream::Write, COMDAT

; 90   : 		return S_OK;
; 91   : 	else
; 92   : 		return E_FAIL;
; 93   : }

  00000	8b ff		 npad	 2

; 84   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 85   : 	DWORD written;
; 86   : 	BOOL result = WriteFile(m_hfile, pv, cb, &written, NULL);

  00005	6a 00		 push	 0
  00007	8d 45 10	 lea	 eax, DWORD PTR _written$[ebp]
  0000a	50		 push	 eax
  0000b	ff 75 10	 push	 DWORD PTR _cb$[ebp]
  0000e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00011	ff 75 0c	 push	 DWORD PTR _pv$[ebp]
  00014	ff 70 08	 push	 DWORD PTR [eax+8]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20

; 87   : 	if (pcbWritten)

  0001d	8b 4d 14	 mov	 ecx, DWORD PTR _pcbWritten$[ebp]
  00020	85 c9		 test	 ecx, ecx
  00022	74 05		 je	 SHORT $L56363

; 88   : 		*pcbWritten = written;

  00024	8b 55 10	 mov	 edx, DWORD PTR _written$[ebp]
  00027	89 11		 mov	 DWORD PTR [ecx], edx
$L56363:

; 89   : 	if (result)

  00029	f7 d8		 neg	 eax
  0002b	1b c0		 sbb	 eax, eax
  0002d	25 fb bf ff 7f	 and	 eax, 2147467259		; 7fffbffbH
  00032	05 05 40 00 80	 add	 eax, -2147467259	; 80004005H

; 90   : 		return S_OK;
; 91   : 	else
; 92   : 		return E_FAIL;
; 93   : }

  00037	5d		 pop	 ebp
  00038	c2 10 00	 ret	 16			; 00000010H
?Write@CFileStream@@UAGJPBXKPAK@Z ENDP			; CFileStream::Write
_TEXT	ENDS
EXTRN	__imp__SetFilePointer@16:NEAR
; Function compile flags: /Ogs
;	COMDAT ?Seek@CFileStream@@UAGJT_LARGE_INTEGER@@KPAT_ULARGE_INTEGER@@@Z
_TEXT	SEGMENT
_movehigh$ = -4						; size = 4
_this$ = 8						; size = 4
_dlibMove$ = 12						; size = 8
_dwOrigin$ = 20						; size = 4
_plibNewPosition$ = 24					; size = 4
?Seek@CFileStream@@UAGJT_LARGE_INTEGER@@KPAT_ULARGE_INTEGER@@@Z PROC NEAR ; CFileStream::Seek, COMDAT

; 126  : }

  00000	8b ff		 npad	 2

; 96   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 97   : 	LONG movelow;
; 98   : 	LONG movehigh;
; 99   : 
; 100  : 	movelow = dlibMove.LowPart;
; 101  : 	movehigh = dlibMove.HighPart;

  00006	8b 45 10	 mov	 eax, DWORD PTR _dlibMove$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR _movehigh$[ebp], eax

; 102  : 
; 103  : 	DWORD moveMethod;
; 104  : 	switch (dwOrigin)

  0000c	8b 45 14	 mov	 eax, DWORD PTR _dwOrigin$[ebp]
  0000f	83 e8 00	 sub	 eax, 0
  00012	74 17		 je	 SHORT $L56381
  00014	48		 dec	 eax
  00015	74 0f		 je	 SHORT $L56382
  00017	48		 dec	 eax
  00018	74 07		 je	 SHORT $L56383

; 109  : 	default: return E_INVALIDARG;

  0001a	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0001f	eb 3d		 jmp	 SHORT $L56389
$L56383:

; 108  : 	case STREAM_SEEK_END: moveMethod = FILE_END; break;

  00021	6a 02		 push	 2
  00023	58		 pop	 eax
  00024	eb 07		 jmp	 SHORT $L56378
$L56382:

; 107  : 	case STREAM_SEEK_CUR: moveMethod = FILE_CURRENT; break;

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	eb 02		 jmp	 SHORT $L56378
$L56381:

; 105  : 	{
; 106  : 	case STREAM_SEEK_SET: moveMethod = FILE_BEGIN; break;

  0002b	33 c0		 xor	 eax, eax
$L56378:

; 110  : 	}
; 111  : 
; 112  : 
; 113  : 
; 114  : 	DWORD result = SetFilePointer(m_hfile, movelow, &movehigh, moveMethod);

  0002d	50		 push	 eax
  0002e	8d 45 fc	 lea	 eax, DWORD PTR _movehigh$[ebp]
  00031	50		 push	 eax
  00032	ff 75 0c	 push	 DWORD PTR _dlibMove$[ebp]
  00035	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00038	ff 70 08	 push	 DWORD PTR [eax+8]
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16

; 115  : 
; 116  : 	if (plibNewPosition)

  00041	8b 4d 18	 mov	 ecx, DWORD PTR _plibNewPosition$[ebp]
  00044	85 c9		 test	 ecx, ecx
  00046	74 08		 je	 SHORT $L56387

; 117  : 	{
; 118  : 		plibNewPosition->LowPart = result;
; 119  : 		plibNewPosition->HighPart = movehigh;

  00048	8b 55 fc	 mov	 edx, DWORD PTR _movehigh$[ebp]
  0004b	89 01		 mov	 DWORD PTR [ecx], eax
  0004d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$L56387:

; 120  : 	}
; 121  : 
; 122  : 	if (result != -1)

  00050	83 f8 ff	 cmp	 eax, -1
  00053	74 04		 je	 SHORT $L56388

; 123  : 		return NOERROR;

  00055	33 c0		 xor	 eax, eax
  00057	eb 05		 jmp	 SHORT $L56389
$L56388:

; 124  : 	else
; 125  : 		return E_FAIL;

  00059	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$L56389:

; 126  : }

  0005e	c9		 leave
  0005f	c2 14 00	 ret	 20			; 00000014H
?Seek@CFileStream@@UAGJT_LARGE_INTEGER@@KPAT_ULARGE_INTEGER@@@Z ENDP ; CFileStream::Seek
_TEXT	ENDS
EXTRN	__imp__GetFileSize@8:NEAR
; Function compile flags: /Ogs
;	COMDAT ?Stat@CFileStream@@UAGJPAUtagSTATSTG@@K@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pstatstg$ = 12						; size = 4
_grfStatFlag$ = 16					; size = 4
?Stat@CFileStream@@UAGJPAUtagSTATSTG@@K@Z PROC NEAR	; CFileStream::Stat, COMDAT

; 139  : }

  00000	8b ff		 npad	 2

; 130  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 131  :     memset(pstatstg, 0, sizeof(STATSTG));

  00006	8b 75 0c	 mov	 esi, DWORD PTR _pstatstg$[ebp]
  00009	57		 push	 edi
  0000a	6a 12		 push	 18			; 00000012H
  0000c	33 c0		 xor	 eax, eax
  0000e	59		 pop	 ecx
  0000f	8b fe		 mov	 edi, esi
  00011	f3 ab		 rep stosd

; 132  : 
; 133  :     pstatstg->pwcsName = NULL; 

  00013	21 06		 and	 DWORD PTR [esi], eax

; 134  :     pstatstg->type = STGTY_STREAM; 
; 135  : 
; 136  :     pstatstg->cbSize.LowPart = GetFileSize(m_hfile, &pstatstg->cbSize.HighPart); 

  00015	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00018	50		 push	 eax
  00019	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 46 04 02 00
	00 00		 mov	 DWORD PTR [esi+4], 2
  00023	ff 70 08	 push	 DWORD PTR [eax+8]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSize@8
  0002c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002f	5f		 pop	 edi

; 137  : 
; 138  :     return S_OK;

  00030	33 c0		 xor	 eax, eax
  00032	5e		 pop	 esi

; 139  : }

  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
?Stat@CFileStream@@UAGJPAUtagSTATSTG@@K@Z ENDP		; CFileStream::Stat
_TEXT	ENDS
PUBLIC	??0ISequentialStream@@QAE@XZ			; ISequentialStream::ISequentialStream
; Function compile flags: /Ogs
;	COMDAT ??0ISequentialStream@@QAE@XZ
_TEXT	SEGMENT
??0ISequentialStream@@QAE@XZ PROC NEAR			; ISequentialStream::ISequentialStream, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0ISequentialStream@@QAE@XZ ENDP			; ISequentialStream::ISequentialStream
; Function compile flags: /Ogs
_TEXT	ENDS
;	COMDAT ?Release@CFileStream@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@CFileStream@@UAGKXZ PROC NEAR			; CFileStream::Release, COMDAT

; 53   : }

  00000	8b ff		 npad	 2

; 47   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 48   : 	if (--m_cRef != 0)	

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00008	ff 49 04	 dec	 DWORD PTR [ecx+4]
  0000b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 49   : 		return m_cRef;	

  0000e	75 09		 jne	 SHORT $L56321

; 50   : 	
; 51   : 	delete this;

  00010	6a 01		 push	 1
  00012	e8 00 00 00 00	 call	 ??_GCFileStream@@QAEPAXI@Z

; 52   : 	return 0;

  00017	33 c0		 xor	 eax, eax
$L56321:

; 53   : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?Release@CFileStream@@UAGKXZ ENDP			; CFileStream::Release
_TEXT	ENDS
PUBLIC	??0IStream@@QAE@XZ				; IStream::IStream
; Function compile flags: /Ogs
;	COMDAT ??0IStream@@QAE@XZ
_TEXT	SEGMENT
??0IStream@@QAE@XZ PROC NEAR				; IStream::IStream, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0IStream@@QAE@XZ ENDP					; IStream::IStream
_TEXT	ENDS
PUBLIC	??0CFileStream@@QAE@PBDHHPAJ@Z			; CFileStream::CFileStream
EXTRN	__imp__CreateFileA@28:NEAR
EXTRN	__imp__GetLastError@0:NEAR
; Function compile flags: /Ogs
;	COMDAT ??0CFileStream@@QAE@PBDHHPAJ@Z
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_bRead$ = 12						; size = 4
_bTruncate$ = 16					; size = 4
_error$ = 20						; size = 4
??0CFileStream@@QAE@PBDHHPAJ@Z PROC NEAR		; CFileStream::CFileStream, COMDAT
; _this$ = ecx

; 34   : }

  00000	8b ff		 npad	 2

; 21   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 22   :     m_hfile = CreateFile(filename, bRead ? GENERIC_READ : GENERIC_WRITE, 0, NULL, 
; 23   : 						  (bTruncate ? CREATE_ALWAYS : OPEN_EXISTING), FILE_ATTRIBUTE_NORMAL,
; 24   : 						  NULL);

  00005	8b 45 10	 mov	 eax, DWORD PTR _bTruncate$[ebp]
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _bRead$[ebp]
  0000f	6a 00		 push	 0
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	68 80 00 00 00	 push	 128			; 00000080H
  0001a	83 c0 03	 add	 eax, 3
  0001d	50		 push	 eax
  0001e	f7 d9		 neg	 ecx
  00020	1b c9		 sbb	 ecx, ecx
  00022	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
  00027	6a 00		 push	 0
  00029	23 c8		 and	 ecx, eax
  0002b	6a 00		 push	 0
  0002d	03 c8		 add	 ecx, eax
  0002f	51		 push	 ecx
  00030	ff 75 08	 push	 DWORD PTR _filename$[ebp]
  00033	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CFileStream@@6B@
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28

; 25   : 	if (error)

  0003f	8b 5d 14	 mov	 ebx, DWORD PTR _error$[ebp]
  00042	85 db		 test	 ebx, ebx
  00044	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00047	74 17		 je	 SHORT $L56304

; 26   : 	{
; 27   :         ULONG foo = GetLastError();

  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 28   : 		if (m_hfile == INVALID_HANDLE_VALUE)

  0004f	83 7e 08 ff	 cmp	 DWORD PTR [esi+8], -1
  00053	75 08		 jne	 SHORT $L56302

; 29   : 			*error = E_FAIL;

  00055	c7 03 05 40 00
	80		 mov	 DWORD PTR [ebx], -2147467259 ; 80004005H

; 30   : 		else

  0005b	eb 03		 jmp	 SHORT $L56304
$L56302:

; 31   : 			*error = NOERROR;

  0005d	83 23 00	 and	 DWORD PTR [ebx], 0
$L56304:

; 32   : 	}
; 33   : 	m_cRef = 1;

  00060	c7 46 04 01 00
	00 00		 mov	 DWORD PTR [esi+4], 1

; 34   : }

  00067	8b c6		 mov	 eax, esi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	5d		 pop	 ebp
  0006c	c2 10 00	 ret	 16			; 00000010H
??0CFileStream@@QAE@PBDHHPAJ@Z ENDP			; CFileStream::CFileStream
_TEXT	ENDS
END
