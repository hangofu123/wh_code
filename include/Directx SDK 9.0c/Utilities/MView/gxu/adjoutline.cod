; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.4035 

	TITLE	.\adjoutline.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04IHCGOIEL@mWd1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04KMALLLII@mWd2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LFBAIKMJ@mWd3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04PKFBBMAO@mWd4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04ODEKCNEP@mWd5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04MIGHHOIM@mWd6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04NBHMEPMN@mWd7?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04FGOEFDAC@mWd8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04EPPPGCED@mWd9?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DOMPIIAD@mWd10?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05CHNELJEC@mWd11?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MPJOKIB@mWd12?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05BFOCNLMA@mWd13?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05FKKDENAH@mWd14?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05EDLIHMEG@mWd15?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05GIJFCPIF@mWd16?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HBIOBOME@mWd17?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PGBGACAL@mWd18?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05OPANDDEK@mWd19?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DMIJDGFK@mWd20?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05CFJCAHBL@mWd21?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05OLPFENI@mWd22?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05BHKEGFJJ@mWd23?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05FIOFPDFO@mWd24?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05EBPOMCBP@mWd25?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05GKNDJBNM@mWd26?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HDMIKAJN@mWd27?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PEFALMFC@mWd28?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BEMIBDAE@mTot?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07HHMNENJH@mWorlds?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04JKCKMDGO@vClr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CAdjacencyOutline@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAdjacencyOutline@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendPoint@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIPAE2AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendMidpoint@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyWeights@@YAXPAMK0K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyIndexedWeights@@YAXPAMK0K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendPointSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendMidpointSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendPointIndexSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendMidpointIndexSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CAdjacencyOutline@@QAEJPAUID3DXBaseMesh@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@CAdjacencyOutline@@QAEJPAUIDirect3DDevice9@@KPAUID3DXEffect@@1KPAUD3DXMATRIX@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateEmptyOutline@CAdjacencyOutline@@AAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CD3DXCrackDecl1@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PxyzwGetTexCoord@DXCrackFVF@@QAEPAUD3DXVECTOR4@@PAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PfGetWeights@CD3DXCrackDecl1@@QAEPAMPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PfGetWeights@DXCrackFVF@@QAEPAMPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CWeights@DXCrackFVF@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetArrayElem@DXCrackFVF@@QAEPAEPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetArrayElem@CD3DXCrackDecl1@@QAEPAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CWeights@CD3DXCrackDecl1@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0DXCrackFVF@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04IHCGOIEL@mWd1?$AA@			; `string'
PUBLIC	??_C@_04KMALLLII@mWd2?$AA@			; `string'
PUBLIC	??_C@_04LFBAIKMJ@mWd3?$AA@			; `string'
PUBLIC	??_C@_04PKFBBMAO@mWd4?$AA@			; `string'
PUBLIC	??_C@_04ODEKCNEP@mWd5?$AA@			; `string'
PUBLIC	??_C@_04MIGHHOIM@mWd6?$AA@			; `string'
PUBLIC	??_C@_04NBHMEPMN@mWd7?$AA@			; `string'
PUBLIC	??_C@_04FGOEFDAC@mWd8?$AA@			; `string'
PUBLIC	??_C@_04EPPPGCED@mWd9?$AA@			; `string'
PUBLIC	??_C@_05DOMPIIAD@mWd10?$AA@			; `string'
PUBLIC	??_C@_05CHNELJEC@mWd11?$AA@			; `string'
PUBLIC	??_C@_05MPJOKIB@mWd12?$AA@			; `string'
PUBLIC	??_C@_05BFOCNLMA@mWd13?$AA@			; `string'
PUBLIC	??_C@_05FKKDENAH@mWd14?$AA@			; `string'
PUBLIC	??_C@_05EDLIHMEG@mWd15?$AA@			; `string'
PUBLIC	??_C@_05GIJFCPIF@mWd16?$AA@			; `string'
PUBLIC	??_C@_05HBIOBOME@mWd17?$AA@			; `string'
PUBLIC	??_C@_05PGBGACAL@mWd18?$AA@			; `string'
PUBLIC	??_C@_05OPANDDEK@mWd19?$AA@			; `string'
PUBLIC	??_C@_05DMIJDGFK@mWd20?$AA@			; `string'
PUBLIC	??_C@_05CFJCAHBL@mWd21?$AA@			; `string'
PUBLIC	??_C@_05OLPFENI@mWd22?$AA@			; `string'
PUBLIC	??_C@_05BHKEGFJJ@mWd23?$AA@			; `string'
PUBLIC	??_C@_05FIOFPDFO@mWd24?$AA@			; `string'
PUBLIC	??_C@_05EBPOMCBP@mWd25?$AA@			; `string'
PUBLIC	??_C@_05GKNDJBNM@mWd26?$AA@			; `string'
PUBLIC	??_C@_05HDMIKAJN@mWd27?$AA@			; `string'
PUBLIC	??_C@_05PEFALMFC@mWd28?$AA@			; `string'
;	COMDAT ??_C@_04IHCGOIEL@mWd1?$AA@
CONST	SEGMENT
??_C@_04IHCGOIEL@mWd1?$AA@ DB 'mWd1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KMALLLII@mWd2?$AA@
CONST	SEGMENT
??_C@_04KMALLLII@mWd2?$AA@ DB 'mWd2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LFBAIKMJ@mWd3?$AA@
CONST	SEGMENT
??_C@_04LFBAIKMJ@mWd3?$AA@ DB 'mWd3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PKFBBMAO@mWd4?$AA@
CONST	SEGMENT
??_C@_04PKFBBMAO@mWd4?$AA@ DB 'mWd4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ODEKCNEP@mWd5?$AA@
CONST	SEGMENT
??_C@_04ODEKCNEP@mWd5?$AA@ DB 'mWd5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MIGHHOIM@mWd6?$AA@
CONST	SEGMENT
??_C@_04MIGHHOIM@mWd6?$AA@ DB 'mWd6', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NBHMEPMN@mWd7?$AA@
CONST	SEGMENT
??_C@_04NBHMEPMN@mWd7?$AA@ DB 'mWd7', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FGOEFDAC@mWd8?$AA@
CONST	SEGMENT
??_C@_04FGOEFDAC@mWd8?$AA@ DB 'mWd8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EPPPGCED@mWd9?$AA@
CONST	SEGMENT
??_C@_04EPPPGCED@mWd9?$AA@ DB 'mWd9', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DOMPIIAD@mWd10?$AA@
CONST	SEGMENT
??_C@_05DOMPIIAD@mWd10?$AA@ DB 'mWd10', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CHNELJEC@mWd11?$AA@
CONST	SEGMENT
??_C@_05CHNELJEC@mWd11?$AA@ DB 'mWd11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPJOKIB@mWd12?$AA@
CONST	SEGMENT
??_C@_05MPJOKIB@mWd12?$AA@ DB 'mWd12', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BFOCNLMA@mWd13?$AA@
CONST	SEGMENT
??_C@_05BFOCNLMA@mWd13?$AA@ DB 'mWd13', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKKDENAH@mWd14?$AA@
CONST	SEGMENT
??_C@_05FKKDENAH@mWd14?$AA@ DB 'mWd14', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EDLIHMEG@mWd15?$AA@
CONST	SEGMENT
??_C@_05EDLIHMEG@mWd15?$AA@ DB 'mWd15', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GIJFCPIF@mWd16?$AA@
CONST	SEGMENT
??_C@_05GIJFCPIF@mWd16?$AA@ DB 'mWd16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HBIOBOME@mWd17?$AA@
CONST	SEGMENT
??_C@_05HBIOBOME@mWd17?$AA@ DB 'mWd17', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PGBGACAL@mWd18?$AA@
CONST	SEGMENT
??_C@_05PGBGACAL@mWd18?$AA@ DB 'mWd18', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OPANDDEK@mWd19?$AA@
CONST	SEGMENT
??_C@_05OPANDDEK@mWd19?$AA@ DB 'mWd19', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DMIJDGFK@mWd20?$AA@
CONST	SEGMENT
??_C@_05DMIJDGFK@mWd20?$AA@ DB 'mWd20', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFJCAHBL@mWd21?$AA@
CONST	SEGMENT
??_C@_05CFJCAHBL@mWd21?$AA@ DB 'mWd21', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OLPFENI@mWd22?$AA@
CONST	SEGMENT
??_C@_05OLPFENI@mWd22?$AA@ DB 'mWd22', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BHKEGFJJ@mWd23?$AA@
CONST	SEGMENT
??_C@_05BHKEGFJJ@mWd23?$AA@ DB 'mWd23', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FIOFPDFO@mWd24?$AA@
CONST	SEGMENT
??_C@_05FIOFPDFO@mWd24?$AA@ DB 'mWd24', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EBPOMCBP@mWd25?$AA@
CONST	SEGMENT
??_C@_05EBPOMCBP@mWd25?$AA@ DB 'mWd25', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GKNDJBNM@mWd26?$AA@
CONST	SEGMENT
??_C@_05GKNDJBNM@mWd26?$AA@ DB 'mWd26', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDMIKAJN@mWd27?$AA@
CONST	SEGMENT
??_C@_05HDMIKAJN@mWd27?$AA@ DB 'mWd27', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PEFALMFC@mWd28?$AA@
CONST	SEGMENT
??_C@_05PEFALMFC@mWd28?$AA@ DB 'mWd28', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_x_rgszMatrix DD FLAT:??_C@_04IHCGOIEL@mWd1?$AA@
	DD	FLAT:??_C@_04KMALLLII@mWd2?$AA@
	DD	FLAT:??_C@_04LFBAIKMJ@mWd3?$AA@
	DD	FLAT:??_C@_04PKFBBMAO@mWd4?$AA@
	DD	FLAT:??_C@_04ODEKCNEP@mWd5?$AA@
	DD	FLAT:??_C@_04MIGHHOIM@mWd6?$AA@
	DD	FLAT:??_C@_04NBHMEPMN@mWd7?$AA@
	DD	FLAT:??_C@_04FGOEFDAC@mWd8?$AA@
	DD	FLAT:??_C@_04EPPPGCED@mWd9?$AA@
	DD	FLAT:??_C@_05DOMPIIAD@mWd10?$AA@
	DD	FLAT:??_C@_05CHNELJEC@mWd11?$AA@
	DD	FLAT:??_C@_05MPJOKIB@mWd12?$AA@
	DD	FLAT:??_C@_05BFOCNLMA@mWd13?$AA@
	DD	FLAT:??_C@_05FKKDENAH@mWd14?$AA@
	DD	FLAT:??_C@_05EDLIHMEG@mWd15?$AA@
	DD	FLAT:??_C@_05GIJFCPIF@mWd16?$AA@
	DD	FLAT:??_C@_05HBIOBOME@mWd17?$AA@
	DD	FLAT:??_C@_05PGBGACAL@mWd18?$AA@
	DD	FLAT:??_C@_05OPANDDEK@mWd19?$AA@
	DD	FLAT:??_C@_05DMIJDGFK@mWd20?$AA@
	DD	FLAT:??_C@_05CFJCAHBL@mWd21?$AA@
	DD	FLAT:??_C@_05OLPFENI@mWd22?$AA@
	DD	FLAT:??_C@_05BHKEGFJJ@mWd23?$AA@
	DD	FLAT:??_C@_05FIOFPDFO@mWd24?$AA@
	DD	FLAT:??_C@_05EBPOMCBP@mWd25?$AA@
	DD	FLAT:??_C@_05GKNDJBNM@mWd26?$AA@
	DD	FLAT:??_C@_05HDMIKAJN@mWd27?$AA@
	DD	FLAT:??_C@_05PEFALMFC@mWd28?$AA@
_DATA	ENDS
CONST	SEGMENT
_x_rgdwTexCoordSize DD 08H
	DD	0cH
	DD	010H
	DD	04H
CONST	ENDS
PUBLIC	??1CAdjacencyOutline@@QAE@XZ			; CAdjacencyOutline::~CAdjacencyOutline
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\adjoutline.cpp
;	COMDAT ??1CAdjacencyOutline@@QAE@XZ
_TEXT	SEGMENT
??1CAdjacencyOutline@@QAE@XZ PROC NEAR			; CAdjacencyOutline::~CAdjacencyOutline, COMDAT
; _this$ = ecx

; 46   : }

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 41   : {

  00003	8b f1		 mov	 esi, ecx

; 42   :     delete m_rgaeAttributeTable;

  00005	ff 76 54	 push	 DWORD PTR [esi+84]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 43   : 
; 44   :     GXRELEASE(m_pVertexBuffer);

  0000d	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00010	85 c0		 test	 eax, eax
  00012	59		 pop	 ecx
  00013	74 0a		 je	 SHORT $L56373
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	50		 push	 eax
  00018	ff 51 08	 call	 DWORD PTR [ecx+8]
  0001b	83 66 4c 00	 and	 DWORD PTR [esi+76], 0
$L56373:

; 45   :     GXRELEASE(m_pDecl);

  0001f	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  00022	85 c0		 test	 eax, eax
  00024	74 0a		 je	 SHORT $L56377
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	50		 push	 eax
  00029	ff 51 08	 call	 DWORD PTR [ecx+8]
  0002c	83 66 50 00	 and	 DWORD PTR [esi+80], 0
$L56377:
  00030	5e		 pop	 esi

; 46   : }

  00031	c3		 ret	 0
??1CAdjacencyOutline@@QAE@XZ ENDP			; CAdjacencyOutline::~CAdjacencyOutline
_TEXT	ENDS
PUBLIC	?CopyWeights@@YAXPAMK0K@Z			; CopyWeights
EXTRN	__fltused:NEAR
; Function compile flags: /Ogs
;	COMDAT ?CopyWeights@@YAXPAMK0K@Z
_TEXT	SEGMENT
_pfWeightSrc$ = 8					; size = 4
_cWeightsSrc$ = 12					; size = 4
_pfWeightDest$ = 16					; size = 4
_cWeightsDest$ = 20					; size = 4
?CopyWeights@@YAXPAMK0K@Z PROC NEAR			; CopyWeights, COMDAT

; 164  :     {
; 165  :         pfWeightDest[iWeight] = 0.0f;
; 166  :     }
; 167  : }

  00000	8b ff		 npad	 2

; 140  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 141  :     float fSum;
; 142  :     DWORD iWeight;
; 143  :     float fWeight;
; 144  : 
; 145  :     // there should always be more dest weights than source
; 146  :     GXASSERT(cWeightsSrc < cWeightsDest);
; 147  : 
; 148  :     // first copy the weights that exist in the source
; 149  :     fSum = 0.0f;
; 150  :     for (iWeight = 0; iWeight < cWeightsSrc; iWeight++)

  00005	8b 55 10	 mov	 edx, DWORD PTR _pfWeightDest$[ebp]
  00008	d9 ee		 fldz
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR _cWeightsSrc$[ebp]
  0000e	33 c0		 xor	 eax, eax
  00010	85 ff		 test	 edi, edi
  00012	76 1a		 jbe	 SHORT $L56445
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pfWeightSrc$[ebp]
  00017	56		 push	 esi
  00018	8b f2		 mov	 esi, edx
  0001a	2b ca		 sub	 ecx, edx
  0001c	8b c7		 mov	 eax, edi
$L56443:

; 151  :     {
; 152  :         fWeight = pfWeightSrc[iWeight];

  0001e	d9 04 31	 fld	 DWORD PTR [ecx+esi]

; 153  :         fSum += fWeight;

  00021	d9 c0		 fld	 ST(0)
  00023	de c2		 faddp	 ST(2), ST(0)

; 154  : 
; 155  :         pfWeightDest[iWeight] = fWeight;

  00025	d9 1e		 fstp	 DWORD PTR [esi]
  00027	83 c6 04	 add	 esi, 4
  0002a	4f		 dec	 edi
  0002b	75 f1		 jne	 SHORT $L56443
  0002d	5e		 pop	 esi
$L56445:

; 156  :     }
; 157  : 
; 158  :     // now set the implied weight - always exists in dest
; 159  :     pfWeightDest[iWeight] = 1.0f - fSum;
; 160  :     iWeight += 1;
; 161  : 
; 162  :     // set any other weights that are unused to 0.0f
; 163  :     for (; iWeight < cWeightsDest; iWeight++)

  0002e	8b 4d 14	 mov	 ecx, DWORD PTR _cWeightsDest$[ebp]
  00031	d9 e8		 fld1
  00033	d8 e1		 fsub	 ST(0), ST(1)
  00035	d9 1c 82	 fstp	 DWORD PTR [edx+eax*4]
  00038	40		 inc	 eax
  00039	3b c1		 cmp	 eax, ecx
  0003b	dd d8		 fstp	 ST(0)
  0003d	73 09		 jae	 SHORT $L56446
  0003f	8d 3c 82	 lea	 edi, DWORD PTR [edx+eax*4]
  00042	2b c8		 sub	 ecx, eax
  00044	33 c0		 xor	 eax, eax
  00046	f3 ab		 rep stosd
$L56446:
  00048	5f		 pop	 edi

; 164  :     {
; 165  :         pfWeightDest[iWeight] = 0.0f;
; 166  :     }
; 167  : }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?CopyWeights@@YAXPAMK0K@Z ENDP				; CopyWeights
_TEXT	ENDS
PUBLIC	?CopyIndexedWeights@@YAXPAMK0K@Z		; CopyIndexedWeights
; Function compile flags: /Ogs
;	COMDAT ?CopyIndexedWeights@@YAXPAMK0K@Z
_TEXT	SEGMENT
_pfWeightSrc$ = 8					; size = 4
_cWeightsSrc$ = 12					; size = 4
_pfWeightDest$ = 16					; size = 4
_cWeightsDest$ = 20					; size = 4
?CopyIndexedWeights@@YAXPAMK0K@Z PROC NEAR		; CopyIndexedWeights, COMDAT

; 206  : }

  00000	8b ff		 npad	 2

; 176  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 177  :     float fSum;
; 178  :     DWORD iWeight;
; 179  :     float fWeight;
; 180  : 
; 181  :     // there should always be more dest weights than source
; 182  :     GXASSERT(cWeightsSrc < cWeightsDest);
; 183  : 
; 184  :     // first copy the weights that exist in the source
; 185  :     fSum = 0.0f;
; 186  :     for (iWeight = 0; iWeight < cWeightsSrc - 1; iWeight++)

  00005	8b 55 10	 mov	 edx, DWORD PTR _pfWeightDest$[ebp]
  00008	d9 ee		 fldz
  0000a	53		 push	 ebx
  0000b	8b 5d 0c	 mov	 ebx, DWORD PTR _cWeightsSrc$[ebp]
  0000e	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
  00011	56		 push	 esi
  00012	33 c0		 xor	 eax, eax
  00014	85 c9		 test	 ecx, ecx
  00016	57		 push	 edi
  00017	76 18		 jbe	 SHORT $L56461
  00019	8b 7d 08	 mov	 edi, DWORD PTR _pfWeightSrc$[ebp]
  0001c	8b f2		 mov	 esi, edx
  0001e	2b fa		 sub	 edi, edx
  00020	8b c1		 mov	 eax, ecx
$L56459:

; 187  :     {
; 188  :         fWeight = pfWeightSrc[iWeight];

  00022	d9 04 37	 fld	 DWORD PTR [edi+esi]

; 189  :         fSum += fWeight;

  00025	d9 c0		 fld	 ST(0)
  00027	de c2		 faddp	 ST(2), ST(0)

; 190  : 
; 191  :         pfWeightDest[iWeight] = fWeight;

  00029	d9 1e		 fstp	 DWORD PTR [esi]
  0002b	83 c6 04	 add	 esi, 4
  0002e	49		 dec	 ecx
  0002f	75 f1		 jne	 SHORT $L56459
$L56461:

; 192  :     }
; 193  : 
; 194  :     // now set the implied weight - always exists in dest
; 195  :     pfWeightDest[iWeight] = 1.0f - fSum;
; 196  :     iWeight += 1;
; 197  : 
; 198  :     // set any other weights that are unused to 0.0f
; 199  :     for (; iWeight < cWeightsDest - 1; iWeight++)

  00031	8b 75 14	 mov	 esi, DWORD PTR _cWeightsDest$[ebp]
  00034	d9 e8		 fld1
  00036	d8 e1		 fsub	 ST(0), ST(1)
  00038	8d 4e ff	 lea	 ecx, DWORD PTR [esi-1]
  0003b	d9 1c 82	 fstp	 DWORD PTR [edx+eax*4]
  0003e	40		 inc	 eax
  0003f	3b c1		 cmp	 eax, ecx
  00041	dd d8		 fstp	 ST(0)
  00043	73 09		 jae	 SHORT $L56462
  00045	8d 3c 82	 lea	 edi, DWORD PTR [edx+eax*4]
  00048	2b c8		 sub	 ecx, eax
  0004a	33 c0		 xor	 eax, eax
  0004c	f3 ab		 rep stosd
$L56462:

; 200  :     {
; 201  :         pfWeightDest[iWeight] = 0.0f;
; 202  :     }
; 203  : 
; 204  :     // copy the indices straight from one to the other
; 205  :     memcpy(&pfWeightDest[cWeightsDest-1], &pfWeightSrc[cWeightsSrc-1], sizeof(DWORD));

  0004e	8b 45 08	 mov	 eax, DWORD PTR _pfWeightSrc$[ebp]
  00051	8b 44 98 fc	 mov	 eax, DWORD PTR [eax+ebx*4-4]
  00055	5f		 pop	 edi
  00056	89 44 b2 fc	 mov	 DWORD PTR [edx+esi*4-4], eax
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx

; 206  : }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?CopyIndexedWeights@@YAXPAMK0K@Z ENDP			; CopyIndexedWeights
_TEXT	ENDS
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC NEAR				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 315  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 308  : }

  00000	8b ff		 npad	 2

; 304  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx

; 305  :     x = fx;

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _fx$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 306  :     y = fy;

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _fy$[ebp]
  0000f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 307  :     z = fz;

  00012	8b 4d 10	 mov	 ecx, DWORD PTR _fz$[ebp]
  00015	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 308  : }

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	?CreateEmptyOutline@CAdjacencyOutline@@AAEJXZ	; CAdjacencyOutline::CreateEmptyOutline
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\adjoutline.cpp
;	COMDAT ?CreateEmptyOutline@CAdjacencyOutline@@AAEJXZ
_TEXT	SEGMENT
?CreateEmptyOutline@CAdjacencyOutline@@AAEJXZ PROC NEAR	; CAdjacencyOutline::CreateEmptyOutline, COMDAT
; _this$ = ecx

; 835  : }

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 827  : {

  00003	8b f1		 mov	 esi, ecx

; 828  :     GXRELEASE(m_pVertexBuffer);

  00005	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00008	85 c0		 test	 eax, eax
  0000a	74 0a		 je	 SHORT $L56774
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	50		 push	 eax
  0000f	ff 51 08	 call	 DWORD PTR [ecx+8]
  00012	83 66 4c 00	 and	 DWORD PTR [esi+76], 0
$L56774:

; 829  :     delete []m_rgaeAttributeTable;

  00016	ff 76 54	 push	 DWORD PTR [esi+84]
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 830  :     m_rgaeAttributeTable = NULL;

  0001e	83 66 54 00	 and	 DWORD PTR [esi+84], 0

; 831  : 
; 832  :     m_caeAttributeTable = 0;

  00022	83 66 58 00	 and	 DWORD PTR [esi+88], 0
  00026	59		 pop	 ecx

; 833  : 
; 834  :     return S_OK;

  00027	33 c0		 xor	 eax, eax
  00029	5e		 pop	 esi

; 835  : }

  0002a	c3		 ret	 0
?CreateEmptyOutline@CAdjacencyOutline@@AAEJXZ ENDP	; CAdjacencyOutline::CreateEmptyOutline
_TEXT	ENDS
PUBLIC	__real@3b808081
PUBLIC	??0D3DXCOLOR@@QAE@K@Z				; D3DXCOLOR::D3DXCOLOR
;	COMDAT __real@3b808081
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.inl
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
; Function compile flags: /Ogs
CONST	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@K@Z
_TEXT	SEGMENT
tv186 = 8						; size = 4
tv185 = 8						; size = 4
tv184 = 8						; size = 4
tv183 = 8						; size = 4
_dw$ = 8						; size = 4
??0D3DXCOLOR@@QAE@K@Z PROC NEAR				; D3DXCOLOR::D3DXCOLOR, COMDAT
; _this$ = ecx

; 1352 : }

  00000	8b ff		 npad	 2

; 1346 : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 1347 :     CONST FLOAT f = 1.0f / 255.0f;
; 1348 :     r = f * (FLOAT) (unsigned char) (dw >> 16);

  00005	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3b808081
  0000b	8b c1		 mov	 eax, ecx
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _dw$[ebp]
  00010	8b d1		 mov	 edx, ecx
  00012	c1 ea 10	 shr	 edx, 16			; 00000010H
  00015	0f b6 d2	 movzx	 edx, dl
  00018	89 55 08	 mov	 DWORD PTR tv186[ebp], edx

; 1349 :     g = f * (FLOAT) (unsigned char) (dw >>  8);

  0001b	8b d1		 mov	 edx, ecx
  0001d	c1 ea 08	 shr	 edx, 8
  00020	db 45 08	 fild	 DWORD PTR tv186[ebp]
  00023	0f b6 d2	 movzx	 edx, dl
  00026	d8 c9		 fmul	 ST(0), ST(1)
  00028	89 55 08	 mov	 DWORD PTR tv185[ebp], edx

; 1350 :     b = f * (FLOAT) (unsigned char) (dw >>  0);

  0002b	0f b6 d1	 movzx	 edx, cl
  0002e	d9 18		 fstp	 DWORD PTR [eax]
  00030	db 45 08	 fild	 DWORD PTR tv185[ebp]
  00033	89 55 08	 mov	 DWORD PTR tv184[ebp], edx

; 1351 :     a = f * (FLOAT) (unsigned char) (dw >> 24);

  00036	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00039	d8 c9		 fmul	 ST(0), ST(1)
  0003b	d9 58 04	 fstp	 DWORD PTR [eax+4]
  0003e	db 45 08	 fild	 DWORD PTR tv184[ebp]
  00041	89 4d 08	 mov	 DWORD PTR tv183[ebp], ecx
  00044	d8 c9		 fmul	 ST(0), ST(1)
  00046	d9 58 08	 fstp	 DWORD PTR [eax+8]
  00049	db 45 08	 fild	 DWORD PTR tv183[ebp]
  0004c	d8 c9		 fmul	 ST(0), ST(1)
  0004e	d9 58 0c	 fstp	 DWORD PTR [eax+12]
  00051	dd d8		 fstp	 ST(0)

; 1352 : }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
??0D3DXCOLOR@@QAE@K@Z ENDP				; D3DXCOLOR::D3DXCOLOR
_TEXT	ENDS
PUBLIC	?CWeights@DXCrackFVF@@QAEKXZ			; DXCrackFVF::CWeights
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\gxcrackfvf.h
;	COMDAT ?CWeights@DXCrackFVF@@QAEKXZ
_TEXT	SEGMENT
?CWeights@DXCrackFVF@@QAEKXZ PROC NEAR			; DXCrackFVF::CWeights, COMDAT
; _this$ = ecx

; 76   :     inline DWORD        CWeights()      { return m_cWeights; }

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	c3		 ret	 0
?CWeights@DXCrackFVF@@QAEKXZ ENDP			; DXCrackFVF::CWeights
_TEXT	ENDS
PUBLIC	??0DXCrackFVF@@QAE@K@Z				; DXCrackFVF::DXCrackFVF
; Function compile flags: /Ogs
;	COMDAT ??0DXCrackFVF@@QAE@K@Z
_TEXT	SEGMENT
_dwFVF$ = 8						; size = 4
??0DXCrackFVF@@QAE@K@Z PROC NEAR			; DXCrackFVF::DXCrackFVF, COMDAT
; _this$ = ecx

; 192  : }

  00000	8b ff		 npad	 2

; 115  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b c1		 mov	 eax, ecx
  00007	53		 push	 ebx
  00008	8b 5d 08	 mov	 ebx, DWORD PTR _dwFVF$[ebp]
  0000b	56		 push	 esi

; 116  :     DWORD oCur = 0;
; 117  :     DWORD dwPosition;
; 118  :     DWORD dwTexCoordInfo;
; 119  :     DWORD iTexCoord;
; 120  :     DWORD dwTexCoordSize;
; 121  :     m_oTex[0] = 0;
; 122  : 
; 123  :     dwPosition = dwFVF & D3DFVF_POSITION_MASK;

  0000c	8b d3		 mov	 edx, ebx
  0000e	57		 push	 edi
  0000f	33 ff		 xor	 edi, edi
  00011	81 e2 0e 40 00
	00		 and	 edx, 16398		; 0000400eH
  00017	33 c9		 xor	 ecx, ecx

; 124  : 
; 125  :     if (dwPosition == D3DFVF_XYZ)

  00019	83 fa 02	 cmp	 edx, 2
  0001c	8d 70 18	 lea	 esi, DWORD PTR [eax+24]
  0001f	89 18		 mov	 DWORD PTR [eax], ebx
  00021	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00024	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00027	89 78 10	 mov	 DWORD PTR [eax+16], edi
  0002a	89 78 14	 mov	 DWORD PTR [eax+20], edi
  0002d	89 78 38	 mov	 DWORD PTR [eax+56], edi
  00030	89 78 3c	 mov	 DWORD PTR [eax+60], edi
  00033	89 3e		 mov	 DWORD PTR [esi], edi
  00035	75 05		 jne	 SHORT $L55537

; 126  :     {
; 127  :         oCur += 3 * sizeof(float);

  00037	6a 0c		 push	 12			; 0000000cH
$L56878:
  00039	59		 pop	 ecx

; 128  :     }
; 129  :     else if (dwPosition == D3DFVF_XYZRHW)

  0003a	eb 1d		 jmp	 SHORT $L56875
$L55537:
  0003c	83 fa 04	 cmp	 edx, 4
  0003f	75 04		 jne	 SHORT $L55540

; 130  :     {
; 131  :         oCur += 4 * sizeof(float);

  00041	6a 10		 push	 16			; 00000010H

; 132  :     }
; 133  :     else if (dwPosition >= D3DFVF_XYZB1)

  00043	eb f4		 jmp	 SHORT $L56878
$L55540:
  00045	83 fa 06	 cmp	 edx, 6
  00048	72 0f		 jb	 SHORT $L56875

; 134  :     {
; 135  :         m_cWeights = (dwPosition >> 1) - 2;

  0004a	d1 ea		 shr	 edx, 1
  0004c	8d 4a fe	 lea	 ecx, DWORD PTR [edx-2]
  0004f	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 136  :         oCur += (3 + m_cWeights) * sizeof(float);

  00052	8d 0c 8d 0c 00
	00 00		 lea	 ecx, DWORD PTR [ecx*4+12]
$L56875:

; 137  :     }
; 138  : 
; 139  :     if ( dwFVF & D3DFVF_NORMAL )

  00059	f6 c3 10	 test	 bl, 16			; 00000010H
  0005c	74 06		 je	 SHORT $L55545

; 140  :     {
; 141  :         m_oNormal = oCur;

  0005e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 142  :         oCur += 3 * sizeof(float);

  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
$L55545:

; 143  :     }
; 144  : 
; 145  :     if ( dwFVF & D3DFVF_PSIZE )

  00064	f6 c3 20	 test	 bl, 32			; 00000020H
  00067	74 06		 je	 SHORT $L56876

; 146  :     {
; 147  :         m_oPointSize = oCur;

  00069	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 148  :         oCur += sizeof(float);

  0006c	83 c1 04	 add	 ecx, 4
$L56876:

; 149  :     }
; 150  : 
; 151  :     if ( dwFVF & D3DFVF_DIFFUSE )

  0006f	f6 c3 40	 test	 bl, 64			; 00000040H
  00072	74 06		 je	 SHORT $L56877

; 152  :     {
; 153  :         m_oDiffuse = oCur;

  00074	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 154  :         oCur += sizeof(D3DCOLOR);

  00077	83 c1 04	 add	 ecx, 4
$L56877:

; 155  :     }
; 156  : 
; 157  :     if ( dwFVF & D3DFVF_SPECULAR )

  0007a	84 db		 test	 bl, bl
  0007c	79 06		 jns	 SHORT $L55551

; 158  :     {
; 159  :         m_oSpecular = oCur;

  0007e	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 160  :         oCur += sizeof(D3DCOLOR);

  00081	83 c1 04	 add	 ecx, 4
$L55551:

; 161  :     }
; 162  : 
; 163  :     if ( dwFVF & D3DFVF_TEXCOUNT_MASK )

  00084	f6 c7 0f	 test	 bh, 15			; 0000000fH
  00087	74 3d		 je	 SHORT $L55557

; 164  :     {
; 165  :         m_oTex[0] = oCur;
; 166  : 
; 167  :         // only one tu/tv set currently supported
; 168  : 
; 169  :         m_cTexCoords = ((dwFVF & D3DFVF_TEXCOUNT_MASK)>>D3DFVF_TEXCOUNT_SHIFT);

  00089	8b d3		 mov	 edx, ebx
  0008b	c1 ea 08	 shr	 edx, 8
  0008e	83 e2 0f	 and	 edx, 15			; 0000000fH

; 170  : 
; 171  :         if(m_cTexCoords > 8)

  00091	83 fa 08	 cmp	 edx, 8
  00094	89 0e		 mov	 DWORD PTR [esi], ecx
  00096	89 50 3c	 mov	 DWORD PTR [eax+60], edx
  00099	76 07		 jbe	 SHORT $L55554

; 172  :             m_cTexCoords = 8;

  0009b	c7 40 3c 08 00
	00 00		 mov	 DWORD PTR [eax+60], 8
$L55554:

; 173  : 
; 174  :         // all 2d, then go quick route
; 175  :         //if ((dwFVF & 0xffff0000) == 0)
; 176  :         //{
; 177  :             //oCur += sizeof(float) * 2 * m_cTexCoords;
; 178  :         //}
; 179  :         //else
; 180  :         {
; 181  :             dwTexCoordSize = (dwFVF & 0xffff0000) >> 16;

  000a2	c1 eb 10	 shr	 ebx, 16			; 00000010H

; 182  :             for (iTexCoord = 0; iTexCoord < m_cTexCoords; iTexCoord++)

  000a5	33 d2		 xor	 edx, edx
  000a7	39 78 3c	 cmp	 DWORD PTR [eax+60], edi
  000aa	76 1a		 jbe	 SHORT $L55557
$L55555:

; 183  :             {
; 184  :                 m_oTex[iTexCoord] = oCur;
; 185  :                 oCur += x_rgdwTexCoordSize[dwTexCoordSize & 0x3];

  000ac	8b fb		 mov	 edi, ebx
  000ae	83 e7 03	 and	 edi, 3
  000b1	89 0e		 mov	 DWORD PTR [esi], ecx
  000b3	03 0c bd 00 00
	00 00		 add	 ecx, DWORD PTR _x_rgdwTexCoordSize[edi*4]

; 186  :                 dwTexCoordSize = dwTexCoordSize >> 2;

  000ba	c1 eb 02	 shr	 ebx, 2
  000bd	42		 inc	 edx
  000be	83 c6 04	 add	 esi, 4
  000c1	3b 50 3c	 cmp	 edx, DWORD PTR [eax+60]
  000c4	72 e6		 jb	 SHORT $L55555
$L55557:
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi

; 187  :             }
; 188  :         }
; 189  :     }
; 190  : 
; 191  :     m_cBytesPerVertex = oCur;

  000c8	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000cb	5b		 pop	 ebx

; 192  : }

  000cc	5d		 pop	 ebp
  000cd	c2 04 00	 ret	 4
??0DXCrackFVF@@QAE@K@Z ENDP				; DXCrackFVF::DXCrackFVF
_TEXT	ENDS
PUBLIC	?GetArrayElem@DXCrackFVF@@QAEPAEPAXK@Z		; DXCrackFVF::GetArrayElem
; Function compile flags: /Ogs
;	COMDAT ?GetArrayElem@DXCrackFVF@@QAEPAEPAXK@Z
_TEXT	SEGMENT
_pvPoints$ = 8						; size = 4
_iElem$ = 12						; size = 4
?GetArrayElem@DXCrackFVF@@QAEPAEPAXK@Z PROC NEAR	; DXCrackFVF::GetArrayElem, COMDAT
; _this$ = ecx

; 202  : }

  00000	8b ff		 npad	 2

; 200  : { 

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 201  :     return ((PBYTE)pvPoints + (iElem * m_cBytesPerVertex)); 

  00005	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00008	0f af 45 0c	 imul	 eax, DWORD PTR _iElem$[ebp]
  0000c	03 45 08	 add	 eax, DWORD PTR _pvPoints$[ebp]

; 202  : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?GetArrayElem@DXCrackFVF@@QAEPAEPAXK@Z ENDP		; DXCrackFVF::GetArrayElem
_TEXT	ENDS
PUBLIC	?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetPosition
; Function compile flags: /Ogs
;	COMDAT ?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_pvPos$ = 12						; size = 4
?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z PROC NEAR ; DXCrackFVF::SetPosition, COMDAT
; _this$ = ecx

; 211  : }

  00000	8b ff		 npad	 2

; 209  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 210  :     memcpy(pvPoint, pvPos, sizeof(D3DXVECTOR3));

  00006	8b 75 0c	 mov	 esi, DWORD PTR _pvPos$[ebp]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _pvPoint$[ebp]
  0000d	a5		 movsd
  0000e	a5		 movsd
  0000f	a5		 movsd
  00010	5f		 pop	 edi
  00011	5e		 pop	 esi

; 211  : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?SetPosition@DXCrackFVF@@QAEXPAXPAUD3DXVECTOR3@@@Z ENDP	; DXCrackFVF::SetPosition
_TEXT	ENDS
PUBLIC	?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord
; Function compile flags: /Ogs
;	COMDAT ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_iTexCoord$ = 12					; size = 4
_pvTexCoord$ = 16					; size = 4
?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z PROC NEAR ; DXCrackFVF::SetTexCoord, COMDAT
; _this$ = ecx

; 296  :     }
; 297  : }

  00000	8b ff		 npad	 2

; 292  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 293  :     if (iTexCoord < m_cTexCoords)

  00005	8b 45 0c	 mov	 eax, DWORD PTR _iTexCoord$[ebp]
  00008	3b 41 3c	 cmp	 eax, DWORD PTR [ecx+60]
  0000b	73 11		 jae	 SHORT $L55625
  0000d	56		 push	 esi

; 294  :     {
; 295  :         memcpy(((PBYTE)pvPoint) + m_oTex[iTexCoord], pvTexCoord, sizeof(D3DXVECTOR3));

  0000e	8b 75 10	 mov	 esi, DWORD PTR _pvTexCoord$[ebp]
  00011	57		 push	 edi
  00012	8b 7c 81 18	 mov	 edi, DWORD PTR [ecx+eax*4+24]
  00016	03 7d 08	 add	 edi, DWORD PTR _pvPoint$[ebp]
  00019	a5		 movsd
  0001a	a5		 movsd
  0001b	a5		 movsd
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
$L55625:

; 296  :     }
; 297  : }

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ENDP ; DXCrackFVF::SetTexCoord
_TEXT	ENDS
PUBLIC	?PxyzwGetTexCoord@DXCrackFVF@@QAEPAUD3DXVECTOR4@@PAXI@Z ; DXCrackFVF::PxyzwGetTexCoord
; Function compile flags: /Ogs
;	COMDAT ?PxyzwGetTexCoord@DXCrackFVF@@QAEPAUD3DXVECTOR4@@PAXI@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
_index$ = 12						; size = 4
?PxyzwGetTexCoord@DXCrackFVF@@QAEPAUD3DXVECTOR4@@PAXI@Z PROC NEAR ; DXCrackFVF::PxyzwGetTexCoord, COMDAT
; _this$ = ecx

; 446  : }

  00000	8b ff		 npad	 2

; 444  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 445  :     return (D3DXVECTOR4*) (((PBYTE)pvPoint) + m_oTex[index]);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  00008	8b 44 81 18	 mov	 eax, DWORD PTR [ecx+eax*4+24]
  0000c	03 45 08	 add	 eax, DWORD PTR _pvPoint$[ebp]

; 446  : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?PxyzwGetTexCoord@DXCrackFVF@@QAEPAUD3DXVECTOR4@@PAXI@Z ENDP ; DXCrackFVF::PxyzwGetTexCoord
_TEXT	ENDS
PUBLIC	?PfGetWeights@DXCrackFVF@@QAEPAMPAX@Z		; DXCrackFVF::PfGetWeights
; Function compile flags: /Ogs
;	COMDAT ?PfGetWeights@DXCrackFVF@@QAEPAMPAX@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
?PfGetWeights@DXCrackFVF@@QAEPAMPAX@Z PROC NEAR		; DXCrackFVF::PfGetWeights, COMDAT
; _this$ = ecx

; 455  : }

  00000	8b ff		 npad	 2

; 453  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 454  :     return (float*)(((PBYTE)pvPoint) + sizeof(D3DXVECTOR3));

  00005	8b 45 08	 mov	 eax, DWORD PTR _pvPoint$[ebp]
  00008	83 c0 0c	 add	 eax, 12			; 0000000cH

; 455  : }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?PfGetWeights@DXCrackFVF@@QAEPAMPAX@Z ENDP		; DXCrackFVF::PfGetWeights
_TEXT	ENDS
PUBLIC	?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ	; CD3DXCrackDecl1::BIndexedWeights
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\crackdecl.h
;	COMDAT ?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ
_TEXT	SEGMENT
?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ PROC NEAR	; CD3DXCrackDecl1::BIndexedWeights, COMDAT
; _this$ = ecx

; 184  :     BOOL BIndexedWeights()                           { return pIndexElement != NULL; }

  00000	33 c0		 xor	 eax, eax
  00002	39 81 90 00 00
	00		 cmp	 DWORD PTR [ecx+144], eax
  00008	0f 95 c0	 setne	 al
  0000b	c3		 ret	 0
?BIndexedWeights@CD3DXCrackDecl1@@QAEHXZ ENDP		; CD3DXCrackDecl1::BIndexedWeights
_TEXT	ENDS
PUBLIC	?CWeights@CD3DXCrackDecl1@@QAEHXZ		; CD3DXCrackDecl1::CWeights
; Function compile flags: /Ogs
;	COMDAT ?CWeights@CD3DXCrackDecl1@@QAEHXZ
_TEXT	SEGMENT
?CWeights@CD3DXCrackDecl1@@QAEHXZ PROC NEAR		; CD3DXCrackDecl1::CWeights, COMDAT
; _this$ = ecx

; 190  :     BOOL CWeights()                                  { return pWeightElement == NULL ? 0 : (pWeightElement->Type - D3DDECLTYPE_FLOAT1) + 1; }

  00000	8b 81 8c 00 00
	00		 mov	 eax, DWORD PTR [ecx+140]
  00006	85 c0		 test	 eax, eax
  00008	75 01		 jne	 SHORT $L56887
  0000a	c3		 ret	 0
$L56887:
  0000b	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0000f	40		 inc	 eax
  00010	c3		 ret	 0
?CWeights@CD3DXCrackDecl1@@QAEHXZ ENDP			; CD3DXCrackDecl1::CWeights
_TEXT	ENDS
PUBLIC	?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z ; CD3DXCrackDecl1::PvGetPosition
; Function compile flags: /Ogs
;	COMDAT ?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z PROC NEAR ; CD3DXCrackDecl1::PvGetPosition, COMDAT
; _this$ = ecx

; 192  :     LPD3DXVECTOR3 PvGetPosition(PBYTE pvPoint)       { return (LPD3DXVECTOR3)(pvPoint + pPositionElement->Offset); }

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 81 88 00 00
	00		 mov	 eax, DWORD PTR [ecx+136]
  0000b	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  0000f	03 45 08	 add	 eax, DWORD PTR _pvPoint$[ebp]
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?PvGetPosition@CD3DXCrackDecl1@@QAEPAUD3DXVECTOR3@@PAE@Z ENDP ; CD3DXCrackDecl1::PvGetPosition
_TEXT	ENDS
PUBLIC	?PfGetWeights@CD3DXCrackDecl1@@QAEPAMPAE@Z	; CD3DXCrackDecl1::PfGetWeights
; Function compile flags: /Ogs
;	COMDAT ?PfGetWeights@CD3DXCrackDecl1@@QAEPAMPAE@Z
_TEXT	SEGMENT
_pvPoint$ = 8						; size = 4
?PfGetWeights@CD3DXCrackDecl1@@QAEPAMPAE@Z PROC NEAR	; CD3DXCrackDecl1::PfGetWeights, COMDAT
; _this$ = ecx

; 194  :     FLOAT *PfGetWeights(PBYTE pvPoint)               { return (FLOAT*)(pvPoint + pWeightElement->Offset); }

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 81 8c 00 00
	00		 mov	 eax, DWORD PTR [ecx+140]
  0000b	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  0000f	03 45 08	 add	 eax, DWORD PTR _pvPoint$[ebp]
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?PfGetWeights@CD3DXCrackDecl1@@QAEPAMPAE@Z ENDP		; CD3DXCrackDecl1::PfGetWeights
_TEXT	ENDS
PUBLIC	?GetArrayElem@CD3DXCrackDecl1@@QAEPAEPAEI@Z	; CD3DXCrackDecl1::GetArrayElem
; Function compile flags: /Ogs
;	COMDAT ?GetArrayElem@CD3DXCrackDecl1@@QAEPAEPAEI@Z
_TEXT	SEGMENT
_pvPoints$ = 8						; size = 4
_iVertex$ = 12						; size = 4
?GetArrayElem@CD3DXCrackDecl1@@QAEPAEPAEI@Z PROC NEAR	; CD3DXCrackDecl1::GetArrayElem, COMDAT
; _this$ = ecx

; 223  :     PBYTE GetArrayElem(PBYTE pvPoints, UINT iVertex) { return pvPoints + m_cBytesPerVertex * iVertex; }

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	8b 81 c0 00 00
	00		 mov	 eax, DWORD PTR [ecx+192]
  0000b	0f af 45 0c	 imul	 eax, DWORD PTR _iVertex$[ebp]
  0000f	03 45 08	 add	 eax, DWORD PTR _pvPoints$[ebp]
  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?GetArrayElem@CD3DXCrackDecl1@@QAEPAEPAEI@Z ENDP	; CD3DXCrackDecl1::GetArrayElem
_TEXT	ENDS
PUBLIC	??0CD3DXCrackDecl1@@QAE@XZ			; CD3DXCrackDecl1::CD3DXCrackDecl1
EXTRN	??0CD3DXCrackDecl@@QAE@XZ:NEAR			; CD3DXCrackDecl::CD3DXCrackDecl
; Function compile flags: /Ogs
;	COMDAT ??0CD3DXCrackDecl1@@QAE@XZ
_TEXT	SEGMENT
??0CD3DXCrackDecl1@@QAE@XZ PROC NEAR			; CD3DXCrackDecl1::CD3DXCrackDecl1, COMDAT
; _this$ = ecx

; 254  :         }

  00000	8b ff		 npad	 2
  00002	56		 push	 esi
  00003	57		 push	 edi

; 252  :         {

  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??0CD3DXCrackDecl@@QAE@XZ ; CD3DXCrackDecl::CD3DXCrackDecl
  0000b	33 c0		 xor	 eax, eax

; 253  :         memset(rgpTextureElements, 0, sizeof(LPD3DVERTEXELEMENT9) * 8);

  0000d	6a 08		 push	 8
  0000f	59		 pop	 ecx
  00010	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00016	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax
  0001c	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  00022	89 86 94 00 00
	00		 mov	 DWORD PTR [esi+148], eax
  00028	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax
  0002e	89 86 9c 00 00
	00		 mov	 DWORD PTR [esi+156], eax
  00034	8d be a0 00 00
	00		 lea	 edi, DWORD PTR [esi+160]
  0003a	f3 ab		 rep stosd
  0003c	5f		 pop	 edi

; 254  :         }

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	c3		 ret	 0
??0CD3DXCrackDecl1@@QAE@XZ ENDP				; CD3DXCrackDecl1::CD3DXCrackDecl1
_TEXT	ENDS
PUBLIC	?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z ; CD3DXCrackDecl1::SetDeclaration
EXTRN	_D3DXGetDeclVertexSize@8:NEAR
EXTRN	?SetDeclaration@CD3DXCrackDecl@@QAEJPBU_D3DVERTEXELEMENT9@@@Z:NEAR ; CD3DXCrackDecl::SetDeclaration
; Function compile flags: /Ogs
;	COMDAT ?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z
_TEXT	SEGMENT
_pElementsNew$ = 8					; size = 4
?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z PROC NEAR ; CD3DXCrackDecl1::SetDeclaration, COMDAT
; _this$ = ecx

; 355  :     }

  00000	8b ff		 npad	 2

; 270  :     {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi

; 271  :         CONST D3DVERTEXELEMENT9 *pPlace;
; 272  : 
; 273  :         CD3DXCrackDecl::SetDeclaration(pElementsNew);

  00006	ff 75 08	 push	 DWORD PTR _pElementsNew$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?SetDeclaration@CD3DXCrackDecl@@QAEJPBU_D3DVERTEXELEMENT9@@@Z ; CD3DXCrackDecl::SetDeclaration

; 274  : 
; 275  : #ifdef DEBUG
; 276  :         // this class only works for single stream data types
; 277  :         pPlace = pElementsNew;
; 278  :         while(pPlace->Stream != 0xFF)
; 279  :         {
; 280  :             GXASSERT(pPlace->Stream == 0);
; 281  :             pPlace++;
; 282  :         }
; 283  : #endif
; 284  :         // should be pointing into local copy of declaration
; 285  :         pPlace = pElements;

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	e9 c9 00 00 00	 jmp	 $L56898
$L56019:

; 288  :         {
; 289  :             if (pPlace->UsageIndex == 0 || pPlace->Usage == D3DDECLUSAGE_TEXCOORD || 
; 290  :                 pPlace->Usage == D3DDECLUSAGE_COLOR )

  00017	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  0001a	84 d2		 test	 dl, dl
  0001c	74 11		 je	 SHORT $L56022
  0001e	8a 48 06	 mov	 cl, BYTE PTR [eax+6]
  00021	80 f9 05	 cmp	 cl, 5
  00024	74 09		 je	 SHORT $L56022
  00026	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  00029	0f 85 ae 00 00
	00		 jne	 $L56028
$L56022:

; 291  :             {
; 292  :                 switch (pPlace->Usage)

  0002f	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00033	83 e9 00	 sub	 ecx, 0
  00036	0f 84 95 00 00
	00		 je	 $L56027
  0003c	49		 dec	 ecx
  0003d	0f 84 80 00 00
	00		 je	 $L56029
  00043	49		 dec	 ecx
  00044	74 68		 je	 SHORT $L56031
  00046	49		 dec	 ecx
  00047	74 57		 je	 SHORT $L56034
  00049	49		 dec	 ecx
  0004a	49		 dec	 ecx
  0004b	74 3c		 je	 SHORT $L56044
  0004d	83 e9 05	 sub	 ecx, 5
  00050	0f 85 87 00 00
	00		 jne	 $L56028

; 321  : 
; 322  :                 case D3DDECLUSAGE_COLOR:
; 323  :                     if (pPlace->UsageIndex == 0)

  00056	84 d2		 test	 dl, dl
  00058	75 15		 jne	 SHORT $L56037

; 324  :                     {
; 325  :                         if ((pPlace->Type == D3DDECLTYPE_FLOAT4) || (pPlace->Type == D3DDECLTYPE_D3DCOLOR))

  0005a	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  0005d	80 f9 03	 cmp	 cl, 3
  00060	74 05		 je	 SHORT $L56039
  00062	80 f9 04	 cmp	 cl, 4
  00065	75 76		 jne	 SHORT $L56028
$L56039:

; 326  :                         {
; 327  :                             pDiffuseElement = pPlace;

  00067	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax

; 328  :                         }
; 329  :                     }
; 330  :                     else

  0006d	eb 6e		 jmp	 SHORT $L56028
$L56037:

; 331  :                     if (pPlace->UsageIndex == 1)

  0006f	80 fa 01	 cmp	 dl, 1
  00072	75 69		 jne	 SHORT $L56028

; 332  :                     {
; 333  :                         if ((pPlace->Type == D3DDECLTYPE_FLOAT4) || (pPlace->Type == D3DDECLTYPE_D3DCOLOR))

  00074	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  00077	80 f9 03	 cmp	 cl, 3
  0007a	74 05		 je	 SHORT $L56043
  0007c	80 f9 04	 cmp	 cl, 4
  0007f	75 5c		 jne	 SHORT $L56028
$L56043:

; 334  :                         {
; 335  :                             pSpecularElement = pPlace;

  00081	89 86 9c 00 00
	00		 mov	 DWORD PTR [esi+156], eax

; 336  :                         }
; 337  :                     }
; 338  :                     break;

  00087	eb 54		 jmp	 SHORT $L56028
$L56044:

; 339  : 
; 340  :                 case D3DDECLUSAGE_TEXCOORD:
; 341  :                     if ((pPlace->Type >= D3DDECLTYPE_FLOAT1) && (pPlace->Type <= D3DDECLTYPE_FLOAT4) && (pPlace->UsageIndex < 8))

  00089	80 78 04 03	 cmp	 BYTE PTR [eax+4], 3
  0008d	77 4e		 ja	 SHORT $L56028
  0008f	80 fa 08	 cmp	 dl, 8
  00092	73 49		 jae	 SHORT $L56028

; 342  :                     {
; 343  :                         rgpTextureElements[pPlace->UsageIndex] = pPlace;

  00094	0f b6 ca	 movzx	 ecx, dl
  00097	89 84 8e a0 00
	00 00		 mov	 DWORD PTR [esi+ecx*4+160], eax

; 344  :                     }
; 345  :                     break;

  0009e	eb 3d		 jmp	 SHORT $L56028
$L56034:

; 314  : 
; 315  :                 case D3DDECLUSAGE_NORMAL:
; 316  :                     if (pPlace->Type == D3DDECLTYPE_FLOAT3)

  000a0	80 78 04 02	 cmp	 BYTE PTR [eax+4], 2
  000a4	75 37		 jne	 SHORT $L56028

; 317  :                     {
; 318  :                         pNormalElement = pPlace;

  000a6	89 86 94 00 00
	00		 mov	 DWORD PTR [esi+148], eax

; 319  :                     }
; 320  :                     break;

  000ac	eb 2f		 jmp	 SHORT $L56028
$L56031:

; 307  : 
; 308  :                 case D3DDECLUSAGE_BLENDINDICES:
; 309  :                     if ((pPlace->Type == D3DDECLTYPE_UBYTE4) || (pPlace->Type == D3DDECLTYPE_D3DCOLOR))

  000ae	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  000b1	80 f9 05	 cmp	 cl, 5
  000b4	74 05		 je	 SHORT $L56033
  000b6	80 f9 04	 cmp	 cl, 4
  000b9	75 22		 jne	 SHORT $L56028
$L56033:

; 310  :                     {
; 311  :                         pIndexElement = pPlace;

  000bb	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax

; 312  :                     }
; 313  :                     break;

  000c1	eb 1a		 jmp	 SHORT $L56028
$L56029:

; 298  :                     }
; 299  :                     break;
; 300  : 
; 301  :                 case D3DDECLUSAGE_BLENDWEIGHT:
; 302  :                     if ((pPlace->Type >= D3DDECLTYPE_FLOAT1) && (pPlace->Type <= D3DDECLTYPE_FLOAT4))

  000c3	80 78 04 03	 cmp	 BYTE PTR [eax+4], 3
  000c7	77 14		 ja	 SHORT $L56028

; 303  :                     {
; 304  :                         pWeightElement = pPlace;

  000c9	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax

; 305  :                     }
; 306  :                     break;

  000cf	eb 0c		 jmp	 SHORT $L56028
$L56027:

; 293  :                 {
; 294  :                 case D3DDECLUSAGE_POSITION:
; 295  :                     if (pPlace->Type == D3DDECLTYPE_FLOAT3)

  000d1	80 78 04 02	 cmp	 BYTE PTR [eax+4], 2
  000d5	75 06		 jne	 SHORT $L56028

; 296  :                     {
; 297  :                         pPositionElement = pPlace;

  000d7	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
$L56028:

; 346  :                 }
; 347  :             }
; 348  : 
; 349  :             pPlace++;

  000dd	83 c0 08	 add	 eax, 8
$L56898:

; 286  : 
; 287  :         while(pPlace->Stream != 0xFF)

  000e0	66 81 38 ff 00	 cmp	 WORD PTR [eax], 255	; 000000ffH
  000e5	0f 85 2c ff ff
	ff		 jne	 $L56019

; 350  :         }
; 351  : 
; 352  :         m_cBytesPerVertex = D3DXGetDeclVertexSize(pElements,0);

  000eb	6a 00		 push	 0
  000ed	ff 36		 push	 DWORD PTR [esi]
  000ef	e8 00 00 00 00	 call	 _D3DXGetDeclVertexSize@8
  000f4	89 86 c0 00 00
	00		 mov	 DWORD PTR [esi+192], eax

; 353  : 
; 354  :         return S_OK;

  000fa	33 c0		 xor	 eax, eax
  000fc	5e		 pop	 esi

; 355  :     }

  000fd	5d		 pop	 ebp
  000fe	c2 04 00	 ret	 4
?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z ENDP ; CD3DXCrackDecl1::SetDeclaration
_TEXT	ENDS
PUBLIC	??0CAdjacencyOutline@@QAE@XZ			; CAdjacencyOutline::CAdjacencyOutline
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\adjoutline.cpp
;	COMDAT ??0CAdjacencyOutline@@QAE@XZ
_TEXT	SEGMENT
??0CAdjacencyOutline@@QAE@XZ PROC NEAR			; CAdjacencyOutline::CAdjacencyOutline, COMDAT
; _this$ = ecx

; 38   : }

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 37   : {

  00003	6a 02		 push	 2
  00005	8b f1		 mov	 esi, ecx
  00007	e8 00 00 00 00	 call	 ??0DXCrackFVF@@QAE@K@Z	; DXCrackFVF::DXCrackFVF
  0000c	33 c0		 xor	 eax, eax
  0000e	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00011	89 46 44	 mov	 DWORD PTR [esi+68], eax
  00014	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00017	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  0001a	89 46 50	 mov	 DWORD PTR [esi+80], eax
  0001d	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00020	89 46 58	 mov	 DWORD PTR [esi+88], eax

; 38   : }

  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	c3		 ret	 0
??0CAdjacencyOutline@@QAE@XZ ENDP			; CAdjacencyOutline::CAdjacencyOutline
_TEXT	ENDS
PUBLIC	__real@3eaaaaab
PUBLIC	?AppendPoint@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIPAE2AAI@Z ; CAdjacencyOutline::AppendPoint
EXTRN	__alloca_probe:NEAR
;	COMDAT __real@3eaaaaab
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\gxcrackfvf.h
CONST	SEGMENT
__real@3eaaaaab DD 03eaaaaabr			; 0.333333
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\adjoutline.cpp
CONST	ENDS
;	COMDAT ?AppendPoint@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIPAE2AAI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv202 = -4						; size = 4
_cdMesh$ = 8						; size = 4
_pwFace$ = 12						; size = 4
_pvMeshPoints$ = 16					; size = 4
_pvLinePoints$ = 20					; size = 4
_iCurPoint$ = 24					; size = 4
?AppendPoint@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIPAE2AAI@Z PROC NEAR ; CAdjacencyOutline::AppendPoint, COMDAT
; _this$ = ecx

; 89   : }

  00000	8b ff		 npad	 2

; 57   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx

; 58   :     UINT iPoint;
; 59   :     PVOID pvPoint;
; 60   :     DWORD cFloats;
; 61   :     DWORD iFloat;
; 62   :     float *pfTemp;
; 63   : 
; 64   :     GXASSERT(m_cfvf.CWeights() == cdMesh.CWeights());
; 65   : 
; 66   :     cFloats = 3 /*vector*/ + cdMesh.CWeights();

  00007	8b 45 08	 mov	 eax, DWORD PTR _cdMesh$[ebp]
  0000a	8b 80 8c 00 00
	00		 mov	 eax, DWORD PTR [eax+140]
  00010	85 c0		 test	 eax, eax
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00018	74 05		 je	 SHORT $L56907
$L56906:
  0001a	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0001e	40		 inc	 eax
$L56907:
  0001f	8d 70 03	 lea	 esi, DWORD PTR [eax+3]

; 67   : 
; 68   :     pfTemp = (float*)_alloca(cFloats * sizeof(float));

  00022	8b fe		 mov	 edi, esi
  00024	c1 e7 02	 shl	 edi, 2
  00027	8b c7		 mov	 eax, edi
  00029	83 c0 03	 add	 eax, 3
  0002c	83 e0 fc	 and	 eax, -4			; fffffffcH
  0002f	89 7d fc	 mov	 DWORD PTR tv202[ebp], edi
  00032	e8 00 00 00 00	 call	 __alloca_probe

; 69   :     memset(pfTemp, 0, cFloats * sizeof(float));

  00037	8b cf		 mov	 ecx, edi
  00039	8b d9		 mov	 ebx, ecx
  0003b	c1 e9 02	 shr	 ecx, 2
  0003e	8b d4		 mov	 edx, esp
  00040	33 c0		 xor	 eax, eax
  00042	8b fa		 mov	 edi, edx
  00044	f3 ab		 rep stosd
  00046	8b cb		 mov	 ecx, ebx
  00048	83 e1 03	 and	 ecx, 3
  0004b	f3 aa		 rep stosb

; 70   : 
; 71   :     for (iPoint = 0; iPoint < 3; iPoint++)

  0004d	33 ff		 xor	 edi, edi
$L56397:

; 72   :     {
; 73   :         pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace[iPoint]);

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _pwFace$[ebp]
  00052	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _cdMesh$[ebp]
  00058	0f af 81 c0 00
	00 00		 imul	 eax, DWORD PTR [ecx+192]
  0005f	03 45 10	 add	 eax, DWORD PTR _pvMeshPoints$[ebp]

; 74   :         for (iFloat = 0; iFloat < cFloats; iFloat++)

  00062	85 f6		 test	 esi, esi
  00064	76 13		 jbe	 SHORT $L56398
  00066	8b ca		 mov	 ecx, edx
  00068	2b c2		 sub	 eax, edx
  0006a	8b de		 mov	 ebx, esi
$L56400:

; 75   :         {
; 76   :             pfTemp[iFloat] += ((float*)pvPoint)[iFloat];

  0006c	d9 04 08	 fld	 DWORD PTR [eax+ecx]
  0006f	d8 01		 fadd	 DWORD PTR [ecx]
  00071	d9 19		 fstp	 DWORD PTR [ecx]
  00073	83 c1 04	 add	 ecx, 4
  00076	4b		 dec	 ebx
  00077	75 f3		 jne	 SHORT $L56400
$L56398:

; 70   : 
; 71   :     for (iPoint = 0; iPoint < 3; iPoint++)

  00079	47		 inc	 edi
  0007a	83 ff 03	 cmp	 edi, 3
  0007d	72 d0		 jb	 SHORT $L56397

; 77   :         }
; 78   :     }
; 79   : 
; 80   :     for (iFloat = 0; iFloat < cFloats; iFloat++)

  0007f	33 c0		 xor	 eax, eax
  00081	85 f6		 test	 esi, esi
  00083	76 11		 jbe	 SHORT $L56406
$L56404:

; 81   :     {
; 82   :         pfTemp[iFloat] /= 3.0f;

  00085	d9 04 82	 fld	 DWORD PTR [edx+eax*4]
  00088	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3eaaaaab
  0008e	d9 1c 82	 fstp	 DWORD PTR [edx+eax*4]
  00091	40		 inc	 eax
  00092	3b c6		 cmp	 eax, esi
  00094	72 ef		 jb	 SHORT $L56404
$L56406:

; 83   :     }
; 84   : 
; 85   :     pvPoint = m_cfvf.GetArrayElem(pvLinePoints, iCurPoint);

  00096	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00099	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  0009c	8b 45 18	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  0009f	0f af 38	 imul	 edi, DWORD PTR [eax]

; 86   :     memcpy(pvPoint, pfTemp, sizeof(float) * cFloats);

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR tv202[ebp]
  000a5	03 7d 14	 add	 edi, DWORD PTR _pvLinePoints$[ebp]
  000a8	8b f2		 mov	 esi, edx
  000aa	8b d1		 mov	 edx, ecx
  000ac	c1 e9 02	 shr	 ecx, 2
  000af	f3 a5		 rep movsd
  000b1	8b ca		 mov	 ecx, edx
  000b3	83 e1 03	 and	 ecx, 3
  000b6	f3 a4		 rep movsb

; 87   : 
; 88   :     iCurPoint += 1;

  000b8	ff 00		 inc	 DWORD PTR [eax]

; 89   : }

  000ba	8d 65 ec	 lea	 esp, DWORD PTR [ebp-20]
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	c9		 leave
  000c1	c2 14 00	 ret	 20			; 00000014H
?AppendPoint@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIPAE2AAI@Z ENDP ; CAdjacencyOutline::AppendPoint
_TEXT	ENDS
PUBLIC	__real@3f000000
PUBLIC	?AppendMidpoint@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ; CAdjacencyOutline::AppendMidpoint
;	COMDAT __real@3f000000
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\gxcrackfvf.h
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\adjoutline.cpp
CONST	ENDS
;	COMDAT ?AppendMidpoint@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv234 = -4						; size = 4
_pfTemp$ = 8						; size = 4
_cdMesh$ = 8						; size = 4
tv187 = 12						; size = 4
_pwFace1$ = 12						; size = 4
tv317 = 16						; size = 4
_iEdge$ = 16						; size = 4
_pvMeshPoints$ = 20					; size = 4
_pvLinePoints$ = 24					; size = 4
_iCurPoint$ = 28					; size = 4
?AppendMidpoint@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z PROC NEAR ; CAdjacencyOutline::AppendMidpoint, COMDAT
; _this$ = ecx

; 131  : }

  00000	8b ff		 npad	 2

; 101  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	56		 push	 esi

; 102  :     PVOID pvPoint;
; 103  :     DWORD cFloats;
; 104  :     DWORD iFloat;
; 105  :     float *pfTemp;
; 106  : 
; 107  :     GXASSERT(m_cfvf.CWeights() == cdMesh.CWeights());
; 108  : 
; 109  :     cFloats = 3 /*vector*/ + cdMesh.CWeights();

  00009	8b 75 08	 mov	 esi, DWORD PTR _cdMesh$[ebp]
  0000c	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  00012	85 c0		 test	 eax, eax
  00014	57		 push	 edi
  00015	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00018	74 05		 je	 SHORT $L56931
$L56930:
  0001a	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0001e	40		 inc	 eax
$L56931:
  0001f	8d 78 03	 lea	 edi, DWORD PTR [eax+3]

; 110  : 
; 111  :     pfTemp = (float*)_alloca(cFloats * sizeof(float));

  00022	8b c7		 mov	 eax, edi
  00024	c1 e0 02	 shl	 eax, 2
  00027	89 45 fc	 mov	 DWORD PTR tv234[ebp], eax
  0002a	83 c0 03	 add	 eax, 3
  0002d	83 e0 fc	 and	 eax, -4			; fffffffcH
  00030	e8 00 00 00 00	 call	 __alloca_probe

; 112  : 
; 113  :     pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[iEdge]);

  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _pwFace1$[ebp]
  00038	8b 55 10	 mov	 edx, DWORD PTR _iEdge$[ebp]
  0003b	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0003e	0f af 86 c0 00
	00 00		 imul	 eax, DWORD PTR [esi+192]
  00045	03 45 14	 add	 eax, DWORD PTR _pvMeshPoints$[ebp]

; 114  :     for (iFloat = 0; iFloat < cFloats; iFloat++)

  00048	85 ff		 test	 edi, edi
  0004a	8b dc		 mov	 ebx, esp
  0004c	89 5d 08	 mov	 DWORD PTR _pfTemp$[ebp], ebx
  0004f	76 1a		 jbe	 SHORT $L56426
  00051	2b c4		 sub	 eax, esp
  00053	89 45 10	 mov	 DWORD PTR tv317[ebp], eax
  00056	89 7d 0c	 mov	 DWORD PTR tv187[ebp], edi
  00059	eb 03		 jmp	 SHORT $L56424
$L56949:

; 102  :     PVOID pvPoint;
; 103  :     DWORD cFloats;
; 104  :     DWORD iFloat;
; 105  :     float *pfTemp;
; 106  : 
; 107  :     GXASSERT(m_cfvf.CWeights() == cdMesh.CWeights());
; 108  : 
; 109  :     cFloats = 3 /*vector*/ + cdMesh.CWeights();

  0005b	8b 45 10	 mov	 eax, DWORD PTR tv317[ebp]
$L56424:

; 115  :     {
; 116  :         pfTemp[iFloat] = ((float*)pvPoint)[iFloat];

  0005e	d9 04 18	 fld	 DWORD PTR [eax+ebx]
  00061	d9 1b		 fstp	 DWORD PTR [ebx]
  00063	83 c3 04	 add	 ebx, 4
  00066	ff 4d 0c	 dec	 DWORD PTR tv187[ebp]
  00069	75 f0		 jne	 SHORT $L56949
$L56426:

; 117  :     }
; 118  : 
; 119  :     pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[(iEdge+1)%3]);

  0006b	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0006e	6a 03		 push	 3
  00070	33 d2		 xor	 edx, edx
  00072	5b		 pop	 ebx
  00073	f7 f3		 div	 ebx
  00075	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00078	0f af 86 c0 00
	00 00		 imul	 eax, DWORD PTR [esi+192]
  0007f	03 45 14	 add	 eax, DWORD PTR _pvMeshPoints$[ebp]

; 120  :     for (iFloat = 0; iFloat < cFloats; iFloat++)

  00082	85 ff		 test	 edi, edi
  00084	76 18		 jbe	 SHORT $L56430
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _pfTemp$[ebp]
  00089	2b c1		 sub	 eax, ecx
$L56428:

; 121  :     {
; 122  :         pfTemp[iFloat] += ((float*)pvPoint)[iFloat];
; 123  : 
; 124  :         pfTemp[iFloat] /= 2.0f;

  0008b	d9 04 01	 fld	 DWORD PTR [ecx+eax]
  0008e	d8 01		 fadd	 DWORD PTR [ecx]
  00090	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00096	d9 19		 fstp	 DWORD PTR [ecx]
  00098	83 c1 04	 add	 ecx, 4
  0009b	4f		 dec	 edi
  0009c	75 ed		 jne	 SHORT $L56428
$L56430:

; 125  :     }
; 126  : 
; 127  :     pvPoint = m_cfvf.GetArrayElem(pvLinePoints, iCurPoint);

  0009e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  000a4	8b 45 1c	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  000a7	0f af 38	 imul	 edi, DWORD PTR [eax]

; 128  :     memcpy(pvPoint, pfTemp, sizeof(float) * cFloats);

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR tv234[ebp]
  000ad	03 7d 18	 add	 edi, DWORD PTR _pvLinePoints$[ebp]
  000b0	8b 75 08	 mov	 esi, DWORD PTR _pfTemp$[ebp]
  000b3	8b d1		 mov	 edx, ecx
  000b5	c1 e9 02	 shr	 ecx, 2
  000b8	f3 a5		 rep movsd
  000ba	8b ca		 mov	 ecx, edx
  000bc	83 e1 03	 and	 ecx, 3
  000bf	f3 a4		 rep movsb

; 129  : 
; 130  :     iCurPoint += 1;

  000c1	ff 00		 inc	 DWORD PTR [eax]

; 131  : }

  000c3	8d 65 ec	 lea	 esp, DWORD PTR [ebp-20]
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	c9		 leave
  000ca	c2 18 00	 ret	 24			; 00000018H
?AppendMidpoint@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ENDP ; CAdjacencyOutline::AppendMidpoint
_TEXT	ENDS
PUBLIC	?AppendPointSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ; CAdjacencyOutline::AppendPointSkinned
; Function compile flags: /Ogs
;	COMDAT ?AppendPointSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z
_TEXT	SEGMENT
_vAvg$ = -16						; size = 12
_this$ = -4						; size = 4
_cdMesh$ = 8						; size = 4
_pwFace1$ = 12						; size = 4
_iEdge$ = 16						; size = 4
_pvMeshPoints$ = 20					; size = 4
_pvDestPoint$ = 24					; size = 4
_pvLinePoints$ = 24					; size = 4
_iCurPoint$ = 28					; size = 4
?AppendPointSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z PROC NEAR ; CAdjacencyOutline::AppendPointSkinned, COMDAT
; _this$ = ecx

; 257  : }

  00000	8b ff		 npad	 2

; 218  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 219  :     PBYTE pvDestPoint;
; 220  :     PBYTE pvPoint;
; 221  :     D3DXVECTOR3 vAvg(1.0f/3.0f,1.0f/3.0f,1.0f/3.0f);
; 222  : 
; 223  :     pvDestPoint = m_cfvf.GetArrayElem(pvLinePoints, iCurPoint);

  00008	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3eaaaaab
  00011	8b 45 1c	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  00014	d9 55 f0	 fst	 DWORD PTR _vAvg$[ebp]
  00017	0f af 10	 imul	 edx, DWORD PTR [eax]
  0001a	d9 55 f4	 fst	 DWORD PTR _vAvg$[ebp+4]
  0001d	d9 5d f8	 fstp	 DWORD PTR _vAvg$[ebp+8]

; 224  : 
; 225  :     // Point 0 - first point on edge shared with another triangle
; 226  :     pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[iEdge]);

  00020	8b 45 0c	 mov	 eax, DWORD PTR _pwFace1$[ebp]
  00023	03 55 18	 add	 edx, DWORD PTR _pvLinePoints$[ebp]
  00026	53		 push	 ebx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR _cdMesh$[ebp]
  0002a	56		 push	 esi
  0002b	8b 75 10	 mov	 esi, DWORD PTR _iEdge$[ebp]
  0002e	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00031	0f af 83 c0 00
	00 00		 imul	 eax, DWORD PTR [ebx+192]

; 227  : 
; 228  :     // first position goes in standard position spot
; 229  :     m_cfvf.SetPosition(pvDestPoint, cdMesh.PvGetPosition(pvPoint));

  00038	8b b3 88 00 00
	00		 mov	 esi, DWORD PTR [ebx+136]
  0003e	0f b7 76 02	 movzx	 esi, WORD PTR [esi+2]
  00042	03 45 14	 add	 eax, DWORD PTR _pvMeshPoints$[ebp]
  00045	57		 push	 edi
  00046	03 f0		 add	 esi, eax
  00048	8b fa		 mov	 edi, edx
  0004a	a5		 movsd
  0004b	a5		 movsd
  0004c	a5		 movsd

; 230  : 
; 231  :     // first set of weights go in standard spot - expand to standard length
; 232  :     CopyWeights(cdMesh.PfGetWeights(pvPoint), cdMesh.CWeights(), m_cfvf.PfGetWeights(pvDestPoint), m_cfvf.CWeights());

  0004d	8b 71 38	 mov	 esi, DWORD PTR [ecx+56]
  00050	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00053	8b 8b 8c 00 00
	00		 mov	 ecx, DWORD PTR [ebx+140]
  00059	85 c9		 test	 ecx, ecx
  0005b	89 55 18	 mov	 DWORD PTR _pvDestPoint$[ebp], edx
  0005e	75 04		 jne	 SHORT $L56978
  00060	33 ff		 xor	 edi, edi
  00062	eb 05		 jmp	 SHORT $L56979
$L56978:
  00064	0f b6 79 04	 movzx	 edi, BYTE PTR [ecx+4]
  00068	47		 inc	 edi
$L56979:
  00069	0f b7 49 02	 movzx	 ecx, WORD PTR [ecx+2]
  0006d	56		 push	 esi
  0006e	83 c2 0c	 add	 edx, 12			; 0000000cH
  00071	52		 push	 edx
  00072	03 c8		 add	 ecx, eax
  00074	57		 push	 edi
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?CopyWeights@@YAXPAMK0K@Z ; CopyWeights

; 233  : 
; 234  :     // Point 1 - other point on edge shared with another triangle
; 235  :     pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[(iEdge+1)%3]);

  0007b	8b 45 10	 mov	 eax, DWORD PTR _iEdge$[ebp]
  0007e	83 c4 10	 add	 esp, 16			; 00000010H
  00081	6a 03		 push	 3
  00083	40		 inc	 eax
  00084	59		 pop	 ecx
  00085	33 d2		 xor	 edx, edx
  00087	f7 f1		 div	 ecx
  00089	8b 45 0c	 mov	 eax, DWORD PTR _pwFace1$[ebp]

; 236  : 
; 237  :     // second position goes in first texture coord
; 238  :     m_cfvf.SetTexCoord(pvDestPoint, 0, cdMesh.PvGetPosition(pvPoint));

  0008c	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  0008f	8b cf		 mov	 ecx, edi
  00091	8b 34 90	 mov	 esi, DWORD PTR [eax+edx*4]
  00094	0f af b3 c0 00
	00 00		 imul	 esi, DWORD PTR [ebx+192]
  0009b	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [ebx+136]
  000a1	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  000a5	03 75 14	 add	 esi, DWORD PTR _pvMeshPoints$[ebp]
  000a8	03 c6		 add	 eax, esi
  000aa	50		 push	 eax
  000ab	6a 00		 push	 0
  000ad	ff 75 18	 push	 DWORD PTR _pvDestPoint$[ebp]
  000b0	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord

; 239  : 
; 240  :     // second set of weights go in second texture coord- expand to standard length
; 241  :     CopyWeights(cdMesh.PfGetWeights(pvPoint), cdMesh.CWeights(), (float*)m_cfvf.PxyzwGetTexCoord(pvDestPoint, 1), m_cfvf.CWeights());

  000b5	8b 83 8c 00 00
	00		 mov	 eax, DWORD PTR [ebx+140]
  000bb	85 c0		 test	 eax, eax
  000bd	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  000c0	75 04		 jne	 SHORT $L57002
  000c2	33 d2		 xor	 edx, edx
  000c4	eb 05		 jmp	 SHORT $L57003
$L57002:
  000c6	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  000ca	42		 inc	 edx
$L57003:
  000cb	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  000cf	51		 push	 ecx
  000d0	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  000d3	03 4d 18	 add	 ecx, DWORD PTR _pvDestPoint$[ebp]
  000d6	03 c6		 add	 eax, esi
  000d8	51		 push	 ecx
  000d9	52		 push	 edx
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 ?CopyWeights@@YAXPAMK0K@Z ; CopyWeights

; 242  : 
; 243  :     // Point 2 - point NOT on edge shared with another triangle
; 244  :     pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[(iEdge+2)%3]);

  000e0	8b 45 10	 mov	 eax, DWORD PTR _iEdge$[ebp]
  000e3	83 c4 10	 add	 esp, 16			; 00000010H
  000e6	6a 03		 push	 3
  000e8	83 c0 02	 add	 eax, 2
  000eb	59		 pop	 ecx
  000ec	33 d2		 xor	 edx, edx
  000ee	f7 f1		 div	 ecx
  000f0	8b 45 0c	 mov	 eax, DWORD PTR _pwFace1$[ebp]

; 245  : 
; 246  :     // third position goes in the third texture coordinate
; 247  :     m_cfvf.SetTexCoord(pvDestPoint, 2, cdMesh.PvGetPosition(pvPoint));

  000f3	8b cf		 mov	 ecx, edi
  000f5	8b 34 90	 mov	 esi, DWORD PTR [eax+edx*4]
  000f8	0f af b3 c0 00
	00 00		 imul	 esi, DWORD PTR [ebx+192]
  000ff	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [ebx+136]
  00105	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  00109	03 75 14	 add	 esi, DWORD PTR _pvMeshPoints$[ebp]
  0010c	03 c6		 add	 eax, esi
  0010e	50		 push	 eax
  0010f	6a 02		 push	 2
  00111	ff 75 18	 push	 DWORD PTR _pvDestPoint$[ebp]
  00114	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord

; 248  : 
; 249  :     // third set of weights go in fourth texture coord- expand to standard length
; 250  :     CopyWeights(cdMesh.PfGetWeights(pvPoint), cdMesh.CWeights(), (float*)m_cfvf.PxyzwGetTexCoord(pvDestPoint, 3), m_cfvf.CWeights());

  00119	8b 9b 8c 00 00
	00		 mov	 ebx, DWORD PTR [ebx+140]
  0011f	85 db		 test	 ebx, ebx
  00121	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00124	75 04		 jne	 SHORT $L57025
  00126	33 c9		 xor	 ecx, ecx
  00128	eb 05		 jmp	 SHORT $L57026
$L57025:
  0012a	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  0012e	41		 inc	 ecx
$L57026:
  0012f	50		 push	 eax
  00130	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00133	03 45 18	 add	 eax, DWORD PTR _pvDestPoint$[ebp]
  00136	50		 push	 eax
  00137	0f b7 43 02	 movzx	 eax, WORD PTR [ebx+2]
  0013b	51		 push	 ecx
  0013c	03 c6		 add	 eax, esi
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 ?CopyWeights@@YAXPAMK0K@Z ; CopyWeights
  00144	83 c4 10	 add	 esp, 16			; 00000010H

; 251  : 
; 252  : 
; 253  :     // the third position should be added in
; 254  :     m_cfvf.SetTexCoord(pvDestPoint, 4, &vAvg);

  00147	8d 45 f0	 lea	 eax, DWORD PTR _vAvg$[ebp]
  0014a	50		 push	 eax
  0014b	6a 04		 push	 4
  0014d	ff 75 18	 push	 DWORD PTR _pvDestPoint$[ebp]
  00150	8b cf		 mov	 ecx, edi
  00152	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord

; 255  : 
; 256  :     iCurPoint += 1;

  00157	8b 45 1c	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  0015a	ff 00		 inc	 DWORD PTR [eax]
  0015c	5f		 pop	 edi
  0015d	5e		 pop	 esi
  0015e	5b		 pop	 ebx

; 257  : }

  0015f	c9		 leave
  00160	c2 18 00	 ret	 24			; 00000018H
?AppendPointSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ENDP ; CAdjacencyOutline::AppendPointSkinned
_TEXT	ENDS
PUBLIC	?AppendMidpointSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ; CAdjacencyOutline::AppendMidpointSkinned
; Function compile flags: /Ogs
;	COMDAT ?AppendMidpointSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z
_TEXT	SEGMENT
_vMidPoint$ = -12					; size = 12
_cdMesh$ = 8						; size = 4
_pwFace1$ = 12						; size = 4
_iEdge$ = 16						; size = 4
_pvMeshPoints$ = 20					; size = 4
_pvLinePoints$ = 24					; size = 4
_iCurPoint$ = 28					; size = 4
?AppendMidpointSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z PROC NEAR ; CAdjacencyOutline::AppendMidpointSkinned, COMDAT
; _this$ = ecx

; 279  : }

  00000	8b ff		 npad	 2

; 269  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 270  :     PBYTE pvDestPoint;
; 271  :     D3DXVECTOR3 vMidPoint(0.5f, 0.5f, 0.0f);
; 272  : 
; 273  :     pvDestPoint = m_cfvf.GetArrayElem(pvLinePoints, iCurPoint);

  00008	8b 45 1c	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  0000b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000
  00011	56		 push	 esi
  00012	d9 55 f4	 fst	 DWORD PTR _vMidPoint$[ebp]
  00015	57		 push	 edi
  00016	d9 5d f8	 fstp	 DWORD PTR _vMidPoint$[ebp+4]

; 274  : 
; 275  :     AppendPointSkinned(cdMesh, pwFace1, iEdge, pvMeshPoints, pvLinePoints, iCurPoint);

  00019	50		 push	 eax
  0001a	d9 ee		 fldz
  0001c	ff 75 18	 push	 DWORD PTR _pvLinePoints$[ebp]
  0001f	d9 5d fc	 fstp	 DWORD PTR _vMidPoint$[ebp+8]
  00022	8b f9		 mov	 edi, ecx
  00024	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00027	ff 75 14	 push	 DWORD PTR _pvMeshPoints$[ebp]
  0002a	0f af 30	 imul	 esi, DWORD PTR [eax]
  0002d	ff 75 10	 push	 DWORD PTR _iEdge$[ebp]
  00030	03 75 18	 add	 esi, DWORD PTR _pvLinePoints$[ebp]
  00033	ff 75 0c	 push	 DWORD PTR _pwFace1$[ebp]
  00036	ff 75 08	 push	 DWORD PTR _cdMesh$[ebp]
  00039	e8 00 00 00 00	 call	 ?AppendPointSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ; CAdjacencyOutline::AppendPointSkinned

; 276  : 
; 277  :     // the third position should be ignored!
; 278  :     m_cfvf.SetTexCoord(pvDestPoint, 4, &vMidPoint);

  0003e	8d 45 f4	 lea	 eax, DWORD PTR _vMidPoint$[ebp]
  00041	50		 push	 eax
  00042	6a 04		 push	 4
  00044	56		 push	 esi
  00045	8b cf		 mov	 ecx, edi
  00047	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 279  : }

  0004e	c9		 leave
  0004f	c2 18 00	 ret	 24			; 00000018H
?AppendMidpointSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ENDP ; CAdjacencyOutline::AppendMidpointSkinned
_TEXT	ENDS
PUBLIC	?AppendPointIndexSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ; CAdjacencyOutline::AppendPointIndexSkinned
; Function compile flags: /Ogs
;	COMDAT ?AppendPointIndexSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z
_TEXT	SEGMENT
_vAvg$ = -16						; size = 12
_this$ = -4						; size = 4
_cdMesh$ = 8						; size = 4
_pwFace1$ = 12						; size = 4
_iEdge$ = 16						; size = 4
_pvMeshPoints$ = 20					; size = 4
_pvDestPoint$ = 24					; size = 4
_pvLinePoints$ = 24					; size = 4
_iCurPoint$ = 28					; size = 4
?AppendPointIndexSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z PROC NEAR ; CAdjacencyOutline::AppendPointIndexSkinned, COMDAT
; _this$ = ecx

; 330  : }

  00000	8b ff		 npad	 2

; 291  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 292  :     PBYTE pvDestPoint;
; 293  :     PBYTE pvPoint;
; 294  :     D3DXVECTOR3 vAvg(1.0f/3.0f,1.0f/3.0f,1.0f/3.0f);
; 295  : 
; 296  :     pvDestPoint = m_cfvf.GetArrayElem(pvLinePoints, iCurPoint);

  00008	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3eaaaaab
  00011	8b 45 1c	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  00014	d9 55 f0	 fst	 DWORD PTR _vAvg$[ebp]
  00017	0f af 10	 imul	 edx, DWORD PTR [eax]
  0001a	d9 55 f4	 fst	 DWORD PTR _vAvg$[ebp+4]
  0001d	d9 5d f8	 fstp	 DWORD PTR _vAvg$[ebp+8]

; 297  : 
; 298  :     // Point 0 - first point on edge shared with another triangle
; 299  :     pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[iEdge]);

  00020	8b 45 0c	 mov	 eax, DWORD PTR _pwFace1$[ebp]
  00023	03 55 18	 add	 edx, DWORD PTR _pvLinePoints$[ebp]
  00026	53		 push	 ebx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR _cdMesh$[ebp]
  0002a	56		 push	 esi
  0002b	8b 75 10	 mov	 esi, DWORD PTR _iEdge$[ebp]
  0002e	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00031	0f af 83 c0 00
	00 00		 imul	 eax, DWORD PTR [ebx+192]

; 300  : 
; 301  :     // first position goes in standard position spot
; 302  :     m_cfvf.SetPosition(pvDestPoint, cdMesh.PvGetPosition(pvPoint));

  00038	8b b3 88 00 00
	00		 mov	 esi, DWORD PTR [ebx+136]
  0003e	0f b7 76 02	 movzx	 esi, WORD PTR [esi+2]
  00042	03 45 14	 add	 eax, DWORD PTR _pvMeshPoints$[ebp]
  00045	57		 push	 edi
  00046	03 f0		 add	 esi, eax
  00048	8b fa		 mov	 edi, edx
  0004a	a5		 movsd
  0004b	a5		 movsd
  0004c	a5		 movsd

; 303  : 
; 304  :     // first set of weights go in standard spot - expand to standard length
; 305  :     CopyIndexedWeights(cdMesh.PfGetWeights(pvPoint), cdMesh.CWeights() + 1, m_cfvf.PfGetWeights(pvDestPoint), m_cfvf.CWeights());

  0004d	8b 79 38	 mov	 edi, DWORD PTR [ecx+56]
  00050	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00053	8b 8b 8c 00 00
	00		 mov	 ecx, DWORD PTR [ebx+140]
  00059	85 c9		 test	 ecx, ecx
  0005b	89 55 18	 mov	 DWORD PTR _pvDestPoint$[ebp], edx
  0005e	75 04		 jne	 SHORT $L57066
  00060	33 f6		 xor	 esi, esi
  00062	eb 05		 jmp	 SHORT $L57067
$L57066:
  00064	0f b6 71 04	 movzx	 esi, BYTE PTR [ecx+4]
  00068	46		 inc	 esi
$L57067:
  00069	0f b7 49 02	 movzx	 ecx, WORD PTR [ecx+2]
  0006d	57		 push	 edi
  0006e	83 c2 0c	 add	 edx, 12			; 0000000cH
  00071	52		 push	 edx
  00072	46		 inc	 esi
  00073	03 c8		 add	 ecx, eax
  00075	56		 push	 esi
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 ?CopyIndexedWeights@@YAXPAMK0K@Z ; CopyIndexedWeights

; 306  :     
; 307  :     // Point 1 - other point on edge shared with another triangle
; 308  :     pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[(iEdge+1)%3]);

  0007c	8b 45 10	 mov	 eax, DWORD PTR _iEdge$[ebp]
  0007f	83 c4 10	 add	 esp, 16			; 00000010H
  00082	6a 03		 push	 3
  00084	40		 inc	 eax
  00085	59		 pop	 ecx
  00086	33 d2		 xor	 edx, edx
  00088	f7 f1		 div	 ecx
  0008a	8b 45 0c	 mov	 eax, DWORD PTR _pwFace1$[ebp]

; 309  : 
; 310  :     // second position goes in first texture coord
; 311  :     m_cfvf.SetTexCoord(pvDestPoint, 0, cdMesh.PvGetPosition(pvPoint));

  0008d	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  00090	8b cf		 mov	 ecx, edi
  00092	8b 34 90	 mov	 esi, DWORD PTR [eax+edx*4]
  00095	0f af b3 c0 00
	00 00		 imul	 esi, DWORD PTR [ebx+192]
  0009c	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [ebx+136]
  000a2	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  000a6	03 75 14	 add	 esi, DWORD PTR _pvMeshPoints$[ebp]
  000a9	03 c6		 add	 eax, esi
  000ab	50		 push	 eax
  000ac	6a 00		 push	 0
  000ae	ff 75 18	 push	 DWORD PTR _pvDestPoint$[ebp]
  000b1	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord

; 312  : 
; 313  :     // second set of weights go in second texture coord- expand to standard length
; 314  :     CopyIndexedWeights(cdMesh.PfGetWeights(pvPoint), cdMesh.CWeights() + 1, (float*)m_cfvf.PxyzwGetTexCoord(pvDestPoint, 1), m_cfvf.CWeights());

  000b6	8b 83 8c 00 00
	00		 mov	 eax, DWORD PTR [ebx+140]
  000bc	85 c0		 test	 eax, eax
  000be	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  000c1	75 04		 jne	 SHORT $L57089
  000c3	33 c9		 xor	 ecx, ecx
  000c5	eb 05		 jmp	 SHORT $L57090
$L57089:
  000c7	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000cb	41		 inc	 ecx
$L57090:
  000cc	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  000d0	52		 push	 edx
  000d1	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  000d4	03 55 18	 add	 edx, DWORD PTR _pvDestPoint$[ebp]
  000d7	41		 inc	 ecx
  000d8	52		 push	 edx
  000d9	51		 push	 ecx
  000da	03 c6		 add	 eax, esi
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 ?CopyIndexedWeights@@YAXPAMK0K@Z ; CopyIndexedWeights

; 315  : 
; 316  :     // Point 2 - point NOT on edge shared with another triangle
; 317  :     pvPoint = cdMesh.GetArrayElem(pvMeshPoints, pwFace1[(iEdge+2)%3]);

  000e2	8b 45 10	 mov	 eax, DWORD PTR _iEdge$[ebp]
  000e5	83 c4 10	 add	 esp, 16			; 00000010H
  000e8	6a 03		 push	 3
  000ea	83 c0 02	 add	 eax, 2
  000ed	59		 pop	 ecx
  000ee	33 d2		 xor	 edx, edx
  000f0	f7 f1		 div	 ecx
  000f2	8b 45 0c	 mov	 eax, DWORD PTR _pwFace1$[ebp]
  000f5	8b 34 90	 mov	 esi, DWORD PTR [eax+edx*4]
  000f8	0f af b3 c0 00
	00 00		 imul	 esi, DWORD PTR [ebx+192]

; 318  : 
; 319  :     // third position goes in the third texture coordinate
; 320  :     m_cfvf.SetTexCoord(pvDestPoint, 3, cdMesh.PvGetPosition(pvPoint));

  000ff	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [ebx+136]
  00105	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  00109	03 75 14	 add	 esi, DWORD PTR _pvMeshPoints$[ebp]
  0010c	03 c6		 add	 eax, esi
  0010e	50		 push	 eax
  0010f	51		 push	 ecx
  00110	ff 75 18	 push	 DWORD PTR _pvDestPoint$[ebp]
  00113	8b cf		 mov	 ecx, edi
  00115	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord

; 321  : 
; 322  :     // third set of weights go in fourth texture coord- expand to standard length
; 323  :     CopyIndexedWeights(cdMesh.PfGetWeights(pvPoint), cdMesh.CWeights() + 1, (float*)m_cfvf.PxyzwGetTexCoord(pvDestPoint, 4), m_cfvf.CWeights());

  0011a	8b 9b 8c 00 00
	00		 mov	 ebx, DWORD PTR [ebx+140]
  00120	85 db		 test	 ebx, ebx
  00122	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00125	75 04		 jne	 SHORT $L57112
  00127	33 c9		 xor	 ecx, ecx
  00129	eb 05		 jmp	 SHORT $L57113
$L57112:
  0012b	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  0012f	41		 inc	 ecx
$L57113:
  00130	50		 push	 eax
  00131	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00134	03 45 18	 add	 eax, DWORD PTR _pvDestPoint$[ebp]
  00137	41		 inc	 ecx
  00138	50		 push	 eax
  00139	0f b7 43 02	 movzx	 eax, WORD PTR [ebx+2]
  0013d	51		 push	 ecx
  0013e	03 c6		 add	 eax, esi
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 ?CopyIndexedWeights@@YAXPAMK0K@Z ; CopyIndexedWeights
  00146	83 c4 10	 add	 esp, 16			; 00000010H

; 324  : 
; 325  : 
; 326  :     // the third position should be added in
; 327  :     m_cfvf.SetTexCoord(pvDestPoint, 6, &vAvg);

  00149	8d 45 f0	 lea	 eax, DWORD PTR _vAvg$[ebp]
  0014c	50		 push	 eax
  0014d	6a 06		 push	 6
  0014f	ff 75 18	 push	 DWORD PTR _pvDestPoint$[ebp]
  00152	8b cf		 mov	 ecx, edi
  00154	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord

; 328  : 
; 329  :     iCurPoint += 1;

  00159	8b 45 1c	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  0015c	ff 00		 inc	 DWORD PTR [eax]
  0015e	5f		 pop	 edi
  0015f	5e		 pop	 esi
  00160	5b		 pop	 ebx

; 330  : }

  00161	c9		 leave
  00162	c2 18 00	 ret	 24			; 00000018H
?AppendPointIndexSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ENDP ; CAdjacencyOutline::AppendPointIndexSkinned
_TEXT	ENDS
PUBLIC	?AppendMidpointIndexSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ; CAdjacencyOutline::AppendMidpointIndexSkinned
; Function compile flags: /Ogs
;	COMDAT ?AppendMidpointIndexSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z
_TEXT	SEGMENT
_vMidPoint$ = -12					; size = 12
_cdMesh$ = 8						; size = 4
_pwFace1$ = 12						; size = 4
_iEdge$ = 16						; size = 4
_pvMeshPoints$ = 20					; size = 4
_pvLinePoints$ = 24					; size = 4
_iCurPoint$ = 28					; size = 4
?AppendMidpointIndexSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z PROC NEAR ; CAdjacencyOutline::AppendMidpointIndexSkinned, COMDAT
; _this$ = ecx

; 352  : }

  00000	8b ff		 npad	 2

; 342  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 343  :     PBYTE pvDestPoint;
; 344  :     D3DXVECTOR3 vMidPoint(0.5f, 0.5f, 0.0f);
; 345  : 
; 346  :     pvDestPoint = m_cfvf.GetArrayElem(pvLinePoints, iCurPoint);

  00008	8b 45 1c	 mov	 eax, DWORD PTR _iCurPoint$[ebp]
  0000b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f000000
  00011	56		 push	 esi
  00012	d9 55 f4	 fst	 DWORD PTR _vMidPoint$[ebp]
  00015	57		 push	 edi
  00016	d9 5d f8	 fstp	 DWORD PTR _vMidPoint$[ebp+4]

; 347  : 
; 348  :     AppendPointIndexSkinned(cdMesh, pwFace1, iEdge, pvMeshPoints, pvLinePoints, iCurPoint);

  00019	50		 push	 eax
  0001a	d9 ee		 fldz
  0001c	ff 75 18	 push	 DWORD PTR _pvLinePoints$[ebp]
  0001f	d9 5d fc	 fstp	 DWORD PTR _vMidPoint$[ebp+8]
  00022	8b f9		 mov	 edi, ecx
  00024	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00027	ff 75 14	 push	 DWORD PTR _pvMeshPoints$[ebp]
  0002a	0f af 30	 imul	 esi, DWORD PTR [eax]
  0002d	ff 75 10	 push	 DWORD PTR _iEdge$[ebp]
  00030	03 75 18	 add	 esi, DWORD PTR _pvLinePoints$[ebp]
  00033	ff 75 0c	 push	 DWORD PTR _pwFace1$[ebp]
  00036	ff 75 08	 push	 DWORD PTR _cdMesh$[ebp]
  00039	e8 00 00 00 00	 call	 ?AppendPointIndexSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ; CAdjacencyOutline::AppendPointIndexSkinned

; 349  : 
; 350  :     // the third position should be ignored!
; 351  :     m_cfvf.SetTexCoord(pvDestPoint, 6, &vMidPoint);

  0003e	8d 45 f4	 lea	 eax, DWORD PTR _vMidPoint$[ebp]
  00041	50		 push	 eax
  00042	6a 06		 push	 6
  00044	56		 push	 esi
  00045	8b cf		 mov	 ecx, edi
  00047	e8 00 00 00 00	 call	 ?SetTexCoord@DXCrackFVF@@QAEXPAXIPAUD3DXVECTOR3@@@Z ; DXCrackFVF::SetTexCoord
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 352  : }

  0004e	c9		 leave
  0004f	c2 18 00	 ret	 24			; 00000018H
?AppendMidpointIndexSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ENDP ; CAdjacencyOutline::AppendMidpointIndexSkinned
_TEXT	ENDS
PUBLIC	?Init@CAdjacencyOutline@@QAEJPAUID3DXBaseMesh@@PAK@Z ; CAdjacencyOutline::Init
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_D3DXDeclaratorFromFVF@8:NEAR
; Function compile flags: /Ogs
;	COMDAT ?Init@CAdjacencyOutline@@QAEJPAUID3DXBaseMesh@@PAK@Z
_TEXT	SEGMENT
_Caps$ = -1144						; size = 304
_pDecl$ = -840						; size = 520
$T57125 = -320						; size = 64
_cdMesh$ = -256						; size = 196
_rgwFaces$ = -60					; size = 4
_pdwNeighbor$ = -56					; size = 4
_iCurLineOffset$ = -56					; size = 4
_pDevice$ = -52						; size = 4
_pVBVertices$ = -48					; size = 4
tv1276 = -44						; size = 4
_iCurVertexOffset$ = -44				; size = 4
tv1172 = -40						; size = 4
_iFaceEnd$ = -40					; size = 4
_iFace$ = -36						; size = 4
_cConnections$ = -36					; size = 4
_rgdwFaces$ = -32					; size = 4
_rgaeAttributeTableMesh$ = -28				; size = 4
_iae$ = -24						; size = 4
_pibFaces$ = -20					; size = 4
_pvLinePoints$ = -16					; size = 4
_pvMeshPoints$ = -12					; size = 4
_b16BitMesh$ = -5					; size = 1
_iCurPoint$ = -4					; size = 4
_hr$ = -4						; size = 4
_iPoint$ = 8						; size = 4
_ptmMesh$ = 8						; size = 4
_rgdwNeighbors$ = 12					; size = 4
?Init@CAdjacencyOutline@@QAEJPAUID3DXBaseMesh@@PAK@Z PROC NEAR ; CAdjacencyOutline::Init, COMDAT
; _this$ = ecx

; 652  : }

  00000	8b ff		 npad	 2

; 356  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 78 04 00
	00		 sub	 esp, 1144		; 00000478H
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 357  :     HRESULT hr = S_OK;
; 358  :     UINT cFaces;
; 359  :     UINT iFace;
; 360  :     UINT cConnections;
; 361  :     UINT cPointsMax;
; 362  :     UINT iline;
; 363  :     PBYTE pvLinePoints = NULL;

  0000e	33 ff		 xor	 edi, edi
  00010	8b d9		 mov	 ebx, ecx

; 364  :     PBYTE pvMeshPoints = NULL;
; 365  :     LPDIRECT3DVERTEXBUFFER9 pVBVertices = NULL;
; 366  :     LPDIRECT3DINDEXBUFFER9 pibFaces = NULL;
; 367  :     PUINT pdwFaceCur;
; 368  :     PUINT rgdwFaces = NULL;
; 369  :     CD3DXCrackDecl1 cdMesh;

  00012	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _cdMesh$[ebp]
  00018	89 7d f0	 mov	 DWORD PTR _pvLinePoints$[ebp], edi
  0001b	89 7d f4	 mov	 DWORD PTR _pvMeshPoints$[ebp], edi
  0001e	89 7d d0	 mov	 DWORD PTR _pVBVertices$[ebp], edi
  00021	89 7d ec	 mov	 DWORD PTR _pibFaces$[ebp], edi
  00024	89 7d e0	 mov	 DWORD PTR _rgdwFaces$[ebp], edi
  00027	e8 00 00 00 00	 call	 ??0CD3DXCrackDecl1@@QAE@XZ ; CD3DXCrackDecl1::CD3DXCrackDecl1

; 370  :     PWORD rgwFaces = NULL;
; 371  :     bool b16BitMesh;
; 372  :     UINT iIndex;
; 373  :     UINT iPoint;
; 374  :     DWORD *pdwNeighbor;
; 375  :     UINT iCurPoint;
; 376  :     LPDIRECT3DDEVICE9 pDevice;
; 377  :     D3DXATTRIBUTERANGE *rgaeAttributeTableMesh = NULL;
; 378  :     DWORD iCurLineOffset;
; 379  :     DWORD iCurVertexOffset;
; 380  :     DWORD iFaceEnd;
; 381  :     DWORD iae;
; 382  :     DWORD dwFVFAdjVertices;
; 383  :     D3DCAPS9 Caps;
; 384  :     D3DVERTEXELEMENT9 pDecl[MAX_FVF_DECL_SIZE];
; 385  :     LPD3DVERTEXELEMENT9 pDeclCur;
; 386  : 
; 387  :     ptmMesh->GetDeclaration(pDecl);

  0002c	8b 75 08	 mov	 esi, DWORD PTR _ptmMesh$[ebp]
  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR _pDecl$[ebp]
  00037	51		 push	 ecx
  00038	56		 push	 esi
  00039	89 7d c4	 mov	 DWORD PTR _rgwFaces$[ebp], edi
  0003c	89 7d e4	 mov	 DWORD PTR _rgaeAttributeTableMesh$[ebp], edi
  0003f	ff 50 1c	 call	 DWORD PTR [eax+28]

; 388  :     cdMesh.SetDeclaration(pDecl);

  00042	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _pDecl$[ebp]
  00048	50		 push	 eax
  00049	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _cdMesh$[ebp]
  0004f	e8 00 00 00 00	 call	 ?SetDeclaration@CD3DXCrackDecl1@@QAEJPBU_D3DVERTEXELEMENT9@@@Z ; CD3DXCrackDecl1::SetDeclaration

; 389  : 
; 390  :     ptmMesh->GetDevice(&pDevice);

  00054	8b 06		 mov	 eax, DWORD PTR [esi]
  00056	8d 4d cc	 lea	 ecx, DWORD PTR _pDevice$[ebp]
  00059	51		 push	 ecx
  0005a	56		 push	 esi
  0005b	ff 50 28	 call	 DWORD PTR [eax+40]

; 391  :     pDevice->Release();

  0005e	8b 45 cc	 mov	 eax, DWORD PTR _pDevice$[ebp]
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	50		 push	 eax
  00064	ff 51 08	 call	 DWORD PTR [ecx+8]

; 392  : 
; 393  :     // is the mesh 16 bit?
; 394  :     b16BitMesh = !(ptmMesh->GetOptions() & D3DXMESH_32BIT);

  00067	8b 06		 mov	 eax, DWORD PTR [esi]
  00069	56		 push	 esi
  0006a	ff 50 24	 call	 DWORD PTR [eax+36]
  0006d	34 ff		 xor	 al, 255			; 000000ffH
  0006f	24 01		 and	 al, 1

; 395  : 
; 396  :     hr = CreateEmptyOutline();

  00071	8b cb		 mov	 ecx, ebx
  00073	88 45 fb	 mov	 BYTE PTR _b16BitMesh$[ebp], al
  00076	e8 00 00 00 00	 call	 ?CreateEmptyOutline@CAdjacencyOutline@@AAEJXZ ; CAdjacencyOutline::CreateEmptyOutline

; 397  :     if (FAILED(hr))

  0007b	3b c7		 cmp	 eax, edi
  0007d	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00080	0f 8c 7f 04 00
	00		 jl	 $e_Exit$56553

; 398  :         goto e_Exit;
; 399  : 
; 400  :     pDevice->GetDeviceCaps(&Caps);

  00086	8b 45 cc	 mov	 eax, DWORD PTR _pDevice$[ebp]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	8d 95 88 fb ff
	ff		 lea	 edx, DWORD PTR _Caps$[ebp]
  00091	52		 push	 edx
  00092	50		 push	 eax
  00093	ff 51 1c	 call	 DWORD PTR [ecx+28]

; 401  :     m_bHWVertexShaders = Caps.VertexShaderVersion >= D3DVS_VERSION(1,1);

  00096	81 bd 4c fc ff
	ff 01 01 fe ff	 cmp	 DWORD PTR _Caps$[ebp+196], -130815 ; fffe0101H
  000a0	1b c0		 sbb	 eax, eax
  000a2	40		 inc	 eax
  000a3	89 43 48	 mov	 DWORD PTR [ebx+72], eax

; 402  : 
; 403  :     if (cdMesh.CWeights() > 0)

  000a6	8b 45 8c	 mov	 eax, DWORD PTR _cdMesh$[ebp+140]
  000a9	3b c7		 cmp	 eax, edi
  000ab	74 25		 je	 SHORT $L56555
  000ad	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  000b1	40		 inc	 eax
  000b2	3b c7		 cmp	 eax, edi
  000b4	7e 1c		 jle	 SHORT $L56555

; 404  :     {
; 405  :         m_bSkinning = TRUE;

  000b6	33 c0		 xor	 eax, eax
  000b8	40		 inc	 eax

; 406  : 
; 407  :         if (cdMesh.BIndexedWeights())

  000b9	39 7d 90	 cmp	 DWORD PTR _cdMesh$[ebp+144], edi
  000bc	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  000bf	74 0a		 je	 SHORT $L56556

; 408  :         {
; 409  :             dwFVFAdjVertices = INDEXSKINNEDFVF;

  000c1	b9 0e 87 79 1e	 mov	 ecx, 511280910		; 1e79870eH

; 410  :             m_bIndexSkinning = TRUE;

  000c6	89 43 44	 mov	 DWORD PTR [ebx+68], eax

; 411  :         }
; 412  :         else

  000c9	eb 10		 jmp	 SHORT $L56558
$L56556:

; 413  :         {
; 414  :             dwFVFAdjVertices = SKINNEDFVF;

  000cb	b9 0c 05 99 01	 mov	 ecx, 26805516		; 0199050cH

; 415  :             m_bIndexSkinning = FALSE;
; 416  :         }
; 417  :     }
; 418  :     else

  000d0	eb 06		 jmp	 SHORT $L57165
$L56555:

; 419  :     {
; 420  :         dwFVFAdjVertices = D3DFVF_XYZ;

  000d2	6a 02		 push	 2
  000d4	59		 pop	 ecx

; 421  :         m_bSkinning = FALSE;

  000d5	89 7b 40	 mov	 DWORD PTR [ebx+64], edi
$L57165:

; 422  :         m_bIndexSkinning = FALSE;

  000d8	89 7b 44	 mov	 DWORD PTR [ebx+68], edi
$L56558:

; 423  :     }
; 424  :     m_cfvf = DXCrackFVF(dwFVFAdjVertices);

  000db	51		 push	 ecx
  000dc	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR $T57125[ebp]
  000e2	e8 00 00 00 00	 call	 ??0DXCrackFVF@@QAE@K@Z	; DXCrackFVF::DXCrackFVF

; 425  : 
; 426  :     if (rgdwNeighbors == NULL)

  000e7	83 7d 0c 00	 cmp	 DWORD PTR _rgdwNeighbors$[ebp], 0
  000eb	6a 10		 push	 16			; 00000010H
  000ed	59		 pop	 ecx
  000ee	8b f0		 mov	 esi, eax
  000f0	8b fb		 mov	 edi, ebx
  000f2	f3 a5		 rep movsd
  000f4	0f 84 09 04 00
	00		 je	 $L57159

; 427  :         goto e_Exit;
; 428  : 
; 429  :     hr = ptmMesh->GetAttributeTable(NULL, &m_caeAttributeTable);

  000fa	8b 7d 08	 mov	 edi, DWORD PTR _ptmMesh$[ebp]
  000fd	8b 07		 mov	 eax, DWORD PTR [edi]
  000ff	8d 73 58	 lea	 esi, DWORD PTR [ebx+88]
  00102	56		 push	 esi
  00103	6a 00		 push	 0
  00105	57		 push	 edi
  00106	ff 50 4c	 call	 DWORD PTR [eax+76]

; 430  :     if (FAILED(hr))

  00109	85 c0		 test	 eax, eax
  0010b	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  0010e	0f 8c ef 03 00
	00		 jl	 $L57159

; 431  :         goto e_Exit;
; 432  : 
; 433  :     if (m_caeAttributeTable == 0)

  00114	8b 06		 mov	 eax, DWORD PTR [esi]
  00116	85 c0		 test	 eax, eax
  00118	0f 84 e5 03 00
	00		 je	 $L57159

; 434  :     {
; 435  :         // not attribute sorted!  just return for now
; 436  :         goto e_Exit;
; 437  :     }
; 438  : 
; 439  :     rgaeAttributeTableMesh = new D3DXATTRIBUTERANGE[m_caeAttributeTable];

  0011e	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00121	c1 e0 02	 shl	 eax, 2
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0012a	89 45 e4	 mov	 DWORD PTR _rgaeAttributeTableMesh$[ebp], eax

; 440  :     m_rgaeAttributeTable = new D3DXATTRIBUTERANGE[m_caeAttributeTable];

  0012d	8b 06		 mov	 eax, DWORD PTR [esi]
  0012f	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00132	c1 e0 02	 shl	 eax, 2
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 441  :     if ((rgaeAttributeTableMesh == NULL) || (rgaeAttributeTableMesh == NULL))

  0013b	83 7d e4 00	 cmp	 DWORD PTR _rgaeAttributeTableMesh$[ebp], 0
  0013f	59		 pop	 ecx
  00140	59		 pop	 ecx
  00141	89 43 54	 mov	 DWORD PTR [ebx+84], eax
  00144	0f 84 b2 03 00
	00		 je	 $L56572

; 444  :         goto e_Exit;
; 445  :     }
; 446  : 
; 447  :     hr = ptmMesh->GetAttributeTable(rgaeAttributeTableMesh, NULL);

  0014a	8b 07		 mov	 eax, DWORD PTR [edi]
  0014c	6a 00		 push	 0
  0014e	ff 75 e4	 push	 DWORD PTR _rgaeAttributeTableMesh$[ebp]
  00151	57		 push	 edi
  00152	ff 50 4c	 call	 DWORD PTR [eax+76]

; 448  :     if (FAILED(hr))

  00155	85 c0		 test	 eax, eax
  00157	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  0015a	0f 8c a3 03 00
	00		 jl	 $L57159

; 449  :         goto e_Exit;
; 450  : 
; 451  :     cFaces = rgaeAttributeTableMesh[m_caeAttributeTable-1].FaceStart + rgaeAttributeTableMesh[m_caeAttributeTable-1].FaceCount;

  00160	8b 06		 mov	 eax, DWORD PTR [esi]
  00162	8b 4d e4	 mov	 ecx, DWORD PTR _rgaeAttributeTableMesh$[ebp]
  00165	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00168	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0016b	8b 70 f0	 mov	 esi, DWORD PTR [eax-16]
  0016e	03 70 f4	 add	 esi, DWORD PTR [eax-12]

; 452  : 
; 453  :     if (b16BitMesh)

  00171	80 7d fb 00	 cmp	 BYTE PTR _b16BitMesh$[ebp], 0
  00175	74 7e		 je	 SHORT $L56578

; 454  :     {
; 455  :         // allocate a temporary, so that the follow code
; 456  :         //   can work on just 32bit indices
; 457  :         rgdwFaces = new UINT[cFaces*3];

  00177	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  0017a	c1 e0 02	 shl	 eax, 2
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 458  :         if (rgdwFaces == NULL)

  00183	85 c0		 test	 eax, eax
  00185	59		 pop	 ecx
  00186	89 45 e0	 mov	 DWORD PTR _rgdwFaces$[ebp], eax

; 613  :     if (FAILED(hr))
; 614  :         goto e_Exit;
; 615  : 
; 616  : 
; 617  : e_Exit:

  00189	0f 84 6d 03 00
	00		 je	 $L56572
  0018f	8b 07		 mov	 eax, DWORD PTR [edi]
  00191	8d 4d ec	 lea	 ecx, DWORD PTR _pibFaces$[ebp]
  00194	51		 push	 ecx
  00195	57		 push	 edi
  00196	ff 50 38	 call	 DWORD PTR [eax+56]
  00199	85 c0		 test	 eax, eax
  0019b	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  0019e	0f 8c 5f 03 00
	00		 jl	 $L57159
  001a4	8b 45 ec	 mov	 eax, DWORD PTR _pibFaces$[ebp]
  001a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a9	68 00 08 00 00	 push	 2048			; 00000800H
  001ae	8d 55 c4	 lea	 edx, DWORD PTR _rgwFaces$[ebp]
  001b1	52		 push	 edx
  001b2	6a 00		 push	 0
  001b4	6a 00		 push	 0
  001b6	50		 push	 eax
  001b7	ff 51 2c	 call	 DWORD PTR [ecx+44]
  001ba	85 c0		 test	 eax, eax
  001bc	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  001bf	0f 8c 3e 03 00
	00		 jl	 $L57159
  001c5	8d 34 76	 lea	 esi, DWORD PTR [esi+esi*2]
  001c8	33 c0		 xor	 eax, eax
  001ca	85 f6		 test	 esi, esi
  001cc	76 5d		 jbe	 SHORT $L56602
$L56591:

; 459  :         {
; 460  :             hr = E_OUTOFMEMORY;
; 461  :             goto e_Exit;
; 462  :         }
; 463  : 
; 464  :         // get the index buffer
; 465  :         hr = ptmMesh->GetIndexBuffer(&pibFaces);
; 466  :         if (FAILED(hr))
; 467  :             goto e_Exit;
; 468  : 
; 469  :         hr = pibFaces->Lock(0,0, (PVOID*)&rgwFaces, D3DLOCK_NOSYSLOCK );
; 470  :         if (FAILED(hr))
; 471  :             goto e_Exit;
; 472  : 
; 473  :         // UpConvert from 16 bit to 32 bit
; 474  :         for (iIndex = 0; iIndex < cFaces * 3; iIndex++)
; 475  :         {
; 476  :             if (rgwFaces[iIndex] != UNUSED16)

  001ce	8b 4d c4	 mov	 ecx, DWORD PTR _rgwFaces$[ebp]
  001d1	66 8b 0c 41	 mov	 cx, WORD PTR [ecx+eax*2]
  001d5	66 81 f9 ff ff	 cmp	 cx, 65535		; 0000ffffH
  001da	74 0b		 je	 SHORT $L56594

; 477  :                 rgdwFaces[iIndex] = rgwFaces[iIndex];

  001dc	8b 55 e0	 mov	 edx, DWORD PTR _rgdwFaces$[ebp]
  001df	0f b7 c9	 movzx	 ecx, cx
  001e2	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx

; 478  :             else

  001e5	eb 07		 jmp	 SHORT $L56592
$L56594:

; 479  :                 rgdwFaces[iIndex] = UNUSED32;

  001e7	8b 4d e0	 mov	 ecx, DWORD PTR _rgdwFaces$[ebp]
  001ea	83 0c 81 ff	 or	 DWORD PTR [ecx+eax*4], -1
$L56592:
  001ee	40		 inc	 eax
  001ef	3b c6		 cmp	 eax, esi
  001f1	72 db		 jb	 SHORT $L56591

; 480  :         }
; 481  :     }
; 482  :     else

  001f3	eb 36		 jmp	 SHORT $L56602
$L56578:

; 483  :     {
; 484  :         // get the index buffer
; 485  :         hr = ptmMesh->GetIndexBuffer(&pibFaces);

  001f5	8b 07		 mov	 eax, DWORD PTR [edi]
  001f7	8d 4d ec	 lea	 ecx, DWORD PTR _pibFaces$[ebp]
  001fa	51		 push	 ecx
  001fb	57		 push	 edi
  001fc	ff 50 38	 call	 DWORD PTR [eax+56]

; 486  :         if (FAILED(hr))

  001ff	85 c0		 test	 eax, eax
  00201	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00204	0f 8c f9 02 00
	00		 jl	 $L57159

; 487  :             goto e_Exit;
; 488  : 
; 489  :         hr = pibFaces->Lock(0,0, (PVOID*)&rgdwFaces, D3DLOCK_NOSYSLOCK );

  0020a	8b 45 ec	 mov	 eax, DWORD PTR _pibFaces$[ebp]
  0020d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020f	68 00 08 00 00	 push	 2048			; 00000800H
  00214	8d 55 e0	 lea	 edx, DWORD PTR _rgdwFaces$[ebp]
  00217	52		 push	 edx
  00218	6a 00		 push	 0
  0021a	6a 00		 push	 0
  0021c	50		 push	 eax
  0021d	ff 51 2c	 call	 DWORD PTR [ecx+44]

; 490  :         if (FAILED(hr))

  00220	85 c0		 test	 eax, eax
  00222	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00225	0f 8c d8 02 00
	00		 jl	 $L57159
$L56602:

; 491  :             goto e_Exit;
; 492  :     }
; 493  : 
; 494  :     // first count the number of links
; 495  :     cConnections = 0;

  0022b	33 c0		 xor	 eax, eax

; 496  :     iCurLineOffset = 0;

  0022d	33 ff		 xor	 edi, edi

; 497  :     iCurVertexOffset = 0;

  0022f	33 f6		 xor	 esi, esi

; 498  :     for (iae = 0; iae < m_caeAttributeTable; iae++)

  00231	39 43 58	 cmp	 DWORD PTR [ebx+88], eax
  00234	89 45 dc	 mov	 DWORD PTR _cConnections$[ebp], eax
  00237	89 7d c8	 mov	 DWORD PTR _iCurLineOffset$[ebp], edi
  0023a	89 75 d4	 mov	 DWORD PTR _iCurVertexOffset$[ebp], esi
  0023d	89 45 e8	 mov	 DWORD PTR _iae$[ebp], eax
  00240	0f 86 9b 00 00
	00		 jbe	 $L56606
  00246	8b 4d e4	 mov	 ecx, DWORD PTR _rgaeAttributeTableMesh$[ebp]
  00249	83 c1 04	 add	 ecx, 4
  0024c	89 4d d8	 mov	 DWORD PTR tv1172[ebp], ecx
$L57160:

; 499  :     {
; 500  :         m_rgaeAttributeTable[iae].AttribId = rgaeAttributeTableMesh[iae].AttribId;

  0024f	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  00252	8b 55 d8	 mov	 edx, DWORD PTR tv1172[ebp]
  00255	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  00258	89 14 08	 mov	 DWORD PTR [eax+ecx], edx

; 501  : 
; 502  :         // initialize line counts
; 503  :         m_rgaeAttributeTable[iae].FaceStart = iCurLineOffset;

  0025b	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  0025e	89 7c 08 04	 mov	 DWORD PTR [eax+ecx+4], edi

; 504  :         m_rgaeAttributeTable[iae].FaceCount = 0;

  00262	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  00265	83 64 08 08 00	 and	 DWORD PTR [eax+ecx+8], 0

; 505  : 
; 506  :         iFaceEnd = rgaeAttributeTableMesh[iae].FaceStart + rgaeAttributeTableMesh[iae].FaceCount;

  0026a	8b 4d d8	 mov	 ecx, DWORD PTR tv1172[ebp]
  0026d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0026f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00272	03 ca		 add	 ecx, edx

; 507  :         for (iFace = rgaeAttributeTableMesh[iae].FaceStart; iFace < iFaceEnd; iFace++)

  00274	3b d1		 cmp	 edx, ecx
  00276	73 2e		 jae	 SHORT $L56609
  00278	8b 7d 0c	 mov	 edi, DWORD PTR _rgdwNeighbors$[ebp]
  0027b	8d 34 52	 lea	 esi, DWORD PTR [edx+edx*2]
  0027e	8d 34 b7	 lea	 esi, DWORD PTR [edi+esi*4]
  00281	2b ca		 sub	 ecx, edx
$L56607:

; 508  :         {
; 509  :             for (iPoint = 0; iPoint < 3; iPoint++)

  00283	6a 03		 push	 3
  00285	5f		 pop	 edi
$L56610:

; 510  :             {
; 511  :                 if (rgdwNeighbors[iFace*3 + iPoint] != UNUSED32)

  00286	83 3e ff	 cmp	 DWORD PTR [esi], -1
  00289	74 0c		 je	 SHORT $L56611

; 512  :                 {
; 513  :                     cConnections += 1;
; 514  :                     m_rgaeAttributeTable[iae].FaceCount += 1;

  0028b	8b 53 54	 mov	 edx, DWORD PTR [ebx+84]
  0028e	ff 45 dc	 inc	 DWORD PTR _cConnections$[ebp]
  00291	8d 54 10 08	 lea	 edx, DWORD PTR [eax+edx+8]
  00295	ff 02		 inc	 DWORD PTR [edx]
$L56611:
  00297	83 c6 04	 add	 esi, 4
  0029a	4f		 dec	 edi
  0029b	75 e9		 jne	 SHORT $L56610

; 507  :         for (iFace = rgaeAttributeTableMesh[iae].FaceStart; iFace < iFaceEnd; iFace++)

  0029d	49		 dec	 ecx
  0029e	75 e3		 jne	 SHORT $L56607
  002a0	8b 75 d4	 mov	 esi, DWORD PTR _iCurVertexOffset$[ebp]
  002a3	8b 7d c8	 mov	 edi, DWORD PTR _iCurLineOffset$[ebp]
$L56609:

; 515  :                 }
; 516  :             }
; 517  :         }
; 518  : 
; 519  :         m_rgaeAttributeTable[iae].VertexStart = iCurVertexOffset;

  002a6	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  002a9	83 45 d8 14	 add	 DWORD PTR tv1172[ebp], 20 ; 00000014H
  002ad	89 74 08 0c	 mov	 DWORD PTR [eax+ecx+12], esi

; 520  :         m_rgaeAttributeTable[iae].VertexCount = m_rgaeAttributeTable[iae].FaceCount*2;

  002b1	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  002b4	03 c8		 add	 ecx, eax
  002b6	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002b9	d1 e2		 shl	 edx, 1
  002bb	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 521  : 
; 522  :         iCurLineOffset += m_rgaeAttributeTable[iae].FaceCount;

  002be	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  002c1	03 c8		 add	 ecx, eax
  002c3	03 79 08	 add	 edi, DWORD PTR [ecx+8]

; 523  :         iCurVertexOffset += m_rgaeAttributeTable[iae].VertexCount;

  002c6	03 71 10	 add	 esi, DWORD PTR [ecx+16]
  002c9	ff 45 e8	 inc	 DWORD PTR _iae$[ebp]
  002cc	8b 4d e8	 mov	 ecx, DWORD PTR _iae$[ebp]
  002cf	83 c0 14	 add	 eax, 20			; 00000014H
  002d2	3b 4b 58	 cmp	 ecx, DWORD PTR [ebx+88]
  002d5	89 7d c8	 mov	 DWORD PTR _iCurLineOffset$[ebp], edi
  002d8	89 75 d4	 mov	 DWORD PTR _iCurVertexOffset$[ebp], esi
  002db	0f 82 6e ff ff
	ff		 jb	 $L57160
$L56606:

; 524  :     }
; 525  : 
; 526  :     // should be even, otherwise the adjacency info is definitely incorrect
; 527  :     GXASSERT((cConnections & 1) == 0);
; 528  :     cPointsMax = cConnections * 2;

  002e1	8b 4d dc	 mov	 ecx, DWORD PTR _cConnections$[ebp]
  002e4	03 c9		 add	 ecx, ecx

; 529  : 
; 530  :     // UNDONE UNDONE, need to handle large line lists
; 531  :     //if (cConnections >= UNUSED16)
; 532  :       //  goto e_Exit;
; 533  : 
; 534  :     if (cPointsMax == 0)

  002e6	0f 84 17 02 00
	00		 je	 $L57159

; 535  :         goto e_Exit;
; 536  : 
; 537  :     hr = pDevice->CreateVertexBuffer(m_cfvf.m_cBytesPerVertex * cPointsMax, 
; 538  :                         D3DUSAGE_WRITEONLY|(m_bHWVertexShaders ? 0:D3DUSAGE_SOFTWAREPROCESSING), 
; 539  :                         m_cfvf.m_dwFVF, D3DPOOL_MANAGED, &m_pVertexBuffer, NULL);

  002ec	8b 7b 48	 mov	 edi, DWORD PTR [ebx+72]
  002ef	8b 45 cc	 mov	 eax, DWORD PTR _pDevice$[ebp]
  002f2	8b 10		 mov	 edx, DWORD PTR [eax]
  002f4	6a 00		 push	 0
  002f6	f7 df		 neg	 edi
  002f8	1b ff		 sbb	 edi, edi
  002fa	8d 73 4c	 lea	 esi, DWORD PTR [ebx+76]
  002fd	56		 push	 esi
  002fe	6a 01		 push	 1
  00300	ff 33		 push	 DWORD PTR [ebx]
  00302	83 e7 f0	 and	 edi, -16		; fffffff0H
  00305	83 c7 10	 add	 edi, 16			; 00000010H
  00308	83 cf 08	 or	 edi, 8
  0030b	57		 push	 edi
  0030c	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  0030f	0f af f9	 imul	 edi, ecx
  00312	57		 push	 edi
  00313	50		 push	 eax
  00314	ff 52 68	 call	 DWORD PTR [edx+104]

; 540  :     if (FAILED(hr))

  00317	85 c0		 test	 eax, eax
  00319	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  0031c	0f 8c e1 01 00
	00		 jl	 $L57159

; 541  :         goto e_Exit;
; 542  : 
; 543  :     m_pVertexBuffer->Lock(0, 0, (PVOID*)&pvLinePoints, 0);

  00322	8b 36		 mov	 esi, DWORD PTR [esi]
  00324	8b 06		 mov	 eax, DWORD PTR [esi]
  00326	33 ff		 xor	 edi, edi
  00328	57		 push	 edi
  00329	8d 4d f0	 lea	 ecx, DWORD PTR _pvLinePoints$[ebp]
  0032c	51		 push	 ecx
  0032d	57		 push	 edi
  0032e	57		 push	 edi
  0032f	56		 push	 esi
  00330	ff 50 2c	 call	 DWORD PTR [eax+44]

; 544  : 
; 545  :     hr = ptmMesh->GetVertexBuffer(&pVBVertices);

  00333	8b 45 08	 mov	 eax, DWORD PTR _ptmMesh$[ebp]
  00336	8b 08		 mov	 ecx, DWORD PTR [eax]
  00338	8d 55 d0	 lea	 edx, DWORD PTR _pVBVertices$[ebp]
  0033b	52		 push	 edx
  0033c	50		 push	 eax
  0033d	ff 51 34	 call	 DWORD PTR [ecx+52]

; 546  :     if (FAILED(hr))

  00340	3b c7		 cmp	 eax, edi
  00342	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00345	0f 8c b8 01 00
	00		 jl	 $L57159

; 547  :         goto e_Exit;
; 548  : 
; 549  :     hr = pVBVertices->Lock(0,0, (PVOID*)&pvMeshPoints, D3DLOCK_NOSYSLOCK );

  0034b	8b 45 d0	 mov	 eax, DWORD PTR _pVBVertices$[ebp]
  0034e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00350	68 00 08 00 00	 push	 2048			; 00000800H
  00355	8d 55 f4	 lea	 edx, DWORD PTR _pvMeshPoints$[ebp]
  00358	52		 push	 edx
  00359	57		 push	 edi
  0035a	57		 push	 edi
  0035b	50		 push	 eax
  0035c	ff 51 2c	 call	 DWORD PTR [ecx+44]

; 550  :     if (FAILED(hr))

  0035f	85 c0		 test	 eax, eax
  00361	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00364	0f 8c 99 01 00
	00		 jl	 $L57159

; 551  :         goto e_Exit;
; 552  : 
; 553  :     iCurPoint = 0;

  0036a	33 c0		 xor	 eax, eax

; 554  :     iline = 0;
; 555  :     for (iae = 0; iae < m_caeAttributeTable; iae++)

  0036c	39 43 58	 cmp	 DWORD PTR [ebx+88], eax
  0036f	89 45 fc	 mov	 DWORD PTR _iCurPoint$[ebp], eax
  00372	89 45 e8	 mov	 DWORD PTR _iae$[ebp], eax
  00375	0f 86 17 01 00
	00		 jbe	 $L56630
  0037b	8b 55 e4	 mov	 edx, DWORD PTR _rgaeAttributeTableMesh$[ebp]
  0037e	83 c2 04	 add	 edx, 4
  00381	89 55 d4	 mov	 DWORD PTR tv1276[ebp], edx
$L56628:

; 556  :     {
; 557  :         iFaceEnd = rgaeAttributeTableMesh[iae].FaceStart + rgaeAttributeTableMesh[iae].FaceCount;

  00384	8b 02		 mov	 eax, DWORD PTR [edx]
  00386	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00389	03 c8		 add	 ecx, eax

; 558  :         for (iFace = rgaeAttributeTableMesh[iae].FaceStart; iFace < iFaceEnd; iFace++)

  0038b	3b c1		 cmp	 eax, ecx
  0038d	89 4d d8	 mov	 DWORD PTR _iFaceEnd$[ebp], ecx
  00390	89 45 dc	 mov	 DWORD PTR _iFace$[ebp], eax
  00393	0f 83 e4 00 00
	00		 jae	 $L56629
  00399	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  0039c	c1 e7 02	 shl	 edi, 2
$L57162:

; 559  :         {
; 560  :             pdwNeighbor = &rgdwNeighbors[iFace * 3];

  0039f	8b 45 0c	 mov	 eax, DWORD PTR _rgdwNeighbors$[ebp]
  003a2	03 c7		 add	 eax, edi
  003a4	89 45 c8	 mov	 DWORD PTR _pdwNeighbor$[ebp], eax

; 561  :             pdwFaceCur = &rgdwFaces[iFace * 3];

  003a7	8b 45 e0	 mov	 eax, DWORD PTR _rgdwFaces$[ebp]
  003aa	8d 34 07	 lea	 esi, DWORD PTR [edi+eax]

; 562  :             if (pdwFaceCur[0] == UNUSED32)

  003ad	83 3e ff	 cmp	 DWORD PTR [esi], -1
  003b0	0f 84 c4 00 00
	00		 je	 $L57164

; 563  :                 break;
; 564  : 
; 565  :             for (iPoint = 0; iPoint < 3; iPoint++)

  003b6	83 65 08 00	 and	 DWORD PTR _iPoint$[ebp], 0
$L57163:

; 566  :             {
; 567  :                 if (pdwNeighbor[iPoint] != UNUSED32)

  003ba	8b 45 c8	 mov	 eax, DWORD PTR _pdwNeighbor$[ebp]
  003bd	8b 4d 08	 mov	 ecx, DWORD PTR _iPoint$[ebp]
  003c0	83 3c 88 ff	 cmp	 DWORD PTR [eax+ecx*4], -1
  003c4	0f 84 91 00 00
	00		 je	 $L56636

; 568  :                 {
; 569  :                     if (m_bIndexSkinning)

  003ca	83 7b 44 00	 cmp	 DWORD PTR [ebx+68], 0

; 570  :                     {
; 571  :                         AppendPointIndexSkinned(cdMesh, pdwFaceCur, iPoint, pvMeshPoints, pvLinePoints, iCurPoint);

  003ce	8d 45 fc	 lea	 eax, DWORD PTR _iCurPoint$[ebp]
  003d1	50		 push	 eax
  003d2	ff 75 f0	 push	 DWORD PTR _pvLinePoints$[ebp]
  003d5	8b cb		 mov	 ecx, ebx
  003d7	ff 75 f4	 push	 DWORD PTR _pvMeshPoints$[ebp]
  003da	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _cdMesh$[ebp]
  003e0	74 28		 je	 SHORT $L56639
  003e2	ff 75 08	 push	 DWORD PTR _iPoint$[ebp]
  003e5	56		 push	 esi
  003e6	50		 push	 eax
  003e7	e8 00 00 00 00	 call	 ?AppendPointIndexSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ; CAdjacencyOutline::AppendPointIndexSkinned

; 572  : 
; 573  :                         AppendMidpointIndexSkinned(cdMesh, pdwFaceCur, iPoint, pvMeshPoints, pvLinePoints, iCurPoint);

  003ec	8d 45 fc	 lea	 eax, DWORD PTR _iCurPoint$[ebp]
  003ef	50		 push	 eax
  003f0	ff 75 f0	 push	 DWORD PTR _pvLinePoints$[ebp]
  003f3	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _cdMesh$[ebp]
  003f9	ff 75 f4	 push	 DWORD PTR _pvMeshPoints$[ebp]
  003fc	8b cb		 mov	 ecx, ebx
  003fe	ff 75 08	 push	 DWORD PTR _iPoint$[ebp]
  00401	56		 push	 esi
  00402	50		 push	 eax
  00403	e8 00 00 00 00	 call	 ?AppendMidpointIndexSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ; CAdjacencyOutline::AppendMidpointIndexSkinned

; 574  :                     }
; 575  :                     else if (m_bSkinning)

  00408	eb 51		 jmp	 SHORT $L56636
$L56639:
  0040a	83 7b 40 00	 cmp	 DWORD PTR [ebx+64], 0
  0040e	74 28		 je	 SHORT $L56641

; 576  :                     {
; 577  :                         AppendPointSkinned(cdMesh, pdwFaceCur, iPoint, pvMeshPoints, pvLinePoints, iCurPoint);

  00410	ff 75 08	 push	 DWORD PTR _iPoint$[ebp]
  00413	56		 push	 esi
  00414	50		 push	 eax
  00415	e8 00 00 00 00	 call	 ?AppendPointSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ; CAdjacencyOutline::AppendPointSkinned

; 578  : 
; 579  :                         AppendMidpointSkinned(cdMesh, pdwFaceCur, iPoint, pvMeshPoints, pvLinePoints, iCurPoint);

  0041a	8d 45 fc	 lea	 eax, DWORD PTR _iCurPoint$[ebp]
  0041d	50		 push	 eax
  0041e	ff 75 f0	 push	 DWORD PTR _pvLinePoints$[ebp]
  00421	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _cdMesh$[ebp]
  00427	ff 75 f4	 push	 DWORD PTR _pvMeshPoints$[ebp]
  0042a	8b cb		 mov	 ecx, ebx
  0042c	ff 75 08	 push	 DWORD PTR _iPoint$[ebp]
  0042f	56		 push	 esi
  00430	50		 push	 eax
  00431	e8 00 00 00 00	 call	 ?AppendMidpointSkinned@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ; CAdjacencyOutline::AppendMidpointSkinned

; 580  :                     }
; 581  :                     else

  00436	eb 23		 jmp	 SHORT $L56636
$L56641:

; 582  :                     {
; 583  :                         AppendPoint(cdMesh, pdwFaceCur, pvMeshPoints, pvLinePoints, iCurPoint);

  00438	56		 push	 esi
  00439	50		 push	 eax
  0043a	e8 00 00 00 00	 call	 ?AppendPoint@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIPAE2AAI@Z ; CAdjacencyOutline::AppendPoint

; 584  : 
; 585  :                         AppendMidpoint(cdMesh, pdwFaceCur, iPoint, pvMeshPoints, pvLinePoints, iCurPoint);

  0043f	8d 45 fc	 lea	 eax, DWORD PTR _iCurPoint$[ebp]
  00442	50		 push	 eax
  00443	ff 75 f0	 push	 DWORD PTR _pvLinePoints$[ebp]
  00446	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _cdMesh$[ebp]
  0044c	ff 75 f4	 push	 DWORD PTR _pvMeshPoints$[ebp]
  0044f	8b cb		 mov	 ecx, ebx
  00451	ff 75 08	 push	 DWORD PTR _iPoint$[ebp]
  00454	56		 push	 esi
  00455	50		 push	 eax
  00456	e8 00 00 00 00	 call	 ?AppendMidpoint@CAdjacencyOutline@@AAEXAAVCD3DXCrackDecl1@@PAIIPAE2AAI@Z ; CAdjacencyOutline::AppendMidpoint
$L56636:
  0045b	ff 45 08	 inc	 DWORD PTR _iPoint$[ebp]
  0045e	83 7d 08 03	 cmp	 DWORD PTR _iPoint$[ebp], 3
  00462	0f 82 52 ff ff
	ff		 jb	 $L57163
  00468	ff 45 dc	 inc	 DWORD PTR _iFace$[ebp]
  0046b	8b 45 dc	 mov	 eax, DWORD PTR _iFace$[ebp]
  0046e	83 c7 0c	 add	 edi, 12			; 0000000cH
  00471	3b 45 d8	 cmp	 eax, DWORD PTR _iFaceEnd$[ebp]
  00474	0f 82 25 ff ff
	ff		 jb	 $L57162
$L57164:

; 558  :         for (iFace = rgaeAttributeTableMesh[iae].FaceStart; iFace < iFaceEnd; iFace++)

  0047a	8b 55 d4	 mov	 edx, DWORD PTR tv1276[ebp]
$L56629:

; 554  :     iline = 0;
; 555  :     for (iae = 0; iae < m_caeAttributeTable; iae++)

  0047d	ff 45 e8	 inc	 DWORD PTR _iae$[ebp]
  00480	8b 45 e8	 mov	 eax, DWORD PTR _iae$[ebp]
  00483	83 c2 14	 add	 edx, 20			; 00000014H
  00486	3b 43 58	 cmp	 eax, DWORD PTR [ebx+88]
  00489	89 55 d4	 mov	 DWORD PTR tv1276[ebp], edx
  0048c	0f 82 f2 fe ff
	ff		 jb	 $L56628
$L56630:

; 586  :                     }
; 587  : 
; 588  :                     iline += 1;
; 589  :                 }
; 590  :             }
; 591  :         }
; 592  :     }
; 593  : 
; 594  :     // create a vertex declaration, so that we can have D3DCOLOR instead of UBYTE4 for the matrix indices 
; 595  :     hr = D3DXDeclaratorFromFVF(m_cfvf.m_dwFVF, pDecl);

  00492	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _pDecl$[ebp]
  00498	50		 push	 eax
  00499	ff 33		 push	 DWORD PTR [ebx]
  0049b	e8 00 00 00 00	 call	 _D3DXDeclaratorFromFVF@8

; 596  :     if (FAILED(hr))

  004a0	85 c0		 test	 eax, eax
  004a2	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  004a5	7c 5c		 jl	 SHORT $L57159

; 601  :     while (pDeclCur->Stream != 0xff)

  004a7	66 81 bd b8 fc
	ff ff ff 00	 cmp	 WORD PTR _pDecl$[ebp], 255 ; 000000ffH
  004b0	74 1f		 je	 SHORT $L56651

; 597  :         goto e_Exit;
; 598  : 
; 599  :     // swap the type of any blendilndices to D3DCOLOR
; 600  :     pDeclCur = pDecl;

  004b2	8d 85 bc fc ff
	ff		 lea	 eax, DWORD PTR _pDecl$[ebp+4]
$L56647:

; 602  :     {
; 603  :         if ((pDeclCur->Usage == D3DDECLUSAGE_BLENDINDICES) || (pDeclCur->Type == D3DDECLTYPE_FLOAT1))

  004b8	80 78 02 02	 cmp	 BYTE PTR [eax+2], 2
  004bc	74 05		 je	 SHORT $L56650
  004be	80 38 00	 cmp	 BYTE PTR [eax], 0
  004c1	75 03		 jne	 SHORT $L56649
$L56650:

; 604  :         {
; 605  :             //pDeclCur->Type = D3DDECLTYPE_UBYTE4;
; 606  :             pDeclCur->Type = D3DDECLTYPE_D3DCOLOR;

  004c3	c6 00 04	 mov	 BYTE PTR [eax], 4
$L56649:

; 607  :         }
; 608  :         pDeclCur++;

  004c6	83 c0 08	 add	 eax, 8
  004c9	66 81 78 fc ff
	00		 cmp	 WORD PTR [eax-4], 255	; 000000ffH
  004cf	75 e7		 jne	 SHORT $L56647
$L56651:

; 609  :     }
; 610  : 
; 611  :     GXRELEASE(m_pDecl);

  004d1	8d 73 50	 lea	 esi, DWORD PTR [ebx+80]
  004d4	8b 06		 mov	 eax, DWORD PTR [esi]
  004d6	85 c0		 test	 eax, eax
  004d8	74 09		 je	 SHORT $L56652
  004da	8b 08		 mov	 ecx, DWORD PTR [eax]
  004dc	50		 push	 eax
  004dd	ff 51 08	 call	 DWORD PTR [ecx+8]
  004e0	83 26 00	 and	 DWORD PTR [esi], 0
$L56652:

; 612  :     hr = pDevice->CreateVertexDeclaration(pDecl, &m_pDecl);

  004e3	8b 45 cc	 mov	 eax, DWORD PTR _pDevice$[ebp]
  004e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  004e8	56		 push	 esi
  004e9	8d 95 b8 fc ff
	ff		 lea	 edx, DWORD PTR _pDecl$[ebp]
  004ef	52		 push	 edx
  004f0	50		 push	 eax
  004f1	ff 91 58 01 00
	00		 call	 DWORD PTR [ecx+344]
  004f7	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 613  :     if (FAILED(hr))
; 614  :         goto e_Exit;
; 615  : 
; 616  : 
; 617  : e_Exit:

  004fa	eb 07		 jmp	 SHORT $L57159
$L56572:

; 442  :     {
; 443  :         hr = E_OUTOFMEMORY;

  004fc	c7 45 fc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L57159:
  00503	33 ff		 xor	 edi, edi
$e_Exit$56553:

; 618  :     if (pvLinePoints != NULL)

  00505	39 7d f0	 cmp	 DWORD PTR _pvLinePoints$[ebp], edi
  00508	74 09		 je	 SHORT $L56658

; 619  :     {
; 620  :         m_pVertexBuffer->Unlock();

  0050a	8b 5b 4c	 mov	 ebx, DWORD PTR [ebx+76]
  0050d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0050f	53		 push	 ebx
  00510	ff 50 30	 call	 DWORD PTR [eax+48]
$L56658:

; 621  :     }
; 622  : 
; 623  :     // if a 16 bit mesh, then rgdwFaces is a temporary array
; 624  :     if (b16BitMesh)

  00513	80 7d fb 00	 cmp	 BYTE PTR _b16BitMesh$[ebp], 0
  00517	74 0e		 je	 SHORT $L56659

; 625  :     {
; 626  :         delete []rgdwFaces;

  00519	ff 75 e0	 push	 DWORD PTR _rgdwFaces$[ebp]
  0051c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 627  : 
; 628  :         if (rgwFaces != NULL)

  00521	39 7d c4	 cmp	 DWORD PTR _rgwFaces$[ebp], edi
  00524	59		 pop	 ecx

; 629  :         {
; 630  :             pibFaces->Unlock();
; 631  :         }
; 632  :     }
; 633  :     else

  00525	eb 03		 jmp	 SHORT $L57166
$L56659:

; 634  :     {
; 635  :         if (rgdwFaces != NULL)

  00527	39 7d e0	 cmp	 DWORD PTR _rgdwFaces$[ebp], edi
$L57166:
  0052a	74 09		 je	 SHORT $L56664

; 636  :         {
; 637  :             pibFaces->Unlock();

  0052c	8b 45 ec	 mov	 eax, DWORD PTR _pibFaces$[ebp]
  0052f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00531	50		 push	 eax
  00532	ff 51 30	 call	 DWORD PTR [ecx+48]
$L56664:

; 638  :         }
; 639  :     }
; 640  :     GXRELEASE(pibFaces);

  00535	8b 45 ec	 mov	 eax, DWORD PTR _pibFaces$[ebp]
  00538	3b c7		 cmp	 eax, edi
  0053a	74 09		 je	 SHORT $L56665
  0053c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0053e	50		 push	 eax
  0053f	ff 51 08	 call	 DWORD PTR [ecx+8]
  00542	89 7d ec	 mov	 DWORD PTR _pibFaces$[ebp], edi
$L56665:

; 641  : 
; 642  :     if (pvMeshPoints)

  00545	39 7d f4	 cmp	 DWORD PTR _pvMeshPoints$[ebp], edi
  00548	74 09		 je	 SHORT $L56670

; 643  :     {
; 644  :         GXASSERT(pVBVertices != NULL);
; 645  :         pVBVertices->Unlock();

  0054a	8b 45 d0	 mov	 eax, DWORD PTR _pVBVertices$[ebp]
  0054d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0054f	50		 push	 eax
  00550	ff 51 30	 call	 DWORD PTR [ecx+48]
$L56670:

; 646  :     }
; 647  :     GXRELEASE(pVBVertices);

  00553	8b 45 d0	 mov	 eax, DWORD PTR _pVBVertices$[ebp]
  00556	3b c7		 cmp	 eax, edi
  00558	74 09		 je	 SHORT $L56671
  0055a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0055c	50		 push	 eax
  0055d	ff 51 08	 call	 DWORD PTR [ecx+8]
  00560	89 7d d0	 mov	 DWORD PTR _pVBVertices$[ebp], edi
$L56671:

; 648  : 
; 649  :     delete []rgaeAttributeTableMesh;

  00563	ff 75 e4	 push	 DWORD PTR _rgaeAttributeTableMesh$[ebp]
  00566	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 650  : 
; 651  :     return hr;

  0056b	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  0056e	59		 pop	 ecx
  0056f	5f		 pop	 edi
  00570	5e		 pop	 esi
  00571	5b		 pop	 ebx

; 652  : }

  00572	c9		 leave
  00573	c2 08 00	 ret	 8
?Init@CAdjacencyOutline@@QAEJPAUID3DXBaseMesh@@PAK@Z ENDP ; CAdjacencyOutline::Init
_TEXT	ENDS
PUBLIC	??_C@_04BEMIBDAE@mTot?$AA@			; `string'
PUBLIC	??_C@_07HHMNENJH@mWorlds?$AA@			; `string'
PUBLIC	??_C@_04JKCKMDGO@vClr?$AA@			; `string'
PUBLIC	?Draw@CAdjacencyOutline@@QAEJPAUIDirect3DDevice9@@KPAUID3DXEffect@@1KPAUD3DXMATRIX@@K@Z ; CAdjacencyOutline::Draw
EXTRN	_D3DXMatrixMultiply@12:NEAR
;	COMDAT ??_C@_04BEMIBDAE@mTot?$AA@
; File d:\builds\nt32_fre\public\sdk\inc\d3dx9math.inl
CONST	SEGMENT
??_C@_04BEMIBDAE@mTot?$AA@ DB 'mTot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HHMNENJH@mWorlds?$AA@
CONST	SEGMENT
??_C@_07HHMNENJH@mWorlds?$AA@ DB 'mWorlds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JKCKMDGO@vClr?$AA@
CONST	SEGMENT
??_C@_04JKCKMDGO@vClr?$AA@ DB 'vClr', 00H		; `string'
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\adjoutline.cpp
CONST	ENDS
;	COMDAT ?Draw@CAdjacencyOutline@@QAEJPAUIDirect3DDevice9@@KPAUID3DXEffect@@1KPAUD3DXMATRIX@@K@Z
_TEXT	SEGMENT
_matTot$ = -280						; size = 64
_matProj$ = -216					; size = 64
_matView$ = -152					; size = 64
_matWorld$ = -88					; size = 64
_vClr$ = -24						; size = 16
_dwSoftwareMode$ = -8					; size = 4
_bChangedSWMode$ = -4					; size = 4
tv681 = 8						; size = 4
tv532 = 8						; size = 4
_pDevice$ = 8						; size = 4
_iAttrib$ = 12						; size = 4
_pfxCurrent$ = 16					; size = 4
_pfxSkinnedAdjacency$ = 16				; size = 4
_cPasses$ = 20						; size = 4
_pfxColor$ = 20						; size = 4
tv648 = 24						; size = 4
tv647 = 24						; size = 4
tv646 = 24						; size = 4
tv645 = 24						; size = 4
tv472 = 24						; size = 4
_iVertexStart$ = 24					; size = 4
_iMatrix$ = 24						; size = 4
_dwColor$ = 24						; size = 4
_cLinesCur$ = 28					; size = 4
_rgmIndexedMatrices$ = 28				; size = 4
_iPass$ = 32						; size = 4
_cIndexedMatrices$ = 32					; size = 4
?Draw@CAdjacencyOutline@@QAEJPAUIDirect3DDevice9@@KPAUID3DXEffect@@1KPAUD3DXMATRIX@@K@Z PROC NEAR ; CAdjacencyOutline::Draw, COMDAT
; _this$ = ecx

; 823  : }

  00000	8b ff		 npad	 2

; 673  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H

; 674  :     HRESULT hr;
; 675  :     LPD3DXEFFECT pfxCurrent;
; 676  :     DWORD dwFVF;
; 677  :     UINT iPass;
; 678  :     UINT cPasses;
; 679  :     DWORD cBytesPerVertex;
; 680  :     D3DXMATRIX matWorld;
; 681  :     D3DXMATRIX matView;
; 682  :     D3DXMATRIX matProj;
; 683  :     D3DXMATRIX matTot;
; 684  :     D3DXCOLOR vClr(dwColor);

  0000b	8b 45 18	 mov	 eax, DWORD PTR _dwColor$[ebp]
  0000e	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3b808081
  00014	53		 push	 ebx
  00015	8b d9		 mov	 ebx, ecx
  00017	8b c8		 mov	 ecx, eax
  00019	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0001c	0f b6 c9	 movzx	 ecx, cl
  0001f	89 4d 18	 mov	 DWORD PTR tv648[ebp], ecx
  00022	8b c8		 mov	 ecx, eax
  00024	c1 e9 08	 shr	 ecx, 8
  00027	db 45 18	 fild	 DWORD PTR tv648[ebp]
  0002a	0f b6 c9	 movzx	 ecx, cl
  0002d	d8 c9		 fmul	 ST(0), ST(1)
  0002f	89 4d 18	 mov	 DWORD PTR tv647[ebp], ecx
  00032	0f b6 c8	 movzx	 ecx, al
  00035	d9 5d e8	 fstp	 DWORD PTR _vClr$[ebp]
  00038	db 45 18	 fild	 DWORD PTR tv647[ebp]
  0003b	89 4d 18	 mov	 DWORD PTR tv646[ebp], ecx
  0003e	c1 e8 18	 shr	 eax, 24			; 00000018H
  00041	56		 push	 esi
  00042	d8 c9		 fmul	 ST(0), ST(1)

; 685  :     DWORD cLines;
; 686  :     DWORD cLinesCur;
; 687  :     DWORD iVertexStart;
; 688  : 	BOOL  dwSoftwareMode;
; 689  :     BOOL bChangedSWMode = FALSE;
; 690  :     DWORD iMatrix;
; 691  :     DWORD iSubset;
; 692  : 
; 693  :     if (m_bSkinning)

  00044	8b 75 08	 mov	 esi, DWORD PTR _pDevice$[ebp]
  00047	57		 push	 edi
  00048	d9 5d ec	 fstp	 DWORD PTR _vClr$[ebp+4]
  0004b	db 45 18	 fild	 DWORD PTR tv646[ebp]
  0004e	89 45 18	 mov	 DWORD PTR tv645[ebp], eax
  00051	33 c0		 xor	 eax, eax
  00053	39 43 40	 cmp	 DWORD PTR [ebx+64], eax
  00056	d8 c9		 fmul	 ST(0), ST(1)
  00058	89 45 fc	 mov	 DWORD PTR _bChangedSWMode$[ebp], eax
  0005b	d9 5d f0	 fstp	 DWORD PTR _vClr$[ebp+8]
  0005e	db 45 18	 fild	 DWORD PTR tv645[ebp]
  00061	d8 c9		 fmul	 ST(0), ST(1)
  00063	d9 5d f4	 fstp	 DWORD PTR _vClr$[ebp+12]
  00066	dd d8		 fstp	 ST(0)
  00068	0f 84 1a 02 00
	00		 je	 $L56732

; 694  :     {
; 695  :         if (!m_bIndexSkinning)
; 696  :         {
; 697  :             // non-indexed skinning setup
; 698  :             pfxCurrent = pfxSkinnedAdjacency;

  0006e	8b 7d 10	 mov	 edi, DWORD PTR _pfxSkinnedAdjacency$[ebp]
  00071	39 43 44	 cmp	 DWORD PTR [ebx+68], eax

; 699  :             pfxSkinnedAdjacency->SetTechnique(pfxSkinnedAdjacency->GetTechnique(0));

  00074	8b 07		 mov	 eax, DWORD PTR [edi]
  00076	89 7d 10	 mov	 DWORD PTR _pfxCurrent$[ebp], edi
  00079	89 45 18	 mov	 DWORD PTR tv472[ebp], eax
  0007c	0f 85 0b 01 00
	00		 jne	 $L56733
  00082	6a 00		 push	 0
  00084	57		 push	 edi
  00085	ff 50 30	 call	 DWORD PTR [eax+48]
  00088	50		 push	 eax
  00089	8b 45 18	 mov	 eax, DWORD PTR tv472[ebp]
  0008c	57		 push	 edi
  0008d	ff 90 f0 00 00
	00		 call	 DWORD PTR [eax+240]

; 700  : 
; 701  :             pDevice->GetTransform(D3DTS_VIEW,&matView);

  00093	8b 06		 mov	 eax, DWORD PTR [esi]
  00095	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _matView$[ebp]
  0009b	51		 push	 ecx
  0009c	6a 02		 push	 2
  0009e	56		 push	 esi
  0009f	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 702  :             pDevice->GetTransform(D3DTS_PROJECTION,&matProj);

  000a5	8b 06		 mov	 eax, DWORD PTR [esi]
  000a7	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _matProj$[ebp]
  000ad	51		 push	 ecx
  000ae	6a 03		 push	 3
  000b0	56		 push	 esi
  000b1	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 703  :             pDevice->GetTransform(D3DTS_WORLD,&matWorld);

  000b7	8b 06		 mov	 eax, DWORD PTR [esi]
  000b9	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  000bc	51		 push	 ecx
  000bd	68 00 01 00 00	 push	 256			; 00000100H
  000c2	56		 push	 esi
  000c3	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 704  : 
; 705  :             D3DXMatrixMultiply(&matTot,&matView,&matProj);

  000c9	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _matProj$[ebp]
  000cf	50		 push	 eax
  000d0	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _matView$[ebp]
  000d6	50		 push	 eax
  000d7	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _matTot$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 706  :             pfxSkinnedAdjacency->SetMatrix("mTot", &matTot);                       

  000e3	8b 07		 mov	 eax, DWORD PTR [edi]
  000e5	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _matTot$[ebp]
  000eb	51		 push	 ecx
  000ec	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04BEMIBDAE@mTot?$AA@
  000f1	57		 push	 edi
  000f2	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 707  : 
; 708  :             pDevice->GetTransform(D3DTS_WORLD,&matWorld);

  000f8	8b 06		 mov	 eax, DWORD PTR [esi]
  000fa	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  000fd	51		 push	 ecx
  000fe	68 00 01 00 00	 push	 256			; 00000100H
  00103	56		 push	 esi
  00104	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 709  :             pfxSkinnedAdjacency->SetMatrix("mWd1", &matWorld);                       

  0010a	8b 07		 mov	 eax, DWORD PTR [edi]
  0010c	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  0010f	51		 push	 ecx
  00110	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04IHCGOIEL@mWd1?$AA@
  00115	57		 push	 edi
  00116	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 710  : 
; 711  :             pDevice->GetTransform(D3DTS_WORLD1,&matWorld);

  0011c	8b 06		 mov	 eax, DWORD PTR [esi]
  0011e	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  00121	51		 push	 ecx
  00122	68 01 01 00 00	 push	 257			; 00000101H
  00127	56		 push	 esi
  00128	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 712  :             pfxSkinnedAdjacency->SetMatrix("mWd2", &matWorld);                       

  0012e	8b 07		 mov	 eax, DWORD PTR [edi]
  00130	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  00133	51		 push	 ecx
  00134	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04KMALLLII@mWd2?$AA@
  00139	57		 push	 edi
  0013a	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 713  : 
; 714  :             pDevice->GetTransform(D3DTS_WORLD2,&matWorld);

  00140	8b 06		 mov	 eax, DWORD PTR [esi]
  00142	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  00145	51		 push	 ecx
  00146	68 02 01 00 00	 push	 258			; 00000102H
  0014b	56		 push	 esi
  0014c	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 715  :             pfxSkinnedAdjacency->SetMatrix("mWd3", &matWorld);                       

  00152	8b 07		 mov	 eax, DWORD PTR [edi]
  00154	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  00157	51		 push	 ecx
  00158	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04LFBAIKMJ@mWd3?$AA@
  0015d	57		 push	 edi
  0015e	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 716  : 
; 717  :             pDevice->GetTransform(D3DTS_WORLD3,&matWorld);

  00164	8b 06		 mov	 eax, DWORD PTR [esi]
  00166	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  00169	51		 push	 ecx
  0016a	68 03 01 00 00	 push	 259			; 00000103H
  0016f	56		 push	 esi
  00170	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 718  :             pfxSkinnedAdjacency->SetMatrix("mWd4", &matWorld);        

  00176	8b 07		 mov	 eax, DWORD PTR [edi]
  00178	8d 4d a8	 lea	 ecx, DWORD PTR _matWorld$[ebp]
  0017b	51		 push	 ecx
  0017c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PKFBBMAO@mWd4?$AA@
  00181	57		 push	 edi
  00182	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 719  :         }        
; 720  :         else  // indexed skinning setup

  00188	e9 ad 00 00 00	 jmp	 $L56740
$L56733:

; 721  :         {
; 722  :             pfxCurrent = pfxSkinnedAdjacency;
; 723  :             pfxSkinnedAdjacency->SetTechnique(pfxSkinnedAdjacency->GetTechnique(1));

  0018d	6a 01		 push	 1
  0018f	57		 push	 edi
  00190	ff 50 30	 call	 DWORD PTR [eax+48]
  00193	50		 push	 eax
  00194	8b 45 18	 mov	 eax, DWORD PTR tv472[ebp]
  00197	57		 push	 edi
  00198	ff 90 f0 00 00
	00		 call	 DWORD PTR [eax+240]

; 724  : 
; 725  :             pDevice->GetTransform(D3DTS_VIEW,&matView);

  0019e	8b 06		 mov	 eax, DWORD PTR [esi]
  001a0	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _matView$[ebp]
  001a6	51		 push	 ecx
  001a7	6a 02		 push	 2
  001a9	56		 push	 esi
  001aa	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 726  :             pDevice->GetTransform(D3DTS_PROJECTION,&matProj);

  001b0	8b 06		 mov	 eax, DWORD PTR [esi]
  001b2	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _matProj$[ebp]
  001b8	51		 push	 ecx
  001b9	6a 03		 push	 3
  001bb	56		 push	 esi
  001bc	ff 90 b4 00 00
	00		 call	 DWORD PTR [eax+180]

; 727  : 
; 728  :             D3DXMatrixMultiply(&matTot,&matView,&matProj);

  001c2	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _matProj$[ebp]
  001c8	50		 push	 eax
  001c9	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _matView$[ebp]
  001cf	50		 push	 eax
  001d0	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _matTot$[ebp]
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 729  :             pfxSkinnedAdjacency->SetMatrix("mTot", &matTot);                       

  001dc	8b 07		 mov	 eax, DWORD PTR [edi]
  001de	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _matTot$[ebp]
  001e4	51		 push	 ecx
  001e5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04BEMIBDAE@mTot?$AA@
  001ea	57		 push	 edi
  001eb	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]

; 730  : 
; 731  :             for (iMatrix = 0; iMatrix < cIndexedMatrices; iMatrix++)

  001f1	83 65 18 00	 and	 DWORD PTR _iMatrix$[ebp], 0
  001f5	83 7d 20 00	 cmp	 DWORD PTR _cIndexedMatrices$[ebp], 0
  001f9	76 2b		 jbe	 SHORT $L56743
  001fb	8b 45 1c	 mov	 eax, DWORD PTR _rgmIndexedMatrices$[ebp]
  001fe	89 45 08	 mov	 DWORD PTR tv681[ebp], eax
$L57196:

; 732  :             {
; 733  :                 pfxSkinnedAdjacency->SetMatrix(x_rgszMatrix[iMatrix], &rgmIndexedMatrices[iMatrix]);

  00201	ff 75 08	 push	 DWORD PTR tv681[ebp]
  00204	8b 4d 18	 mov	 ecx, DWORD PTR _iMatrix$[ebp]
  00207	ff 34 8d 00 00
	00 00		 push	 DWORD PTR _x_rgszMatrix[ecx*4]
  0020e	8b 07		 mov	 eax, DWORD PTR [edi]
  00210	57		 push	 edi
  00211	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]
  00217	ff 45 18	 inc	 DWORD PTR _iMatrix$[ebp]
  0021a	8b 45 18	 mov	 eax, DWORD PTR _iMatrix$[ebp]
  0021d	83 45 08 40	 add	 DWORD PTR tv681[ebp], 64 ; 00000040H
  00221	3b 45 20	 cmp	 eax, DWORD PTR _cIndexedMatrices$[ebp]
  00224	72 db		 jb	 SHORT $L57196
$L56743:

; 734  :             }
; 735  : 
; 736  :             pfxSkinnedAdjacency->SetMatrixArray("mWorlds", rgmIndexedMatrices, cIndexedMatrices);

  00226	ff 75 20	 push	 DWORD PTR _cIndexedMatrices$[ebp]
  00229	8b 07		 mov	 eax, DWORD PTR [edi]
  0022b	ff 75 1c	 push	 DWORD PTR _rgmIndexedMatrices$[ebp]
  0022e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07HHMNENJH@mWorlds?$AA@
  00233	57		 push	 edi
  00234	ff 90 a0 00 00
	00		 call	 DWORD PTR [eax+160]
$L56740:

; 737  :         }
; 738  : 
; 739  :         pfxSkinnedAdjacency->SetVector("vClr", (D3DXVECTOR4*)&vClr);                       

  0023a	8b 07		 mov	 eax, DWORD PTR [edi]
  0023c	8d 4d e8	 lea	 ecx, DWORD PTR _vClr$[ebp]
  0023f	51		 push	 ecx
  00240	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JKCKMDGO@vClr?$AA@
  00245	57		 push	 edi
  00246	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 740  : 
; 741  :         dwSoftwareMode = pDevice->GetSoftwareVertexProcessing();

  0024c	8b 06		 mov	 eax, DWORD PTR [esi]
  0024e	56		 push	 esi
  0024f	ff 90 38 01 00
	00		 call	 DWORD PTR [eax+312]

; 742  :         if (!m_bHWVertexShaders)

  00255	83 7b 48 00	 cmp	 DWORD PTR [ebx+72], 0
  00259	89 45 f8	 mov	 DWORD PTR _dwSoftwareMode$[ebp], eax
  0025c	75 12		 jne	 SHORT $L56747

; 743  :         {
; 744  :             bChangedSWMode = TRUE;
; 745  :             pDevice->SetSoftwareVertexProcessing(TRUE);

  0025e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00260	33 c0		 xor	 eax, eax
  00262	40		 inc	 eax
  00263	50		 push	 eax
  00264	56		 push	 esi
  00265	89 45 fc	 mov	 DWORD PTR _bChangedSWMode$[ebp], eax
  00268	ff 91 34 01 00
	00		 call	 DWORD PTR [ecx+308]

; 746  :         }
; 747  :         // if in the wrong mode, then switch
; 748  :         else if (dwSoftwareMode && m_bHWVertexShaders)

  0026e	eb 30		 jmp	 SHORT $L57197
$L56747:
  00270	85 c0		 test	 eax, eax
  00272	74 2c		 je	 SHORT $L57197

; 749  :         {
; 750  :             bChangedSWMode = TRUE;
; 751  :             pDevice->SetSoftwareVertexProcessing(FALSE);

  00274	8b 06		 mov	 eax, DWORD PTR [esi]
  00276	6a 00		 push	 0
  00278	56		 push	 esi
  00279	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bChangedSWMode$[ebp], 1
  00280	ff 90 34 01 00
	00		 call	 DWORD PTR [eax+308]

; 752  :         }
; 753  :     }
; 754  :     else

  00286	eb 18		 jmp	 SHORT $L57197
$L56732:

; 755  :     {
; 756  :         pfxCurrent = pfxColor;

  00288	8b 45 14	 mov	 eax, DWORD PTR _pfxColor$[ebp]

; 757  :         pfxCurrent->SetVector("vClr", (D3DXVECTOR4*)&vClr);                       

  0028b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0028d	8d 55 e8	 lea	 edx, DWORD PTR _vClr$[ebp]
  00290	52		 push	 edx
  00291	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JKCKMDGO@vClr?$AA@
  00296	50		 push	 eax
  00297	89 45 10	 mov	 DWORD PTR _pfxCurrent$[ebp], eax
  0029a	ff 91 88 00 00
	00		 call	 DWORD PTR [ecx+136]
$L57197:

; 758  :     }
; 759  : 
; 760  : 
; 761  :     if ((iAttrib < m_caeAttributeTable) && (m_rgaeAttributeTable[iAttrib].AttribId == iAttrib))

  002a0	8b 7b 58	 mov	 edi, DWORD PTR [ebx+88]
  002a3	8b 4d 0c	 mov	 ecx, DWORD PTR _iAttrib$[ebp]
  002a6	3b cf		 cmp	 ecx, edi
  002a8	73 0f		 jae	 SHORT $L56752
  002aa	8b 53 54	 mov	 edx, DWORD PTR [ebx+84]
  002ad	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  002b0	39 0c 82	 cmp	 DWORD PTR [edx+eax*4], ecx
  002b3	75 04		 jne	 SHORT $L56752

; 762  :     {
; 763  :         iSubset = iAttrib;

  002b5	8b c1		 mov	 eax, ecx

; 764  :     }
; 765  :     else

  002b7	eb 15		 jmp	 SHORT $L57202
$L56752:

; 766  :     {
; 767  :         // look for the correct attribute table entry to draw
; 768  :         for (iSubset = 0; iSubset < m_caeAttributeTable; iSubset++)

  002b9	33 c0		 xor	 eax, eax
  002bb	85 ff		 test	 edi, edi
  002bd	76 0f		 jbe	 SHORT $L57202
  002bf	8b 53 54	 mov	 edx, DWORD PTR [ebx+84]
$L57201:

; 769  :         {
; 770  :             if (m_rgaeAttributeTable[iSubset].AttribId == iAttrib)

  002c2	39 0a		 cmp	 DWORD PTR [edx], ecx
  002c4	74 08		 je	 SHORT $L57202
  002c6	40		 inc	 eax
  002c7	83 c2 14	 add	 edx, 20			; 00000014H
  002ca	3b c7		 cmp	 eax, edi
  002cc	72 f4		 jb	 SHORT $L57201
$L57202:

; 771  :             {
; 772  :                 break;
; 773  :             }
; 774  :         }
; 775  :     }
; 776  : 
; 777  :     if (iSubset < m_caeAttributeTable)

  002ce	3b c7		 cmp	 eax, edi
  002d0	0f 83 d4 00 00
	00		 jae	 $L57200

; 778  :     {
; 779  :         if (m_rgaeAttributeTable[iSubset].FaceCount > 0)

  002d6	8d 3c 80	 lea	 edi, DWORD PTR [eax+eax*4]
  002d9	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  002dc	c1 e7 02	 shl	 edi, 2
  002df	83 7c 07 08 00	 cmp	 DWORD PTR [edi+eax+8], 0
  002e4	89 7d 08	 mov	 DWORD PTR tv532[ebp], edi
  002e7	0f 86 bd 00 00
	00		 jbe	 $L57200

; 780  :         {
; 781  :             pfxCurrent->Begin(&cPasses, 0);

  002ed	8b 45 10	 mov	 eax, DWORD PTR _pfxCurrent$[ebp]
  002f0	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f2	6a 00		 push	 0
  002f4	8d 55 14	 lea	 edx, DWORD PTR _cPasses$[ebp]
  002f7	52		 push	 edx
  002f8	50		 push	 eax
  002f9	ff 91 04 01 00
	00		 call	 DWORD PTR [ecx+260]

; 782  : 
; 783  :             for (iPass = 0; iPass < cPasses; iPass++)

  002ff	83 65 20 00	 and	 DWORD PTR _iPass$[ebp], 0
  00303	83 7d 14 00	 cmp	 DWORD PTR _cPasses$[ebp], 0
  00307	0f 86 91 00 00
	00		 jbe	 $L56762
  0030d	eb 03		 jmp	 SHORT $L56760
$L57198:
  0030f	8b 7d 08	 mov	 edi, DWORD PTR tv532[ebp]
$L56760:

; 784  :             {
; 785  :                 pDevice->SetVertexDeclaration(m_pDecl);

  00312	ff 73 50	 push	 DWORD PTR [ebx+80]
  00315	8b 06		 mov	 eax, DWORD PTR [esi]
  00317	56		 push	 esi
  00318	ff 90 5c 01 00
	00		 call	 DWORD PTR [eax+348]

; 786  : 
; 787  :                 pfxCurrent->BeginPass(iPass);

  0031e	8b 45 10	 mov	 eax, DWORD PTR _pfxCurrent$[ebp]
  00321	ff 75 20	 push	 DWORD PTR _iPass$[ebp]
  00324	8b 08		 mov	 ecx, DWORD PTR [eax]
  00326	50		 push	 eax
  00327	ff 91 08 01 00
	00		 call	 DWORD PTR [ecx+264]

; 788  : 
; 789  :                 pDevice->SetStreamSource(0, m_pVertexBuffer, 0, m_cfvf.m_cBytesPerVertex);

  0032d	ff 73 04	 push	 DWORD PTR [ebx+4]
  00330	8b 06		 mov	 eax, DWORD PTR [esi]
  00332	6a 00		 push	 0
  00334	ff 73 4c	 push	 DWORD PTR [ebx+76]
  00337	6a 00		 push	 0
  00339	56		 push	 esi
  0033a	ff 90 90 01 00
	00		 call	 DWORD PTR [eax+400]

; 790  : 
; 791  :                 iVertexStart = m_rgaeAttributeTable[iSubset].VertexStart;

  00340	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  00343	03 c7		 add	 eax, edi

; 792  :                 cLines = m_rgaeAttributeTable[iSubset].VertexCount / 2;

  00345	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  00348	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0034b	d1 ef		 shr	 edi, 1
  0034d	eb 2f		 jmp	 SHORT $L57203
$L56764:

; 795  :                 {
; 796  :                     cLinesCur = min(cLines, (0xffff / 2));

  0034f	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00354	3b f8		 cmp	 edi, eax
  00356	89 7d 1c	 mov	 DWORD PTR _cLinesCur$[ebp], edi
  00359	72 03		 jb	 SHORT $L57169
  0035b	89 45 1c	 mov	 DWORD PTR _cLinesCur$[ebp], eax
$L57169:

; 797  : 
; 798  :                     hr = pDevice->DrawPrimitive(D3DPT_LINELIST, 
; 799  :                                                  iVertexStart, 
; 800  :                                                  cLinesCur);

  0035e	ff 75 1c	 push	 DWORD PTR _cLinesCur$[ebp]
  00361	8b 06		 mov	 eax, DWORD PTR [esi]
  00363	ff 75 18	 push	 DWORD PTR _iVertexStart$[ebp]
  00366	6a 02		 push	 2
  00368	56		 push	 esi
  00369	ff 90 44 01 00
	00		 call	 DWORD PTR [eax+324]

; 801  :                     if (FAILED(hr))

  0036f	85 c0		 test	 eax, eax
  00371	7c 4b		 jl	 SHORT $L56713

; 802  :                         return hr;
; 803  : 
; 804  :                     iVertexStart += cLinesCur * 2;

  00373	8b 45 1c	 mov	 eax, DWORD PTR _cLinesCur$[ebp]
  00376	8b 4d 18	 mov	 ecx, DWORD PTR _iVertexStart$[ebp]
  00379	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]

; 805  :                     cLines -= cLinesCur;

  0037c	2b f8		 sub	 edi, eax
$L57203:

; 802  :                         return hr;
; 803  : 
; 804  :                     iVertexStart += cLinesCur * 2;

  0037e	89 4d 18	 mov	 DWORD PTR _iVertexStart$[ebp], ecx

; 793  : 
; 794  :                 while (cLines > 0)

  00381	75 cc		 jne	 SHORT $L56764

; 806  :                 }
; 807  :              
; 808  :                 pfxCurrent->EndPass();

  00383	8b 45 10	 mov	 eax, DWORD PTR _pfxCurrent$[ebp]
  00386	8b 08		 mov	 ecx, DWORD PTR [eax]
  00388	50		 push	 eax
  00389	ff 91 10 01 00
	00		 call	 DWORD PTR [ecx+272]
  0038f	ff 45 20	 inc	 DWORD PTR _iPass$[ebp]
  00392	8b 45 20	 mov	 eax, DWORD PTR _iPass$[ebp]
  00395	3b 45 14	 cmp	 eax, DWORD PTR _cPasses$[ebp]
  00398	0f 82 71 ff ff
	ff		 jb	 $L57198
$L56762:

; 809  :             }
; 810  : 
; 811  :             pfxCurrent->End();

  0039e	8b 45 10	 mov	 eax, DWORD PTR _pfxCurrent$[ebp]
  003a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a3	50		 push	 eax
  003a4	ff 91 14 01 00
	00		 call	 DWORD PTR [ecx+276]
$L57200:

; 812  : 
; 813  : 
; 814  :         }
; 815  :     }
; 816  : 
; 817  :     if (bChangedSWMode)

  003aa	83 7d fc 00	 cmp	 DWORD PTR _bChangedSWMode$[ebp], 0
  003ae	74 0c		 je	 SHORT $L56768

; 818  :     {
; 819  :         pDevice->SetSoftwareVertexProcessing(dwSoftwareMode);

  003b0	ff 75 f8	 push	 DWORD PTR _dwSoftwareMode$[ebp]
  003b3	8b 06		 mov	 eax, DWORD PTR [esi]
  003b5	56		 push	 esi
  003b6	ff 90 34 01 00
	00		 call	 DWORD PTR [eax+308]
$L56768:

; 820  :     }
; 821  : 
; 822  :     return S_OK;

  003bc	33 c0		 xor	 eax, eax
$L56713:
  003be	5f		 pop	 edi
  003bf	5e		 pop	 esi
  003c0	5b		 pop	 ebx

; 823  : }

  003c1	c9		 leave
  003c2	c2 1c 00	 ret	 28			; 0000001cH
?Draw@CAdjacencyOutline@@QAEJPAUIDirect3DDevice9@@KPAUID3DXEffect@@1KPAUD3DXMATRIX@@K@Z ENDP ; CAdjacencyOutline::Draw
_TEXT	ENDS
END
