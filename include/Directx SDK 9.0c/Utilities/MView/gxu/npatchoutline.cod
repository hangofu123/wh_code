; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.4035 

	TITLE	.\npatchoutline.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??0CNPatchOutline@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CNPatchOutline@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalculateCounts@@YAXKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawInternal@CNPatchOutline@@AAEJPAUID3DXBaseMesh@@KKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Draw@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawFace@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateEmptyOutline@CNPatchOutline@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AddOutlineLineSegments@G@@YAXPAGK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AddOutlineLineSegments@I@@YAXPAIK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	??0CNPatchOutline@@QAE@XZ			; CNPatchOutline::CNPatchOutline
; Function compile flags: /Ogs
; File d:\builds\nt32_fre\multimedia\directx\dxsdk\src\mview\gxu\npatchoutline.cpp
;	COMDAT ??0CNPatchOutline@@QAE@XZ
_TEXT	SEGMENT
??0CNPatchOutline@@QAE@XZ PROC NEAR			; CNPatchOutline::CNPatchOutline, COMDAT
; _this$ = ecx

; 31   : {

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000c	89 88 1c 02 00
	00		 mov	 DWORD PTR [eax+540], ecx
  00012	89 88 20 02 00
	00		 mov	 DWORD PTR [eax+544], ecx
  00018	89 88 24 02 00
	00		 mov	 DWORD PTR [eax+548], ecx

; 32   : }

  0001e	c3		 ret	 0
??0CNPatchOutline@@QAE@XZ ENDP				; CNPatchOutline::CNPatchOutline
_TEXT	ENDS
PUBLIC	??1CNPatchOutline@@QAE@XZ			; CNPatchOutline::~CNPatchOutline
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogs
;	COMDAT ??1CNPatchOutline@@QAE@XZ
_TEXT	SEGMENT
??1CNPatchOutline@@QAE@XZ PROC NEAR			; CNPatchOutline::~CNPatchOutline, COMDAT
; _this$ = ecx

; 41   : }

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 35   : {

  00003	8b f1		 mov	 esi, ecx

; 36   :     GXRELEASE(m_pIndexBuffer);

  00005	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00008	85 c0		 test	 eax, eax
  0000a	74 0a		 je	 SHORT $L56251
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	50		 push	 eax
  0000f	ff 51 08	 call	 DWORD PTR [ecx+8]
  00012	83 66 04 00	 and	 DWORD PTR [esi+4], 0
$L56251:

; 37   :     GXRELEASE(m_pDevice);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	85 c0		 test	 eax, eax
  0001a	74 09		 je	 SHORT $L56255
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	50		 push	 eax
  0001f	ff 51 08	 call	 DWORD PTR [ecx+8]
  00022	83 26 00	 and	 DWORD PTR [esi], 0
$L56255:

; 38   :     GXRELEASE(m_pDeclObj);

  00025	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00028	85 c0		 test	 eax, eax
  0002a	74 0a		 je	 SHORT $L56259
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	50		 push	 eax
  0002f	ff 51 08	 call	 DWORD PTR [ecx+8]
  00032	83 66 08 00	 and	 DWORD PTR [esi+8], 0
$L56259:

; 39   : 
; 40   :     delete []m_rgaeAttributeTable;

  00036	ff b6 1c 02 00
	00		 push	 DWORD PTR [esi+540]
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00041	59		 pop	 ecx
  00042	5e		 pop	 esi

; 41   : }

  00043	c3		 ret	 0
??1CNPatchOutline@@QAE@XZ ENDP				; CNPatchOutline::~CNPatchOutline
; Function compile flags: /Ogs
_TEXT	ENDS
;	COMDAT ?CalculateCounts@@YAXKPAK@Z
_TEXT	SEGMENT
_pcFaces$ = 8						; size = 4
?CalculateCounts@@YAXKPAK@Z PROC NEAR			; CalculateCounts, COMDAT
; _cSegments$ = eax

; 69   : }

  00000	8b ff		 npad	 2

; 53   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 54   :     DWORD iLevel;
; 55   :     DWORD cFacesPrev;
; 56   :     DWORD cFacesOut;
; 57   : 
; 58   : 
; 59   :     // UNDONE - should be a convenient formula to figure this one out
; 60   :     cFacesOut = 1;

  00005	33 c9		 xor	 ecx, ecx
  00007	41		 inc	 ecx

; 61   :     cFacesPrev = 1;

  00008	8b d1		 mov	 edx, ecx
  0000a	eb 04		 jmp	 SHORT $L56501
$L56270:

; 63   :     {
; 64   :         cFacesPrev += 2;

  0000c	42		 inc	 edx
  0000d	42		 inc	 edx

; 65   :         cFacesOut += cFacesPrev;

  0000e	03 ca		 add	 ecx, edx
$L56501:

; 62   :     for (iLevel = 0; iLevel < cSegments-1; iLevel++)

  00010	48		 dec	 eax
  00011	75 f9		 jne	 SHORT $L56270

; 66   :     }
; 67   : 
; 68   :     *pcFaces = cFacesOut;

  00013	8b 45 08	 mov	 eax, DWORD PTR _pcFaces$[ebp]
  00016	89 08		 mov	 DWORD PTR [eax], ecx

; 69   : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?CalculateCounts@@YAXKPAK@Z ENDP			; CalculateCounts
_TEXT	ENDS
PUBLIC	?DrawInternal@CNPatchOutline@@AAEJPAUID3DXBaseMesh@@KKK@Z ; CNPatchOutline::DrawInternal
EXTRN	__alloca_probe:NEAR
; Function compile flags: /Ogs
;	COMDAT ?DrawInternal@CNPatchOutline@@AAEJPAUID3DXBaseMesh@@KKK@Z
_TEXT	SEGMENT
_iLineEnd$ = -12					; size = 4
_pbPoints$ = -8						; size = 4
_pdwLineIndices$ = -4					; size = 4
_ptmDrawMesh$ = 8					; size = 4
_pbLine$ = 12						; size = 4
_iAttrib$ = 12						; size = 4
_pVertexBuffer$ = 16					; size = 4
_iStartIndex$ = 16					; size = 4
_iLine$ = 20						; size = 4
_cLines$ = 20						; size = 4
?DrawInternal@CNPatchOutline@@AAEJPAUID3DXBaseMesh@@KKK@Z PROC NEAR ; CNPatchOutline::DrawInternal, COMDAT
; _this$ = ecx

; 377  : }

  00000	8b ff		 npad	 2

; 289  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 290  :     HRESULT hr;
; 291  :     LPDIRECT3DVERTEXBUFFER9 pVertexBuffer;
; 292  :     DWORD cBytesPerVertex;
; 293  :     DWORD dwFVF;
; 294  :     DWORD iSubset;
; 295  : 
; 296  :     DWORD *pdwLineIndices;
; 297  :     PBYTE pbLine;
; 298  :     PBYTE pbPoints;
; 299  :     DWORD iLine;
; 300  :     DWORD iLineStart;
; 301  :     DWORD iLineEnd;
; 302  : 
; 303  :     if ((iAttrib < m_caeAttributeTable) && (m_rgaeAttributeTable[iAttrib].AttribId == iAttrib))

  00008	8b 45 0c	 mov	 eax, DWORD PTR _iAttrib$[ebp]
  0000b	53		 push	 ebx
  0000c	8b d9		 mov	 ebx, ecx
  0000e	8b 8b 20 02 00
	00		 mov	 ecx, DWORD PTR [ebx+544]
  00014	3b c1		 cmp	 eax, ecx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	73 12		 jae	 SHORT $L56384
  0001a	8b b3 1c 02 00
	00		 mov	 esi, DWORD PTR [ebx+540]
  00020	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00023	39 04 96	 cmp	 DWORD PTR [esi+edx*4], eax
  00026	75 04		 jne	 SHORT $L56384

; 304  :     {
; 305  :         iSubset = iAttrib;

  00028	8b f0		 mov	 esi, eax

; 306  :     }
; 307  :     else

  0002a	eb 18		 jmp	 SHORT $L56505
$L56384:

; 308  :     {
; 309  :         // look for the correct attribute table entry to draw
; 310  :         for (iSubset = 0; iSubset < m_caeAttributeTable; iSubset++)

  0002c	33 f6		 xor	 esi, esi
  0002e	85 c9		 test	 ecx, ecx
  00030	76 12		 jbe	 SHORT $L56505
  00032	8b 93 1c 02 00
	00		 mov	 edx, DWORD PTR [ebx+540]
$L56386:

; 311  :         {
; 312  :             if (m_rgaeAttributeTable[iSubset].AttribId == iAttrib)

  00038	39 02		 cmp	 DWORD PTR [edx], eax
  0003a	74 08		 je	 SHORT $L56505
  0003c	46		 inc	 esi
  0003d	83 c2 14	 add	 edx, 20			; 00000014H
  00040	3b f1		 cmp	 esi, ecx
  00042	72 f4		 jb	 SHORT $L56386
$L56505:

; 313  :             {
; 314  :                 break;
; 315  :             }
; 316  :         }
; 317  :     }
; 318  : 
; 319  :     if (iSubset < m_caeAttributeTable)

  00044	3b f1		 cmp	 esi, ecx
  00046	0f 83 b4 01 00
	00		 jae	 $L56401

; 320  :     {
; 321  :         if ((iStartIndex == UNUSED32) || (cLines == UNUSED32))

  0004c	8b 7d 10	 mov	 edi, DWORD PTR _iStartIndex$[ebp]
  0004f	83 ff ff	 cmp	 edi, -1
  00052	74 06		 je	 SHORT $L56392
  00054	83 7d 14 ff	 cmp	 DWORD PTR _cLines$[ebp], -1
  00058	75 15		 jne	 SHORT $L56391
$L56392:

; 322  :         {
; 323  :             iStartIndex = m_rgaeAttributeTable[iSubset].FaceStart;

  0005a	8b 8b 1c 02 00
	00		 mov	 ecx, DWORD PTR [ebx+540]
  00060	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  00063	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00066	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 324  :             cLines = m_rgaeAttributeTable[iSubset].FaceCount;

  00069	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0006c	89 45 14	 mov	 DWORD PTR _cLines$[ebp], eax
$L56391:

; 325  :         }
; 326  : 
; 327  :         if (m_rgaeAttributeTable[iSubset].FaceCount > 0)

  0006f	8b 83 1c 02 00
	00		 mov	 eax, DWORD PTR [ebx+540]
  00075	8d 34 b6	 lea	 esi, DWORD PTR [esi+esi*4]
  00078	c1 e6 02	 shl	 esi, 2
  0007b	83 7c 06 08 00	 cmp	 DWORD PTR [esi+eax+8], 0
  00080	0f 86 7a 01 00
	00		 jbe	 $L56401

; 328  :         {
; 329  :             if (!m_bEmulate32BitIndex)

  00086	83 bb 24 02 00
	00 00		 cmp	 DWORD PTR [ebx+548], 0
  0008d	0f 85 86 00 00
	00		 jne	 $L56394

; 330  :             {
; 331  :                 ptmDrawMesh->GetVertexBuffer(&pVertexBuffer);

  00093	8b 45 08	 mov	 eax, DWORD PTR _ptmDrawMesh$[ebp]
  00096	8b 08		 mov	 ecx, DWORD PTR [eax]
  00098	8d 55 10	 lea	 edx, DWORD PTR _pVertexBuffer$[ebp]
  0009b	52		 push	 edx
  0009c	50		 push	 eax
  0009d	ff 51 34	 call	 DWORD PTR [ecx+52]

; 332  :                 m_pDevice->SetVertexDeclaration(m_pDeclObj);

  000a0	8b 03		 mov	 eax, DWORD PTR [ebx]
  000a2	ff 73 08	 push	 DWORD PTR [ebx+8]
  000a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a7	50		 push	 eax
  000a8	ff 91 5c 01 00
	00		 call	 DWORD PTR [ecx+348]

; 333  :                 m_pDevice->SetStreamSource(0, pVertexBuffer, 0, m_cBytesPerVertex);

  000ae	ff b3 14 02 00
	00		 push	 DWORD PTR [ebx+532]
  000b4	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b8	6a 00		 push	 0
  000ba	ff 75 10	 push	 DWORD PTR _pVertexBuffer$[ebp]
  000bd	6a 00		 push	 0
  000bf	50		 push	 eax
  000c0	ff 91 90 01 00
	00		 call	 DWORD PTR [ecx+400]

; 334  :                 m_pDevice->SetIndices(m_pIndexBuffer);

  000c6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c8	ff 73 04	 push	 DWORD PTR [ebx+4]
  000cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cd	50		 push	 eax
  000ce	ff 91 a0 01 00
	00		 call	 DWORD PTR [ecx+416]

; 335  : 
; 336  :                 hr = m_pDevice->DrawIndexedPrimitive(D3DPT_LINELIST, 
; 337  :                                              0, 0, m_rgaeAttributeTable[iSubset].VertexStart + m_rgaeAttributeTable[iSubset].VertexCount,
; 338  :                                              iStartIndex * 2, 
; 339  :                                              cLines);

  000d4	ff 75 14	 push	 DWORD PTR _cLines$[ebp]
  000d7	8b 83 1c 02 00
	00		 mov	 eax, DWORD PTR [ebx+540]
  000dd	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000df	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e1	03 c6		 add	 eax, esi
  000e3	8d 34 3f	 lea	 esi, DWORD PTR [edi+edi]
  000e6	56		 push	 esi
  000e7	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  000ea	03 70 0c	 add	 esi, DWORD PTR [eax+12]
  000ed	56		 push	 esi
  000ee	6a 00		 push	 0
  000f0	6a 00		 push	 0
  000f2	6a 02		 push	 2
  000f4	51		 push	 ecx
  000f5	ff 92 48 01 00
	00		 call	 DWORD PTR [edx+328]

; 340  :                 if (FAILED(hr))

  000fb	85 c0		 test	 eax, eax

; 341  :                     return hr;

  000fd	0f 8c ff 00 00
	00		 jl	 $L56372

; 342  : 
; 343  :                 GXRELEASE(pVertexBuffer);

  00103	8b 45 10	 mov	 eax, DWORD PTR _pVertexBuffer$[ebp]
  00106	85 c0		 test	 eax, eax
  00108	0f 84 f2 00 00
	00		 je	 $L56401
  0010e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00110	50		 push	 eax
  00111	ff 51 08	 call	 DWORD PTR [ecx+8]

; 344  :             }
; 345  :             else

  00114	e9 e7 00 00 00	 jmp	 $L56401
$L56394:

; 346  :             {
; 347  :                 GXASSERT(ptmDrawMesh->GetOptions() & D3DXMESH_32BIT);
; 348  : 
; 349  :                 hr = ptmDrawMesh->LockVertexBuffer(D3DLOCK_READONLY, (PVOID*)&pbPoints);

  00119	8b 75 08	 mov	 esi, DWORD PTR _ptmDrawMesh$[ebp]
  0011c	8b 06		 mov	 eax, DWORD PTR [esi]
  0011e	8d 4d f8	 lea	 ecx, DWORD PTR _pbPoints$[ebp]
  00121	51		 push	 ecx
  00122	6a 10		 push	 16			; 00000010H
  00124	56		 push	 esi
  00125	ff 50 3c	 call	 DWORD PTR [eax+60]

; 350  :                 if (FAILED(hr))

  00128	85 c0		 test	 eax, eax

; 351  :                     return hr;

  0012a	0f 8c d2 00 00
	00		 jl	 $L56372

; 352  : 
; 353  :                 hr = m_pIndexBuffer->Lock(0, 0, (PVOID*)&pdwLineIndices, D3DLOCK_NOSYSLOCK|D3DLOCK_READONLY);

  00130	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00133	8b 08		 mov	 ecx, DWORD PTR [eax]
  00135	68 10 08 00 00	 push	 2064			; 00000810H
  0013a	8d 55 fc	 lea	 edx, DWORD PTR _pdwLineIndices$[ebp]
  0013d	52		 push	 edx
  0013e	6a 00		 push	 0
  00140	6a 00		 push	 0
  00142	50		 push	 eax
  00143	ff 51 2c	 call	 DWORD PTR [ecx+44]

; 354  :                 if (FAILED(hr))

  00146	85 c0		 test	 eax, eax

; 355  :                     return hr;

  00148	0f 8c b4 00 00
	00		 jl	 $L56372

; 356  : 
; 357  :                 pbLine = (PBYTE)_alloca(m_cBytesPerVertex * 2);

  0014e	8b 83 14 02 00
	00		 mov	 eax, DWORD PTR [ebx+532]
  00154	d1 e0		 shl	 eax, 1
  00156	83 c0 03	 add	 eax, 3
  00159	83 e0 fc	 and	 eax, -4			; fffffffcH
  0015c	e8 00 00 00 00	 call	 __alloca_probe

; 358  : 
; 359  :                 iLineStart = iStartIndex * 2;
; 360  :                 iLineEnd = iLineStart + cLines * 2;

  00161	8b 4d 14	 mov	 ecx, DWORD PTR _cLines$[ebp]
  00164	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00167	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]

; 361  :                 for (iLine = iLineStart; iLine < iLineEnd; iLine+=2)

  0016a	3b c1		 cmp	 eax, ecx
  0016c	89 65 0c	 mov	 DWORD PTR _pbLine$[ebp], esp
  0016f	89 4d f4	 mov	 DWORD PTR _iLineEnd$[ebp], ecx
  00172	89 45 14	 mov	 DWORD PTR _iLine$[ebp], eax
  00175	73 7a		 jae	 SHORT $L56412
$L56410:

; 362  :                 {
; 363  :                     memcpy(pbLine, pbPoints + pdwLineIndices[iLine]*m_cBytesPerVertex, m_cBytesPerVertex);

  00177	8b 55 fc	 mov	 edx, DWORD PTR _pdwLineIndices$[ebp]
  0017a	8b 8b 14 02 00
	00		 mov	 ecx, DWORD PTR [ebx+532]
  00180	8b 45 14	 mov	 eax, DWORD PTR _iLine$[ebp]
  00183	8b 7d 0c	 mov	 edi, DWORD PTR _pbLine$[ebp]
  00186	c1 e0 02	 shl	 eax, 2
  00189	8b 34 10	 mov	 esi, DWORD PTR [eax+edx]
  0018c	0f af f1	 imul	 esi, ecx
  0018f	03 75 f8	 add	 esi, DWORD PTR _pbPoints$[ebp]
  00192	8b d1		 mov	 edx, ecx
  00194	c1 e9 02	 shr	 ecx, 2
  00197	f3 a5		 rep movsd
  00199	8b ca		 mov	 ecx, edx
  0019b	83 e1 03	 and	 ecx, 3
  0019e	f3 a4		 rep movsb

; 364  :                     memcpy(pbLine + m_cBytesPerVertex, pbPoints + pdwLineIndices[iLine+1]*m_cBytesPerVertex, m_cBytesPerVertex);

  001a0	8b 8b 14 02 00
	00		 mov	 ecx, DWORD PTR [ebx+532]
  001a6	8b 55 fc	 mov	 edx, DWORD PTR _pdwLineIndices$[ebp]
  001a9	8b 74 10 04	 mov	 esi, DWORD PTR [eax+edx+4]
  001ad	0f af f1	 imul	 esi, ecx
  001b0	03 75 f8	 add	 esi, DWORD PTR _pbPoints$[ebp]
  001b3	8b f9		 mov	 edi, ecx
  001b5	03 7d 0c	 add	 edi, DWORD PTR _pbLine$[ebp]
  001b8	8b c1		 mov	 eax, ecx
  001ba	c1 e9 02	 shr	 ecx, 2
  001bd	f3 a5		 rep movsd
  001bf	8b c8		 mov	 ecx, eax
  001c1	83 e1 03	 and	 ecx, 3
  001c4	f3 a4		 rep movsb

; 365  : 
; 366  :                     hr = m_pDevice->DrawPrimitiveUP(D3DPT_LINELIST, 1, pbLine, m_cBytesPerVertex);

  001c6	ff b3 14 02 00
	00		 push	 DWORD PTR [ebx+532]
  001cc	8b 03		 mov	 eax, DWORD PTR [ebx]
  001ce	ff 75 0c	 push	 DWORD PTR _pbLine$[ebp]
  001d1	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d3	6a 01		 push	 1
  001d5	6a 02		 push	 2
  001d7	50		 push	 eax
  001d8	ff 91 4c 01 00
	00		 call	 DWORD PTR [ecx+332]

; 367  :                     if (FAILED(hr))

  001de	85 c0		 test	 eax, eax
  001e0	7c 20		 jl	 SHORT $L56372
  001e2	83 45 14 02	 add	 DWORD PTR _iLine$[ebp], 2
  001e6	8b 45 14	 mov	 eax, DWORD PTR _iLine$[ebp]
  001e9	3b 45 f4	 cmp	 eax, DWORD PTR _iLineEnd$[ebp]
  001ec	72 89		 jb	 SHORT $L56410
  001ee	8b 75 08	 mov	 esi, DWORD PTR _ptmDrawMesh$[ebp]
$L56412:

; 368  :                         return hr;
; 369  :                 }
; 370  : 
; 371  :                 ptmDrawMesh->UnlockVertexBuffer();

  001f1	8b 06		 mov	 eax, DWORD PTR [esi]
  001f3	56		 push	 esi
  001f4	ff 50 40	 call	 DWORD PTR [eax+64]

; 372  :                 m_pIndexBuffer->Unlock();

  001f7	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  001fa	8b 03		 mov	 eax, DWORD PTR [ebx]
  001fc	53		 push	 ebx
  001fd	ff 50 30	 call	 DWORD PTR [eax+48]
$L56401:

; 373  :             }
; 374  :         }
; 375  :     }
; 376  :     return S_OK;

  00200	33 c0		 xor	 eax, eax
$L56372:

; 377  : }

  00202	8d 65 e8	 lea	 esp, DWORD PTR [ebp-24]
  00205	5f		 pop	 edi
  00206	5e		 pop	 esi
  00207	5b		 pop	 ebx
  00208	c9		 leave
  00209	c2 10 00	 ret	 16			; 00000010H
?DrawInternal@CNPatchOutline@@AAEJPAUID3DXBaseMesh@@KKK@Z ENDP ; CNPatchOutline::DrawInternal
_TEXT	ENDS
PUBLIC	?Draw@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@K@Z	; CNPatchOutline::Draw
; Function compile flags: /Ogs
;	COMDAT ?Draw@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@K@Z
_TEXT	SEGMENT
_ptmDrawMesh$ = 8					; size = 4
_iSubset$ = 12						; size = 4
?Draw@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@K@Z PROC NEAR ; CNPatchOutline::Draw, COMDAT
; _this$ = ecx

; 386  : }

  00000	8b ff		 npad	 2

; 381  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 382  :     if (iSubset < m_caeAttributeTable)

  00005	8b 45 0c	 mov	 eax, DWORD PTR _iSubset$[ebp]
  00008	3b 81 20 02 00
	00		 cmp	 eax, DWORD PTR [ecx+544]
  0000e	73 0f		 jae	 SHORT $L56421

; 383  :         return DrawInternal(ptmDrawMesh, iSubset, UNUSED32, UNUSED32);

  00010	6a ff		 push	 -1
  00012	6a ff		 push	 -1
  00014	50		 push	 eax
  00015	ff 75 08	 push	 DWORD PTR _ptmDrawMesh$[ebp]
  00018	e8 00 00 00 00	 call	 ?DrawInternal@CNPatchOutline@@AAEJPAUID3DXBaseMesh@@KKK@Z ; CNPatchOutline::DrawInternal
  0001d	eb 02		 jmp	 SHORT $L56422
$L56421:

; 384  :     else
; 385  :         return S_OK;

  0001f	33 c0		 xor	 eax, eax
$L56422:

; 386  : }

  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?Draw@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@K@Z ENDP	; CNPatchOutline::Draw
_TEXT	ENDS
PUBLIC	?DrawFace@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@KK@Z ; CNPatchOutline::DrawFace
; Function compile flags: /Ogs
;	COMDAT ?DrawFace@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@KK@Z
_TEXT	SEGMENT
_ptmDrawMesh$ = 8					; size = 4
_iFace$ = 12						; size = 4
_iSubset$ = 16						; size = 4
?DrawFace@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@KK@Z PROC NEAR ; CNPatchOutline::DrawFace, COMDAT
; _this$ = ecx

; 395  : }

  00000	8b ff		 npad	 2

; 390  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 391  :     if (iSubset < m_caeAttributeTable)

  00005	8b 55 10	 mov	 edx, DWORD PTR _iSubset$[ebp]
  00008	3b 91 20 02 00
	00		 cmp	 edx, DWORD PTR [ecx+544]
  0000e	73 17		 jae	 SHORT $L56430

; 392  :         return DrawInternal(ptmDrawMesh, iSubset, iFace * m_cLinesPerOrigFace, m_cLinesPerOrigFace);

  00010	8b 81 18 02 00
	00		 mov	 eax, DWORD PTR [ecx+536]
  00016	50		 push	 eax
  00017	0f af 45 0c	 imul	 eax, DWORD PTR _iFace$[ebp]
  0001b	50		 push	 eax
  0001c	52		 push	 edx
  0001d	ff 75 08	 push	 DWORD PTR _ptmDrawMesh$[ebp]
  00020	e8 00 00 00 00	 call	 ?DrawInternal@CNPatchOutline@@AAEJPAUID3DXBaseMesh@@KKK@Z ; CNPatchOutline::DrawInternal
  00025	eb 02		 jmp	 SHORT $L56431
$L56430:

; 393  :     else
; 394  :         return S_OK;

  00027	33 c0		 xor	 eax, eax
$L56431:

; 395  : }

  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
?DrawFace@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@KK@Z ENDP ; CNPatchOutline::DrawFace
_TEXT	ENDS
PUBLIC	?CreateEmptyOutline@CNPatchOutline@@QAEJXZ	; CNPatchOutline::CreateEmptyOutline
; Function compile flags: /Ogs
;	COMDAT ?CreateEmptyOutline@CNPatchOutline@@QAEJXZ
_TEXT	SEGMENT
?CreateEmptyOutline@CNPatchOutline@@QAEJXZ PROC NEAR	; CNPatchOutline::CreateEmptyOutline, COMDAT
; _this$ = ecx

; 408  : }

  00000	8b ff		 npad	 2
  00002	53		 push	 ebx
  00003	56		 push	 esi

; 399  : {

  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 400  :     delete []m_rgaeAttributeTable;

  00007	8d be 1c 02 00
	00		 lea	 edi, DWORD PTR [esi+540]
  0000d	ff 37		 push	 DWORD PTR [edi]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 401  :     m_rgaeAttributeTable = NULL;
; 402  :     m_caeAttributeTable = 0;
; 403  :     GXRELEASE(m_pIndexBuffer);

  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00017	33 db		 xor	 ebx, ebx
  00019	3b c3		 cmp	 eax, ebx
  0001b	59		 pop	 ecx
  0001c	89 1f		 mov	 DWORD PTR [edi], ebx
  0001e	89 9e 20 02 00
	00		 mov	 DWORD PTR [esi+544], ebx
  00024	74 09		 je	 SHORT $L56438
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	50		 push	 eax
  00029	ff 51 08	 call	 DWORD PTR [ecx+8]
  0002c	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
$L56438:

; 404  :     GXRELEASE(m_pDevice);

  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	3b c3		 cmp	 eax, ebx
  00033	74 08		 je	 SHORT $L56442
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	50		 push	 eax
  00038	ff 51 08	 call	 DWORD PTR [ecx+8]
  0003b	89 1e		 mov	 DWORD PTR [esi], ebx
$L56442:

; 405  :     GXRELEASE(m_pDeclObj);

  0003d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00040	3b c3		 cmp	 eax, ebx
  00042	74 09		 je	 SHORT $L56446
  00044	8b 08		 mov	 ecx, DWORD PTR [eax]
  00046	50		 push	 eax
  00047	ff 51 08	 call	 DWORD PTR [ecx+8]
  0004a	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
$L56446:
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi

; 406  : 
; 407  :     return S_OK;

  0004f	33 c0		 xor	 eax, eax
  00051	5b		 pop	 ebx

; 408  : }

  00052	c3		 ret	 0
?CreateEmptyOutline@CNPatchOutline@@QAEJXZ ENDP		; CNPatchOutline::CreateEmptyOutline
_TEXT	ENDS
PUBLIC	??$AddOutlineLineSegments@G@@YAXPAGK0@Z		; AddOutlineLineSegments<unsigned short>
; Function compile flags: /Ogs
;	COMDAT ??$AddOutlineLineSegments@G@@YAXPAGK0@Z
_TEXT	SEGMENT
_pwNPatchFaceIndices$ = 8				; size = 4
_cFacesCurLine$ = 12					; size = 4
_cSegments$ = 12					; size = 4
_pwLineIndicesOut$ = 16					; size = 4
??$AddOutlineLineSegments@G@@YAXPAGK0@Z PROC NEAR	; AddOutlineLineSegments<unsigned short>, COMDAT

; 135  :     pwLineIndicesOut++;
; 136  : 
; 137  :     GXASSERT(pwLineIndicesOrig + cSegments * 2 * 3 == pwLineIndicesOut);
; 138  : }

  00000	8b ff		 npad	 2

; 74   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 75   :     DWORD cFacesCurLine;
; 76   :     DWORD iLevel;
; 77   :     DWORD iFaceCur;
; 78   : 
; 79   :     UINT_IDX *pwLineIndicesOrig = pwLineIndicesOut;
; 80   : 
; 81   :     // first deal with all triangles up to the last "strip" of tesselate triangles (three sides of lines, not just two for that row)
; 82   :     cFacesCurLine = 1;
; 83   :     for (iLevel = 0; iLevel < cSegments-1; iLevel++)

  00005	8b 45 0c	 mov	 eax, DWORD PTR _cSegments$[ebp]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _pwNPatchFaceIndices$[ebp]
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	33 f6		 xor	 esi, esi
  0000f	46		 inc	 esi
  00010	48		 dec	 eax
  00011	6a 02		 push	 2
  00013	5a		 pop	 edx
  00014	74 45		 je	 SHORT $L56521
  00016	8b f8		 mov	 edi, eax
  00018	6a 06		 push	 6
  0001a	8d 44 3f 01	 lea	 eax, DWORD PTR [edi+edi+1]
  0001e	5e		 pop	 esi
  0001f	89 45 0c	 mov	 DWORD PTR _cFacesCurLine$[ebp], eax
  00022	8b 45 10	 mov	 eax, DWORD PTR _pwLineIndicesOut$[ebp]
  00025	53		 push	 ebx
$L56455:

; 84   :     {
; 85   :         // Add the left edge
; 86   :         *pwLineIndicesOut = pwNPatchFaceIndices[0];

  00026	66 8b 19	 mov	 bx, WORD PTR [ecx]
  00029	66 89 18	 mov	 WORD PTR [eax], bx

; 87   :         pwLineIndicesOut++;
; 88   :         *pwLineIndicesOut = pwNPatchFaceIndices[1];

  0002c	66 8b 59 02	 mov	 bx, WORD PTR [ecx+2]
  00030	03 c2		 add	 eax, edx
  00032	66 89 18	 mov	 WORD PTR [eax], bx

; 89   :         pwLineIndicesOut++;
; 90   : 
; 91   :         // skip the interior triangles of this strip
; 92   :         pwNPatchFaceIndices += 3 * (cFacesCurLine - 1);

  00035	8d 4c 31 fa	 lea	 ecx, DWORD PTR [ecx+esi-6]

; 93   : 
; 94   :         // add the right edge
; 95   :         *pwLineIndicesOut = pwNPatchFaceIndices[0];

  00039	66 8b 19	 mov	 bx, WORD PTR [ecx]
  0003c	03 c2		 add	 eax, edx
  0003e	66 89 18	 mov	 WORD PTR [eax], bx

; 96   :         pwLineIndicesOut++;
; 97   :         *pwLineIndicesOut = pwNPatchFaceIndices[2];

  00041	66 8b 59 04	 mov	 bx, WORD PTR [ecx+4]
  00045	03 c2		 add	 eax, edx
  00047	66 89 18	 mov	 WORD PTR [eax], bx

; 98   :         pwLineIndicesOut++;

  0004a	03 c2		 add	 eax, edx

; 99   :         pwNPatchFaceIndices += 3;

  0004c	83 c1 06	 add	 ecx, 6

; 100  : 
; 101  :         cFacesCurLine += 2;        

  0004f	83 c6 0c	 add	 esi, 12			; 0000000cH
  00052	4f		 dec	 edi
  00053	75 d1		 jne	 SHORT $L56455
  00055	8b 75 0c	 mov	 esi, DWORD PTR _cFacesCurLine$[ebp]
  00058	5b		 pop	 ebx
  00059	eb 03		 jmp	 SHORT $L56457
$L56521:

; 75   :     DWORD cFacesCurLine;
; 76   :     DWORD iLevel;
; 77   :     DWORD iFaceCur;
; 78   : 
; 79   :     UINT_IDX *pwLineIndicesOrig = pwLineIndicesOut;
; 80   : 
; 81   :     // first deal with all triangles up to the last "strip" of tesselate triangles (three sides of lines, not just two for that row)
; 82   :     cFacesCurLine = 1;
; 83   :     for (iLevel = 0; iLevel < cSegments-1; iLevel++)

  0005b	8b 45 10	 mov	 eax, DWORD PTR _pwLineIndicesOut$[ebp]
$L56457:

; 102  :     }
; 103  : 
; 104  :     // add the left edge
; 105  :     *pwLineIndicesOut = pwNPatchFaceIndices[0];

  0005e	66 8b 39	 mov	 di, WORD PTR [ecx]
  00061	66 89 38	 mov	 WORD PTR [eax], di

; 106  :     pwLineIndicesOut++;
; 107  :     *pwLineIndicesOut = pwNPatchFaceIndices[1];

  00064	66 8b 79 02	 mov	 di, WORD PTR [ecx+2]
  00068	03 c2		 add	 eax, edx
  0006a	66 89 38	 mov	 WORD PTR [eax], di

; 108  :     pwLineIndicesOut++;

  0006d	03 c2		 add	 eax, edx

; 109  : 
; 110  :     // add the bottom edges of all triangles in the middle of the bottom strip
; 111  :     if (cFacesCurLine > 1)

  0006f	83 fe 01	 cmp	 esi, 1
  00072	76 21		 jbe	 SHORT $L56461

; 112  :     {
; 113  :         // add the bottom edge
; 114  :         for (iFaceCur = 0; iFaceCur < cFacesCurLine - 2; iFaceCur += 2)

  00074	83 c6 fe	 add	 esi, -2			; fffffffeH
  00077	74 1c		 je	 SHORT $L56461
  00079	4e		 dec	 esi
  0007a	d1 ee		 shr	 esi, 1
  0007c	46		 inc	 esi
$L56459:

; 115  :         {
; 116  :             *pwLineIndicesOut = pwNPatchFaceIndices[1];

  0007d	66 8b 79 02	 mov	 di, WORD PTR [ecx+2]
  00081	66 89 38	 mov	 WORD PTR [eax], di

; 117  :             pwLineIndicesOut++;
; 118  :             *pwLineIndicesOut = pwNPatchFaceIndices[2];

  00084	66 8b 79 04	 mov	 di, WORD PTR [ecx+4]
  00088	03 c2		 add	 eax, edx
  0008a	66 89 38	 mov	 WORD PTR [eax], di

; 119  :             pwLineIndicesOut++;

  0008d	03 c2		 add	 eax, edx

; 120  : 
; 121  :             pwNPatchFaceIndices += 6;

  0008f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00092	4e		 dec	 esi
  00093	75 e8		 jne	 SHORT $L56459
$L56461:

; 122  :         }
; 123  :     }
; 124  : 
; 125  :     // add the right edge of the last triangle
; 126  :     *pwLineIndicesOut = pwNPatchFaceIndices[0];

  00095	66 8b 31	 mov	 si, WORD PTR [ecx]
  00098	66 89 30	 mov	 WORD PTR [eax], si

; 127  :     pwLineIndicesOut++;
; 128  :     *pwLineIndicesOut = pwNPatchFaceIndices[2];

  0009b	66 8b 71 04	 mov	 si, WORD PTR [ecx+4]
  0009f	03 c2		 add	 eax, edx
  000a1	66 89 30	 mov	 WORD PTR [eax], si

; 129  :     pwLineIndicesOut++;

  000a4	03 c2		 add	 eax, edx

; 130  : 
; 131  :     // add the bottom edge of the last triangle
; 132  :     *pwLineIndicesOut = pwNPatchFaceIndices[1];

  000a6	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  000aa	66 89 10	 mov	 WORD PTR [eax], dx

; 133  :     pwLineIndicesOut++;
; 134  :     *pwLineIndicesOut = pwNPatchFaceIndices[2];

  000ad	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  000b1	5f		 pop	 edi
  000b2	66 89 48 02	 mov	 WORD PTR [eax+2], cx
  000b6	5e		 pop	 esi

; 135  :     pwLineIndicesOut++;
; 136  : 
; 137  :     GXASSERT(pwLineIndicesOrig + cSegments * 2 * 3 == pwLineIndicesOut);
; 138  : }

  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
??$AddOutlineLineSegments@G@@YAXPAGK0@Z ENDP		; AddOutlineLineSegments<unsigned short>
_TEXT	ENDS
PUBLIC	??$AddOutlineLineSegments@I@@YAXPAIK0@Z		; AddOutlineLineSegments<unsigned int>
; Function compile flags: /Ogs
;	COMDAT ??$AddOutlineLineSegments@I@@YAXPAIK0@Z
_TEXT	SEGMENT
_pwNPatchFaceIndices$ = 8				; size = 4
_cFacesCurLine$ = 12					; size = 4
_cSegments$ = 12					; size = 4
_pwLineIndicesOut$ = 16					; size = 4
??$AddOutlineLineSegments@I@@YAXPAIK0@Z PROC NEAR	; AddOutlineLineSegments<unsigned int>, COMDAT

; 135  :     pwLineIndicesOut++;
; 136  : 
; 137  :     GXASSERT(pwLineIndicesOrig + cSegments * 2 * 3 == pwLineIndicesOut);
; 138  : }

  00000	8b ff		 npad	 2

; 74   : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 75   :     DWORD cFacesCurLine;
; 76   :     DWORD iLevel;
; 77   :     DWORD iFaceCur;
; 78   : 
; 79   :     UINT_IDX *pwLineIndicesOrig = pwLineIndicesOut;
; 80   : 
; 81   :     // first deal with all triangles up to the last "strip" of tesselate triangles (three sides of lines, not just two for that row)
; 82   :     cFacesCurLine = 1;
; 83   :     for (iLevel = 0; iLevel < cSegments-1; iLevel++)

  00005	8b 45 0c	 mov	 eax, DWORD PTR _cSegments$[ebp]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _pwNPatchFaceIndices$[ebp]
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	33 f6		 xor	 esi, esi
  0000f	46		 inc	 esi
  00010	48		 dec	 eax
  00011	6a 04		 push	 4
  00013	5a		 pop	 edx
  00014	74 3d		 je	 SHORT $L56527
  00016	8b f8		 mov	 edi, eax
  00018	6a 0c		 push	 12			; 0000000cH
  0001a	8d 44 3f 01	 lea	 eax, DWORD PTR [edi+edi+1]
  0001e	5e		 pop	 esi
  0001f	89 45 0c	 mov	 DWORD PTR _cFacesCurLine$[ebp], eax
  00022	8b 45 10	 mov	 eax, DWORD PTR _pwLineIndicesOut$[ebp]
  00025	53		 push	 ebx
$L56468:

; 84   :     {
; 85   :         // Add the left edge
; 86   :         *pwLineIndicesOut = pwNPatchFaceIndices[0];

  00026	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00028	89 18		 mov	 DWORD PTR [eax], ebx

; 87   :         pwLineIndicesOut++;
; 88   :         *pwLineIndicesOut = pwNPatchFaceIndices[1];

  0002a	8b 59 04	 mov	 ebx, DWORD PTR [ecx+4]
  0002d	03 c2		 add	 eax, edx
  0002f	89 18		 mov	 DWORD PTR [eax], ebx

; 89   :         pwLineIndicesOut++;
; 90   : 
; 91   :         // skip the interior triangles of this strip
; 92   :         pwNPatchFaceIndices += 3 * (cFacesCurLine - 1);

  00031	8d 4c 31 f4	 lea	 ecx, DWORD PTR [ecx+esi-12]

; 93   : 
; 94   :         // add the right edge
; 95   :         *pwLineIndicesOut = pwNPatchFaceIndices[0];

  00035	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00037	03 c2		 add	 eax, edx
  00039	89 18		 mov	 DWORD PTR [eax], ebx

; 96   :         pwLineIndicesOut++;
; 97   :         *pwLineIndicesOut = pwNPatchFaceIndices[2];

  0003b	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  0003e	03 c2		 add	 eax, edx
  00040	89 18		 mov	 DWORD PTR [eax], ebx

; 98   :         pwLineIndicesOut++;

  00042	03 c2		 add	 eax, edx

; 99   :         pwNPatchFaceIndices += 3;

  00044	83 c1 0c	 add	 ecx, 12			; 0000000cH

; 100  : 
; 101  :         cFacesCurLine += 2;        

  00047	83 c6 18	 add	 esi, 24			; 00000018H
  0004a	4f		 dec	 edi
  0004b	75 d9		 jne	 SHORT $L56468
  0004d	8b 75 0c	 mov	 esi, DWORD PTR _cFacesCurLine$[ebp]
  00050	5b		 pop	 ebx
  00051	eb 03		 jmp	 SHORT $L56470
$L56527:

; 75   :     DWORD cFacesCurLine;
; 76   :     DWORD iLevel;
; 77   :     DWORD iFaceCur;
; 78   : 
; 79   :     UINT_IDX *pwLineIndicesOrig = pwLineIndicesOut;
; 80   : 
; 81   :     // first deal with all triangles up to the last "strip" of tesselate triangles (three sides of lines, not just two for that row)
; 82   :     cFacesCurLine = 1;
; 83   :     for (iLevel = 0; iLevel < cSegments-1; iLevel++)

  00053	8b 45 10	 mov	 eax, DWORD PTR _pwLineIndicesOut$[ebp]
$L56470:

; 102  :     }
; 103  : 
; 104  :     // add the left edge
; 105  :     *pwLineIndicesOut = pwNPatchFaceIndices[0];

  00056	8b 39		 mov	 edi, DWORD PTR [ecx]
  00058	89 38		 mov	 DWORD PTR [eax], edi

; 106  :     pwLineIndicesOut++;
; 107  :     *pwLineIndicesOut = pwNPatchFaceIndices[1];

  0005a	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  0005d	03 c2		 add	 eax, edx
  0005f	89 38		 mov	 DWORD PTR [eax], edi

; 108  :     pwLineIndicesOut++;

  00061	03 c2		 add	 eax, edx

; 109  : 
; 110  :     // add the bottom edges of all triangles in the middle of the bottom strip
; 111  :     if (cFacesCurLine > 1)

  00063	83 fe 01	 cmp	 esi, 1
  00066	76 1d		 jbe	 SHORT $L56474

; 112  :     {
; 113  :         // add the bottom edge
; 114  :         for (iFaceCur = 0; iFaceCur < cFacesCurLine - 2; iFaceCur += 2)

  00068	83 c6 fe	 add	 esi, -2			; fffffffeH
  0006b	74 18		 je	 SHORT $L56474
  0006d	4e		 dec	 esi
  0006e	d1 ee		 shr	 esi, 1
  00070	46		 inc	 esi
$L56472:

; 115  :         {
; 116  :             *pwLineIndicesOut = pwNPatchFaceIndices[1];

  00071	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00074	89 38		 mov	 DWORD PTR [eax], edi

; 117  :             pwLineIndicesOut++;
; 118  :             *pwLineIndicesOut = pwNPatchFaceIndices[2];

  00076	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  00079	03 c2		 add	 eax, edx
  0007b	89 38		 mov	 DWORD PTR [eax], edi

; 119  :             pwLineIndicesOut++;

  0007d	03 c2		 add	 eax, edx

; 120  : 
; 121  :             pwNPatchFaceIndices += 6;

  0007f	83 c1 18	 add	 ecx, 24			; 00000018H
  00082	4e		 dec	 esi
  00083	75 ec		 jne	 SHORT $L56472
$L56474:

; 122  :         }
; 123  :     }
; 124  : 
; 125  :     // add the right edge of the last triangle
; 126  :     *pwLineIndicesOut = pwNPatchFaceIndices[0];

  00085	8b 31		 mov	 esi, DWORD PTR [ecx]
  00087	89 30		 mov	 DWORD PTR [eax], esi

; 127  :     pwLineIndicesOut++;
; 128  :     *pwLineIndicesOut = pwNPatchFaceIndices[2];

  00089	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  0008c	03 c2		 add	 eax, edx
  0008e	89 30		 mov	 DWORD PTR [eax], esi

; 129  :     pwLineIndicesOut++;

  00090	03 c2		 add	 eax, edx

; 130  : 
; 131  :     // add the bottom edge of the last triangle
; 132  :     *pwLineIndicesOut = pwNPatchFaceIndices[1];

  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	89 10		 mov	 DWORD PTR [eax], edx

; 133  :     pwLineIndicesOut++;
; 134  :     *pwLineIndicesOut = pwNPatchFaceIndices[2];

  00097	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0009a	5f		 pop	 edi
  0009b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0009e	5e		 pop	 esi

; 135  :     pwLineIndicesOut++;
; 136  : 
; 137  :     GXASSERT(pwLineIndicesOrig + cSegments * 2 * 3 == pwLineIndicesOut);
; 138  : }

  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
??$AddOutlineLineSegments@I@@YAXPAIK0@Z ENDP		; AddOutlineLineSegments<unsigned int>
_TEXT	ENDS
PUBLIC	?Init@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@K@Z	; CNPatchOutline::Init
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_D3DXGetDeclVertexSize@8:NEAR
; Function compile flags: /Ogs
;	COMDAT ?Init@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@K@Z
_TEXT	SEGMENT
_Caps$ = -344						; size = 304
_pbFaceIndices$ = -40					; size = 4
_pbLineIndices$ = -36					; size = 4
_b16BitIndex$ = -32					; size = 4
tv323 = -28						; size = 4
_cBytesPerIndex$ = -28					; size = 4
_cFacesOut$56538 = -24					; size = 4
_rgaeAttributeTableMesh$ = -20				; size = 4
tv579 = -16						; size = 4
_cOrigFaces$ = -16					; size = 4
_cFaces$ = -16						; size = 4
tv261 = -12						; size = 4
_cFacesCur$ = -12					; size = 4
tv588 = -8						; size = 4
_pbLineIndicesCur$ = -8					; size = 4
_iAttr$ = -4						; size = 4
_hr$ = -4						; size = 4
_pbFaceIndicesCur$ = 8					; size = 4
_ptmMesh$ = 8						; size = 4
_cTesselateSegments$ = 12				; size = 4
?Init@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@K@Z PROC NEAR ; CNPatchOutline::Init, COMDAT
; _this$ = ecx

; 285  : }

  00000	8b ff		 npad	 2

; 142  : {

  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 58 01 00
	00		 sub	 esp, 344		; 00000158H
  0000b	53		 push	 ebx
  0000c	56		 push	 esi

; 143  :     HRESULT hr = S_OK;
; 144  :     BOOL b16BitIndex;
; 145  :     DWORD cBytesPerIndex;
; 146  :     DWORD iPoint;
; 147  :     DWORD iOrigFace;
; 148  :     DWORD cFaces;
; 149  :     DWORD cOrigFaces;
; 150  :     D3DXATTRIBUTERANGE *rgaeAttributeTableMesh = NULL;
; 151  :     DWORD *rgdwAttr = NULL;
; 152  :     PBYTE pbFaceIndices = NULL;
; 153  :     PBYTE pbLineIndices = NULL;
; 154  :     PBYTE pbSrc;
; 155  :     PBYTE pbDest;
; 156  :     DWORD iLineOffset;
; 157  :     DWORD iAttr;
; 158  :     DWORD dwNeighbor;
; 159  :     DWORD iFaceEnd;
; 160  :     BOOL bCrease;
; 161  :     DWORD cFacesCur;
; 162  :     D3DCAPS9 Caps;
; 163  :     PBYTE pbFaceIndicesCur;
; 164  :     PBYTE pbLineIndicesCur;
; 165  :     DWORD cNPatchFacesPerFace;
; 166  : 
; 167  :     // is the mesh 16 bit?
; 168  :     b16BitIndex = !(ptmMesh->GetOptions() & D3DXMESH_32BIT);

  0000d	8b 75 08	 mov	 esi, DWORD PTR _ptmMesh$[ebp]
  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	57		 push	 edi
  00013	33 ff		 xor	 edi, edi
  00015	56		 push	 esi
  00016	8b d9		 mov	 ebx, ecx
  00018	89 7d ec	 mov	 DWORD PTR _rgaeAttributeTableMesh$[ebp], edi
  0001b	89 7d d8	 mov	 DWORD PTR _pbFaceIndices$[ebp], edi
  0001e	89 7d dc	 mov	 DWORD PTR _pbLineIndices$[ebp], edi
  00021	ff 50 24	 call	 DWORD PTR [eax+36]
  00024	f7 d0		 not	 eax
  00026	83 e0 01	 and	 eax, 1
  00029	89 45 e0	 mov	 DWORD PTR _b16BitIndex$[ebp], eax

; 169  :     cBytesPerIndex = (b16BitIndex ? 2:4);

  0002c	57		 push	 edi
  0002d	58		 pop	 eax
  0002e	0f 94 c0	 sete	 al

; 170  : 
; 171  :     // get the number of faces
; 172  :     cFaces = ptmMesh->GetNumFaces();

  00031	56		 push	 esi
  00032	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00036	89 45 e4	 mov	 DWORD PTR _cBytesPerIndex$[ebp], eax
  00039	8b 06		 mov	 eax, DWORD PTR [esi]
  0003b	ff 50 10	 call	 DWORD PTR [eax+16]

; 173  : 
; 174  :     hr = CreateEmptyOutline();

  0003e	8b cb		 mov	 ecx, ebx
  00040	89 45 f0	 mov	 DWORD PTR _cFaces$[ebp], eax
  00043	e8 00 00 00 00	 call	 ?CreateEmptyOutline@CNPatchOutline@@QAEJXZ ; CNPatchOutline::CreateEmptyOutline

; 175  :     if (FAILED(hr))

  00048	3b c7		 cmp	 eax, edi
  0004a	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  0004d	0f 8c 60 02 00
	00		 jl	 $e_Exit$56308

; 176  :         goto e_Exit;
; 177  : 
; 178  :     ptmMesh->GetDeclaration(m_pDecl);

  00053	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00055	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  00058	50		 push	 eax
  00059	56		 push	 esi
  0005a	ff 51 1c	 call	 DWORD PTR [ecx+28]

; 179  :     m_cBytesPerVertex = D3DXGetDeclVertexSize(m_pDecl, 0);

  0005d	57		 push	 edi
  0005e	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _D3DXGetDeclVertexSize@8

; 180  : 
; 181  :     ptmMesh->GetDevice(&m_pDevice);

  00067	53		 push	 ebx
  00068	89 83 14 02 00
	00		 mov	 DWORD PTR [ebx+532], eax
  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	56		 push	 esi
  00071	ff 50 28	 call	 DWORD PTR [eax+40]

; 182  : 
; 183  :     hr = m_pDevice->CreateVertexDeclaration(m_pDecl, &m_pDeclObj);

  00074	8b 03		 mov	 eax, DWORD PTR [ebx]
  00076	8b 10		 mov	 edx, DWORD PTR [eax]
  00078	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
  0007b	51		 push	 ecx
  0007c	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  0007f	51		 push	 ecx
  00080	50		 push	 eax
  00081	ff 92 58 01 00
	00		 call	 DWORD PTR [edx+344]

; 184  :     if (FAILED(hr))

  00087	3b c7		 cmp	 eax, edi
  00089	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  0008c	0f 8c 21 02 00
	00		 jl	 $e_Exit$56308

; 185  :         goto e_Exit;
; 186  : 
; 187  : 
; 188  :     hr = ptmMesh->GetAttributeTable(NULL, &m_caeAttributeTable);

  00092	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00094	8d 83 20 02 00
	00		 lea	 eax, DWORD PTR [ebx+544]
  0009a	50		 push	 eax
  0009b	57		 push	 edi
  0009c	56		 push	 esi
  0009d	ff 51 4c	 call	 DWORD PTR [ecx+76]

; 189  :     if (FAILED(hr))

  000a0	3b c7		 cmp	 eax, edi
  000a2	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  000a5	0f 8c 08 02 00
	00		 jl	 $e_Exit$56308

; 190  :         goto e_Exit;
; 191  : 
; 192  :     // check for no attribute table and/or no adjacency
; 193  :     if (m_caeAttributeTable == 0) 

  000ab	8b 83 20 02 00
	00		 mov	 eax, DWORD PTR [ebx+544]
  000b1	3b c7		 cmp	 eax, edi
  000b3	0f 84 fa 01 00
	00		 je	 $e_Exit$56308

; 194  :     {
; 195  :         // not attribute sorted!  just return for now
; 196  :         goto e_Exit;
; 197  :     }
; 198  : 
; 199  :     rgaeAttributeTableMesh = new D3DXATTRIBUTERANGE[m_caeAttributeTable];

  000b9	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000bc	c1 e0 02	 shl	 eax, 2
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000c5	89 45 ec	 mov	 DWORD PTR _rgaeAttributeTableMesh$[ebp], eax

; 200  :     m_rgaeAttributeTable = new D3DXATTRIBUTERANGE[m_caeAttributeTable];

  000c8	8b 83 20 02 00
	00		 mov	 eax, DWORD PTR [ebx+544]
  000ce	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000d1	c1 e0 02	 shl	 eax, 2
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 201  :     if ((rgaeAttributeTableMesh == NULL) || (rgaeAttributeTableMesh == NULL))

  000da	39 7d ec	 cmp	 DWORD PTR _rgaeAttributeTableMesh$[ebp], edi
  000dd	59		 pop	 ecx
  000de	59		 pop	 ecx
  000df	89 83 1c 02 00
	00		 mov	 DWORD PTR [ebx+540], eax
  000e5	0f 84 c1 01 00
	00		 je	 $L56323

; 204  :         goto e_Exit;
; 205  :     }
; 206  : 
; 207  :     CalculateCounts(cTesselateSegments, &cNPatchFacesPerFace);

  000eb	8b 45 0c	 mov	 eax, DWORD PTR _cTesselateSegments$[ebp]
  000ee	33 d2		 xor	 edx, edx
  000f0	42		 inc	 edx
  000f1	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  000f4	3b cf		 cmp	 ecx, edi
  000f6	89 55 e8	 mov	 DWORD PTR _cFacesOut$56538[ebp], edx
  000f9	76 0d		 jbe	 SHORT $L56541
  000fb	89 4d f4	 mov	 DWORD PTR tv261[ebp], ecx
$L56539:
  000fe	42		 inc	 edx
  000ff	42		 inc	 edx
  00100	01 55 e8	 add	 DWORD PTR _cFacesOut$56538[ebp], edx
  00103	ff 4d f4	 dec	 DWORD PTR tv261[ebp]
  00106	75 f6		 jne	 SHORT $L56539
$L56541:

; 208  :     m_cLinesPerOrigFace = cTesselateSegments * 3;

  00108	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0010b	89 83 18 02 00
	00		 mov	 DWORD PTR [ebx+536], eax

; 209  : 
; 210  :     // should be the same number of new faces in relation to the old
; 211  :     GXASSERT((cFaces % cNPatchFacesPerFace) == 0);
; 212  :     cOrigFaces = cFaces / cNPatchFacesPerFace;

  00111	8b 45 f0	 mov	 eax, DWORD PTR _cFaces$[ebp]
  00114	33 d2		 xor	 edx, edx
  00116	f7 75 e8	 div	 DWORD PTR _cFacesOut$56538[ebp]

; 213  : 
; 214  :     hr = ptmMesh->GetAttributeTable(rgaeAttributeTableMesh, NULL);

  00119	57		 push	 edi
  0011a	ff 75 ec	 push	 DWORD PTR _rgaeAttributeTableMesh$[ebp]
  0011d	56		 push	 esi
  0011e	89 45 f0	 mov	 DWORD PTR _cOrigFaces$[ebp], eax
  00121	8b 06		 mov	 eax, DWORD PTR [esi]
  00123	ff 50 4c	 call	 DWORD PTR [eax+76]

; 215  :     if (FAILED(hr))

  00126	3b c7		 cmp	 eax, edi
  00128	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  0012b	0f 8c 82 01 00
	00		 jl	 $e_Exit$56308

; 216  :         goto e_Exit;
; 217  : 
; 218  :     ptmMesh->LockIndexBuffer(D3DLOCK_READONLY, (LPVOID*)&pbFaceIndices);

  00131	8b 06		 mov	 eax, DWORD PTR [esi]
  00133	8d 4d d8	 lea	 ecx, DWORD PTR _pbFaceIndices$[ebp]
  00136	51		 push	 ecx
  00137	6a 10		 push	 16			; 00000010H
  00139	56		 push	 esi
  0013a	ff 50 44	 call	 DWORD PTR [eax+68]

; 219  : 
; 220  :     // now initialize the edge attribute table
; 221  :     cFacesCur = 0;
; 222  :     for (iAttr = 0; iAttr < m_caeAttributeTable; iAttr++)

  0013d	39 bb 20 02 00
	00		 cmp	 DWORD PTR [ebx+544], edi
  00143	89 7d f4	 mov	 DWORD PTR _cFacesCur$[ebp], edi
  00146	89 7d fc	 mov	 DWORD PTR _iAttr$[ebp], edi
  00149	76 6e		 jbe	 SHORT $L56333
  0014b	8b 83 1c 02 00
	00		 mov	 eax, DWORD PTR [ebx+540]
  00151	33 d2		 xor	 edx, edx
  00153	89 55 f8	 mov	 DWORD PTR tv588[ebp], edx
  00156	eb 03		 jmp	 SHORT $L56331
$L56548:

; 216  :         goto e_Exit;
; 217  : 
; 218  :     ptmMesh->LockIndexBuffer(D3DLOCK_READONLY, (LPVOID*)&pbFaceIndices);

  00158	8b 55 f8	 mov	 edx, DWORD PTR tv588[ebp]
$L56331:

; 223  :     {
; 224  :         m_rgaeAttributeTable[iAttr] = rgaeAttributeTableMesh[iAttr];

  0015b	8b 4d ec	 mov	 ecx, DWORD PTR _rgaeAttributeTableMesh$[ebp]
  0015e	8d 34 0a	 lea	 esi, DWORD PTR [edx+ecx]
  00161	8d 3c 02	 lea	 edi, DWORD PTR [edx+eax]
  00164	6a 05		 push	 5
  00166	59		 pop	 ecx
  00167	f3 a5		 rep movsd

; 225  : 
; 226  :         // 3 * Segments primitives per original triangle - original triangle = NewFaces / NumNewFacesPerOld
; 227  :         m_rgaeAttributeTable[iAttr].FaceCount = (m_rgaeAttributeTable[iAttr].FaceCount / cNPatchFacesPerFace) * cTesselateSegments * 3;

  00169	8b 83 1c 02 00
	00		 mov	 eax, DWORD PTR [ebx+540]
  0016f	8d 4c 02 08	 lea	 ecx, DWORD PTR [edx+eax+8]
  00173	8b 01		 mov	 eax, DWORD PTR [ecx]
  00175	33 d2		 xor	 edx, edx
  00177	f7 75 e8	 div	 DWORD PTR _cFacesOut$56538[ebp]

; 228  : 
; 229  :         // setup the correct face start
; 230  :         m_rgaeAttributeTable[iAttr].FaceStart = cFacesCur;

  0017a	8b 55 f8	 mov	 edx, DWORD PTR tv588[ebp]
  0017d	83 c2 14	 add	 edx, 20			; 00000014H
  00180	89 55 f8	 mov	 DWORD PTR tv588[ebp], edx
  00183	0f af 45 0c	 imul	 eax, DWORD PTR _cTesselateSegments$[ebp]
  00187	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0018a	89 01		 mov	 DWORD PTR [ecx], eax
  0018c	8b 4d f4	 mov	 ecx, DWORD PTR _cFacesCur$[ebp]
  0018f	8b 83 1c 02 00
	00		 mov	 eax, DWORD PTR [ebx+540]
  00195	89 4c 02 f0	 mov	 DWORD PTR [edx+eax-16], ecx

; 231  :         cFacesCur += m_rgaeAttributeTable[iAttr].FaceCount;

  00199	8b 83 1c 02 00
	00		 mov	 eax, DWORD PTR [ebx+540]
  0019f	03 4c 02 f4	 add	 ecx, DWORD PTR [edx+eax-12]
  001a3	ff 45 fc	 inc	 DWORD PTR _iAttr$[ebp]
  001a6	89 4d f4	 mov	 DWORD PTR _cFacesCur$[ebp], ecx
  001a9	8b 4d fc	 mov	 ecx, DWORD PTR _iAttr$[ebp]
  001ac	3b 8b 20 02 00
	00		 cmp	 ecx, DWORD PTR [ebx+544]
  001b2	72 a4		 jb	 SHORT $L56548
  001b4	8b 75 08	 mov	 esi, DWORD PTR _ptmMesh$[ebp]
  001b7	33 ff		 xor	 edi, edi
$L56333:

; 232  :     }
; 233  : 
; 234  :     m_pDevice->GetDeviceCaps(&Caps);

  001b9	8b 03		 mov	 eax, DWORD PTR [ebx]
  001bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  001bd	8d 95 a8 fe ff
	ff		 lea	 edx, DWORD PTR _Caps$[ebp]
  001c3	52		 push	 edx
  001c4	50		 push	 eax
  001c5	ff 51 1c	 call	 DWORD PTR [ecx+28]

; 235  : 
; 236  :     // if there are too many vertices, or the max vertex index is below 16bit (means no 32 bit support)
; 237  :     //    then we need to emulate
; 238  :     if (!b16BitIndex && ((Caps.MaxVertexIndex < ptmMesh->GetNumVertices()) || (Caps.MaxVertexIndex <= 0xffff) || (Caps.MaxPrimitiveCount < cFacesCur)))

  001c8	39 7d e0	 cmp	 DWORD PTR _b16BitIndex$[ebp], edi
  001cb	75 31		 jne	 SHORT $L56552
  001cd	8b 06		 mov	 eax, DWORD PTR [esi]
  001cf	56		 push	 esi
  001d0	ff 50 14	 call	 DWORD PTR [eax+20]
  001d3	39 85 60 ff ff
	ff		 cmp	 DWORD PTR _Caps$[ebp+184], eax
  001d9	72 17		 jb	 SHORT $L56335
  001db	81 bd 60 ff ff
	ff ff ff 00 00	 cmp	 DWORD PTR _Caps$[ebp+184], 65535 ; 0000ffffH
  001e5	76 0b		 jbe	 SHORT $L56335
  001e7	8b 45 f4	 mov	 eax, DWORD PTR _cFacesCur$[ebp]
  001ea	39 85 5c ff ff
	ff		 cmp	 DWORD PTR _Caps$[ebp+180], eax
  001f0	73 0c		 jae	 SHORT $L56552
$L56335:

; 239  :     {
; 240  :         m_bEmulate32BitIndex = TRUE;

  001f2	c7 83 24 02 00
	00 01 00 00 00	 mov	 DWORD PTR [ebx+548], 1

; 241  :     }
; 242  :     else

  001fc	eb 06		 jmp	 SHORT $L56336
$L56552:

; 243  :     {
; 244  :         m_bEmulate32BitIndex = FALSE;

  001fe	89 bb 24 02 00
	00		 mov	 DWORD PTR [ebx+548], edi
$L56336:

; 245  :     }
; 246  : 
; 247  :     hr = m_pDevice->CreateIndexBuffer(cOrigFaces * 3 * cTesselateSegments * 2 * cBytesPerIndex, D3DUSAGE_SOFTWAREPROCESSING, 
; 248  :                                         (b16BitIndex ? D3DFMT_INDEX16:D3DFMT_INDEX32),
; 249  :                                         D3DPOOL_MANAGED, &m_pIndexBuffer, NULL);

  00204	57		 push	 edi
  00205	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00208	50		 push	 eax
  00209	8b 45 e0	 mov	 eax, DWORD PTR _b16BitIndex$[ebp]
  0020c	f7 d8		 neg	 eax
  0020e	1b c0		 sbb	 eax, eax
  00210	83 c0 66	 add	 eax, 102		; 00000066H
  00213	6a 01		 push	 1
  00215	50		 push	 eax
  00216	8b 45 f0	 mov	 eax, DWORD PTR _cOrigFaces$[ebp]
  00219	0f af 45 e4	 imul	 eax, DWORD PTR _cBytesPerIndex$[ebp]
  0021d	0f af 45 0c	 imul	 eax, DWORD PTR _cTesselateSegments$[ebp]
  00221	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00223	8b 11		 mov	 edx, DWORD PTR [ecx]
  00225	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00228	6a 10		 push	 16			; 00000010H
  0022a	d1 e0		 shl	 eax, 1
  0022c	50		 push	 eax
  0022d	51		 push	 ecx
  0022e	ff 52 6c	 call	 DWORD PTR [edx+108]

; 250  :     if (FAILED(hr))

  00231	33 ff		 xor	 edi, edi
  00233	3b c7		 cmp	 eax, edi
  00235	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00238	7c 79		 jl	 SHORT $e_Exit$56308

; 251  :         goto e_Exit;
; 252  : 
; 253  :     m_pIndexBuffer->Lock(0, 0, (PVOID*)&pbLineIndices, D3DLOCK_NOSYSLOCK);

  0023a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0023d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023f	68 00 08 00 00	 push	 2048			; 00000800H
  00244	8d 55 dc	 lea	 edx, DWORD PTR _pbLineIndices$[ebp]
  00247	52		 push	 edx
  00248	57		 push	 edi
  00249	57		 push	 edi
  0024a	50		 push	 eax
  0024b	ff 51 2c	 call	 DWORD PTR [ecx+44]

; 254  : 
; 255  : 
; 256  :     // next go through and fill the index buffer
; 257  :     pbFaceIndicesCur = pbFaceIndices;

  0024e	8b 45 d8	 mov	 eax, DWORD PTR _pbFaceIndices$[ebp]

; 258  :     pbLineIndicesCur = pbLineIndices;
; 259  :     for (iOrigFace = 0; iOrigFace < cOrigFaces; iOrigFace++)

  00251	8b 55 f0	 mov	 edx, DWORD PTR _cOrigFaces$[ebp]
  00254	3b d7		 cmp	 edx, edi
  00256	89 45 08	 mov	 DWORD PTR _pbFaceIndicesCur$[ebp], eax
  00259	8b 45 dc	 mov	 eax, DWORD PTR _pbLineIndices$[ebp]
  0025c	89 45 f8	 mov	 DWORD PTR _pbLineIndicesCur$[ebp], eax
  0025f	76 52		 jbe	 SHORT $e_Exit$56308
  00261	8b 45 e4	 mov	 eax, DWORD PTR _cBytesPerIndex$[ebp]
  00264	8b 4d e8	 mov	 ecx, DWORD PTR _cFacesOut$56538[ebp]
  00267	0f af c8	 imul	 ecx, eax
  0026a	0f af 45 0c	 imul	 eax, DWORD PTR _cTesselateSegments$[ebp]
  0026e	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00271	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  00274	89 4d f0	 mov	 DWORD PTR tv579[ebp], ecx
  00277	d1 e7		 shl	 edi, 1
  00279	89 55 e4	 mov	 DWORD PTR tv323[ebp], edx
$L56550:

; 260  :     {
; 261  :         if (b16BitIndex)

  0027c	83 7d e0 00	 cmp	 DWORD PTR _b16BitIndex$[ebp], 0

; 262  :         {
; 263  :             AddOutlineLineSegments<UINT16>((UINT16*)pbFaceIndicesCur, cTesselateSegments, (UINT16*)pbLineIndicesCur);

  00280	ff 75 f8	 push	 DWORD PTR _pbLineIndicesCur$[ebp]
  00283	ff 75 0c	 push	 DWORD PTR _cTesselateSegments$[ebp]
  00286	ff 75 08	 push	 DWORD PTR _pbFaceIndicesCur$[ebp]
  00289	74 07		 je	 SHORT $L56344
  0028b	e8 00 00 00 00	 call	 ??$AddOutlineLineSegments@G@@YAXPAGK0@Z ; AddOutlineLineSegments<unsigned short>

; 264  :         }
; 265  :         else

  00290	eb 05		 jmp	 SHORT $L56553
$L56344:

; 266  :         {
; 267  :             AddOutlineLineSegments<UINT32>((UINT32*)pbFaceIndicesCur, cTesselateSegments, (UINT32*)pbLineIndicesCur);

  00292	e8 00 00 00 00	 call	 ??$AddOutlineLineSegments@I@@YAXPAIK0@Z ; AddOutlineLineSegments<unsigned int>
$L56553:

; 268  :         }
; 269  : 
; 270  :         pbFaceIndicesCur += cBytesPerIndex * 3 * cNPatchFacesPerFace;

  00297	8b 45 f0	 mov	 eax, DWORD PTR tv579[ebp]
  0029a	01 45 08	 add	 DWORD PTR _pbFaceIndicesCur$[ebp], eax

; 271  :         pbLineIndicesCur += cBytesPerIndex * 2 * 3 * cTesselateSegments;

  0029d	01 7d f8	 add	 DWORD PTR _pbLineIndicesCur$[ebp], edi
  002a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a3	ff 4d e4	 dec	 DWORD PTR tv323[ebp]
  002a6	75 d4		 jne	 SHORT $L56550

; 272  :     }

  002a8	33 ff		 xor	 edi, edi
  002aa	eb 07		 jmp	 SHORT $e_Exit$56308
$L56323:

; 202  :     {
; 203  :         hr = E_OUTOFMEMORY;

  002ac	c7 45 fc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$e_Exit$56308:

; 273  : 
; 274  : e_Exit:
; 275  :     delete []rgaeAttributeTableMesh;

  002b3	ff 75 ec	 push	 DWORD PTR _rgaeAttributeTableMesh$[ebp]
  002b6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 276  :     delete []rgdwAttr;

  002bb	57		 push	 edi
  002bc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 277  : 
; 278  :     if (pbFaceIndices != NULL)

  002c1	39 7d d8	 cmp	 DWORD PTR _pbFaceIndices$[ebp], edi
  002c4	59		 pop	 ecx
  002c5	59		 pop	 ecx
  002c6	74 06		 je	 SHORT $L56364

; 279  :         ptmMesh->UnlockIndexBuffer();

  002c8	8b 06		 mov	 eax, DWORD PTR [esi]
  002ca	56		 push	 esi
  002cb	ff 50 48	 call	 DWORD PTR [eax+72]
$L56364:

; 280  : 
; 281  :     if (pbLineIndices != NULL)

  002ce	39 7d dc	 cmp	 DWORD PTR _pbLineIndices$[ebp], edi
  002d1	74 09		 je	 SHORT $L56365

; 282  :         m_pIndexBuffer->Unlock();

  002d3	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  002d6	8b 03		 mov	 eax, DWORD PTR [ebx]
  002d8	53		 push	 ebx
  002d9	ff 50 30	 call	 DWORD PTR [eax+48]
$L56365:

; 283  : 
; 284  :     return hr;

  002dc	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  002df	5f		 pop	 edi
  002e0	5e		 pop	 esi
  002e1	5b		 pop	 ebx

; 285  : }

  002e2	c9		 leave
  002e3	c2 08 00	 ret	 8
?Init@CNPatchOutline@@QAEJPAUID3DXBaseMesh@@K@Z ENDP	; CNPatchOutline::Init
_TEXT	ENDS
END
